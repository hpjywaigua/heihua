#include "Helper/Includes.h"
#include "Tools.h"
//KL NIKE JUST DO IT...
#include "obfuscate.h"
#include "Vector2.hpp"
#include "Vector3.hpp"
#include "Helper/fake_dlfcn.h"
#include "Iconcpp.h"
#include "Font.h"
#include "Icon.h"
#include "NIKE.h"
#include "MemoryTools.h"
#include "KittyMemory/MemoryPatch.h"
#include "KittyMemory/MemoryBackup.h"
#include "KittyMemory/MemoryBackup.cpp"
#include "KittyMemory/MemoryPatch.cpp"
#include "KittyMemory/KittyMemory.h"
#include "KittyMemory/KittyUtils.h"
#include "KittyMemory/KittyMemory.cpp"
#include "KittyMemory/KittyUtils.cpp"




//#include "ca/MemoryPatch.h"
#include "Rect.h"
#include "Items.h"
#include "Itemss.h"
#include "Itemsss.h"
#include "imgui/imgui.h"
#include "imgui/XMAS.h"
#include "imgui/backends/imgui_impl_android.h"
#include "imgui/backends/imgui_impl_opengl3.h"
#include "KittyMemory/MemoryPatch.h"
#include "StrEnc.h"
#include "Spoof.h"
#include "Helper/plthook.h"
//#include "Dobby/dobby.h"


//#include "Dobby/dobby.h"
//#include "Dobby/dobby.h"
//#include "Helper/Items.h"
char *æç¤º = "";
static bool é”™è¯¯æç¤º = false;
int code_sock = -1;
static char s[64];
#include "Helper/json.hpp"
using json = nlohmann::json;
#include "SDK.hpp"

static std::string Mobile = "";
static std::string EXP = "0000-00-00 00:00:00";
static std::string name = "";
static std::string floating = "";
static std::string device = "";
static std::string status = "";

 

bool èŒƒå›´ = false;
bool å­å¼¹è¿½è¸ª = false;
bool JAVAå¡å¯†éªŒè¯ = false;

using namespace SDK;
bool FC = false;
static int style_idx = 2;
bool å˜è‰² = false;
static bool Drive;  
bool æ—è·¯1 = false;
bool å®‰å…¨æœŸ = false;

bool Javaéšè— = false;

bool isLogin123 = false;

bool é˜²è§‚æˆ˜ = false;
bool Bypass10 = false;
bool Bypass11 = false;
bool Breakdown = false;
bool BED = false;
bool å¤§å…æ—è·¯ = false;
bool clear = true;
bool clear1 = false;
bool BypassLOGO = true;
bool update = false;
bool XCF = false;
bool tyyuyUI = false;

bool å¼€å¯å†…é€ = false;
bool å†…é€ä¸Šè‰² = false;
bool å†…é€çº¿æ¡ = false;
bool å†…é€å‘å…‰ = false;
bool å†…é€å˜è‰² = false;
bool å†…é€èœ˜è››ç½‘ = false;
bool å¼€å¯è°ƒè‰² = false;
float *å†…é€é¢œè‰²;


float è¯­è¨€;


bool çª—å£éšè— = false;
float éšè—1;
bool éšè— = false;
bool éšè—çª—å£ = false;
float çª—å£Y;
float çª—å£X;
bool UI1 = false;
float å¹³æ¿è§†è§’è°ƒæ•´ = 90.0;
float é»‘ä½“é¢œè‰² = 14.0;
float Random;
float è§¦æ‘¸XX;
float è§¦æ‘¸å¯¹è±¡X;
float è§¦æ‘¸å¯¹è±¡XX;
float è§¦æ‘¸å¯¹è±¡Y;
float è§¦æ‘¸å¯¹è±¡YY;
float è§¦æ‘¸å¯¹è±¡é˜Ÿä¼;
float è§¦æ‘¸æ¬¡æ•°;



//ä¿®å¤å´©æºƒ
#include <curl/curl.h>
#include <openssl/rsa.h>
#include <openssl/pem.h>
#include "base64/base64.h"
#include "AMColor.h"
//#include "Icon.h"
#include <stdio.h>
char extra[32];
//#include "Iconcpp.h"
bool Visble = false;
bool Eaimbot = false;
bool é€šè¿‡ = false;
static bool iså¤´,isè„–å­,isç›†éª¨,iså·¦ä¸Šè‡‚,iså·¦å°è‡‚,iså·¦æ‰‹,iså·¦å¤§è…¿,iså·¦å°è…¿,iså·¦è„š,iså³ä¸Šè‡‚,iså³å°è‡‚,iså³æ‰‹,iså³å¤§è…¿,iså³å°è…¿,iså³è„š;
bool Bypass = true;
bool Bypass1 = false;
bool Bypass2 = false;
bool Bypass3 = false;

bool æ˜¾ç¤ºåˆ°æœŸæ—¶é—´ = false;

bool å…¨å±€ç¦»çº¿ = false;
bool Catch = false;

bool Slowæç¤º = false;
bool Slowæç¤º1 = true;

bool DobyBypass = false;

bool äººç‰©èŒƒå›´ = false;
bool æ— å = false;
bool ç¨³å®šåŠ é€Ÿå…³ = false;
bool ç¨³å®šåŠ é€Ÿå¼€ = false;
bool ç¨³å®šé™¤é›¾ = false;
bool é™¤è‰ = false;
bool é™¤æ ‘ = false;
bool é»‘å¤© = false;
bool è‡ªç„ = false;
bool å¹³æ¿è§†è§’ = false;
bool é«˜ä¼¤å®³ = false;
bool é»‘ä½“ = false;

float è‡ªç„æ¥å£;

bool Loginèµ¢è— = false;
bool Loginæ–‡å­— = false;

bool å¥½å¿ƒæç¤º = false;
//float æç¤ºå†…å®¹;

float æ–‡å­—xx;
float æ–‡å­—12;
float æ–‡å­—11;
float æ–‡å­—1;
float æ–‡å­—2;
float æ–‡å­—3;
float æ–‡å­—4;
float æ–‡å­—5 = 150;
float æ–‡å­—6;
float æ–‡å­—7;
float æ–‡å­—8;
bool æ˜¾ç¤ºæ–‡å­— = false;

bool å½©è‰²æ–‡å­— = false;

float æ˜¾ç¤ºå°æç¤º;
bool æ˜¾ç¤ºæç¤ºå¼€å…³;

std::string æç¤ºå†…å®¹ = "";
//#define GEngine_Offset
//////////////////


/*#define GEngine_Offset 0x7D80E5C
#define GNames_Offset 0x3E64F90
#define GUObject_Offset 0x80C0EF0
#define GNativeAndroidApp_Offset 0x7D760DC
#define GetActorArray_Offset 0x5747420
#define Actors_Offset 0x70*/

#define AimBullet_Offset 0x1FE6C04
#define GNames_Offset 0x68d5774
#define GUObject_Offset 0xba18ec0
#define GNativeAndroidApp_Offset 0xb799d68
#define CanvasMap_Offset 0xbbf00f8
#define GetActorArray 0x819f78c

#define Actors_Offset 0xA0


#define IM_PI                   3.14159265358979323846f
#define RAD2DEG(x) ((float)(x) * (float)(180.f / IM_PI))
#define DEG2RAD(x) ((float)(x) * (float)(IM_PI / 180.f))
bool WriteAddr(void *addr, void *buffer, size_t length) {
    unsigned long page_size = sysconf(_SC_PAGESIZE);
    unsigned long size = page_size * sizeof(uintptr_t);
    return mprotect((void *) ((uintptr_t) addr - ((uintptr_t) addr % page_size) - page_size), (size_t) size, PROT_EXEC | PROT_READ | PROT_WRITE) == 0 && memcpy(addr, buffer, length) != 0;
}
template<typename T>
void å†™å…¥Fç±»(uintptr_t addr, T value) {
    WriteAddr((void *) addr, &value, sizeof(T));
}
void å†™å…¥Dç±»(uintptr_t addr,int var){
WriteAddr(reinterpret_cast<void*>(addr),reinterpret_cast<void*>(&var),4);
}


//å†…å­˜è¯»å†™
json items_datakl;
json itemss_datakl;
json itemsss_datakl;
std::string g_Token, g_Auth;
std::string g_Token1, g_Auth1;
bool bValid = false;
bool bValid1 = false;
uintptr_t UE4;
uintptr_t anort;
uintptr_t AAGS;
uintptr_t anogs;
uintptr_t gcloud;
uintptr_t INTLFoundation;

android_app *g_App = 0;
ASTExtraPlayerCharacter *g_LocalPlayer = 0;
ASTExtraPlayerController *g_LocalController = 0;
float è‡ªç„å­è¿½;

static bool Feu;
static float Aim10;
static float Aim50;
static float Aim100;
static float Aim150;
static float Aim200;
static float Aim250;
static float Aim300;
static float AimYQ;
static float ç»˜åˆ¶è·ç¦»;
float è§¦æ‘¸X;
float è§¦æ‘¸Y;
float è‡ªç„è·ç¦» = 350;
bool ActiveEsp = true;
bool fov = true;
bool initImGui = false;
bool Unlock = false;
bool FK = false;
bool åŠ¨ä½œ = false;
bool è”¡å¾å¤ = false;
bool åœ°é“é€ƒç”Ÿ = false;
bool show_é˜²å° = false;
bool show_è°ƒè¯• = false;
bool show_å‹æª = false;
bool æ˜¾ç¤ºç‰©èµ„ = false;
bool WideView = false;
bool é£æœº = false;
bool ç©ºæŠ• = false;
bool å…¨å›¾ç»˜åˆ¶ = false;
bool é‡ç½®æ¸¸å®¢ = false;
bool å¹³æ¿è§†è§’123 = false;
bool å¤´éƒ¨èŒƒå›´ = false;
bool æ—¶é—´ = false;
int screenWidth = -1, glWidth, screenHeight = -1, glHeight;
float density = -1;
float RadarX=320,RadarY=255;
bool è§†è§’å­è¿½ = false;
bool é˜²æŠ– = false;
bool ç¬å‡» = false;
bool åŠ é€Ÿ = false;
bool é£å¤©å¼€ = false;
bool èšç‚¹ = false;
bool åŠ é€Ÿå¼€ = false;
bool é£å¤© = false;
//GET UE4 BYâœ”NIKE*Studio






















void ç»˜åˆ¶åŠ ç²—æ–‡æœ¬(float size, float x, float y, ImColor color, ImColor color1, const char* str)
{
    ImGui::GetBackgroundDrawList()->AddText(NULL, size, {x-0.8, y-0.8}, color1, str);
    ImGui::GetBackgroundDrawList()->AddText(NULL, size, {x+0.8, y+0.8}, color1, str);
    ImGui::GetBackgroundDrawList()->AddText(NULL, size, {x, y}, color, str);
}
void ç»˜åˆ¶åŠ ç²—æ–‡æœ¬2(float size, float x, float y, ImColor color, ImColor color1, const char* str)
{
    ImGui::GetBackgroundDrawList()->AddText(NULL, size, {x-0.2, y-0.2}, color1, str);
    ImGui::GetBackgroundDrawList()->AddText(NULL, size, {x+0.2, y+0.2}, color1, str);
    ImGui::GetBackgroundDrawList()->AddText(NULL, size, {x, y}, color, str);
}
ImColor ç´«è‰²2 = ImColor(46,46,177);
ImColor æµ…è“ = ImColor(ImVec4(36/255.f, 249/255.f, 217/255.f, 255/255.f));
ImColor è“è‰² = ImColor(ImVec4(170/255.f, 203/255.f, 244/255.f, 0.95f));
ImColor ç™½è‰² = ImColor(ImVec4(255/255.f, 255/255.f, 258/255.f, 0.95f));
ImColor æµ…ç²‰ = ImColor(ImVec4(255/255.f, 200/255.f, 250/255.f, 0.95f));
ImColor é»‘è‰² = ImColor(ImVec4(0/255.f, 0/255.f, 0/255.f, 0.7f));
ImColor åŠé»‘ = ImColor(ImVec4(0/255.f, 0/255.f, 0/255.f, 0.18f));
ImColor è¡€è‰² = ImColor(ImVec4(0/255.f, 249/255.f, 0/255.f, 0.35f));
ImColor çº¢è‰² = ImColor(ImVec4(233/255.f, 55/255.f, 51/255.f, 0.95f));
ImColor ç»¿è‰² = ImColor(ImVec4(50/255.f, 222/215.f, 50/255.f, 0.95f));
ImColor é»„è‰² = ImColor(ImVec4(255/255.f, 255/255.f, 0/255.f, 0.95f));
ImColor æ©˜é»„ = ImColor(ImVec4(255/255.f, 150/255.f, 30/255.f, 0.95f));
ImColor ç²‰çº¢ = ImColor(ImVec4(220/255.f, 108/255.f, 1202/255.f, 0.95f));
ImColor ç´«è‰² = ImColor(ImVec4(169/255.f, 120/255.f, 223/255.f, 0.95f));


static UEngine *GEngine = 0;
UWorld *GetWorld() {
    while (!GEngine) {
        GEngine = UObject::FindObject<UEngine>("UAEGameEngine Transient.UAEGameEngine_1"); // Auto 
        sleep(1);
    }
    if (GEngine) {
        auto ViewPort = GEngine->GameViewport;

        if (ViewPort) {
   //return {};
            return ViewPort->World;
        }
    }
    return 0;
}



/*UWorld * GetWorld() {
 auto GEngine = * (UEngine * *)(UE4 + GEngine_Offset);
 if (GEngine) {
  auto ViewPort = GEngine->GameViewport;
  if (ViewPort) {
   return ViewPort->World;
  }
 }
 return 0;
}*/


TNameEntryArray *GetGNames()
{
	return ((TNameEntryArray * (*)())(UE4 + GNames_Offset))();
}

std::vector<AActor *> getActors()
{
	auto World = GetWorld();
	if (!World)
		return std::vector<AActor *>();

	auto PersistentLevel = World->PersistentLevel;
	if (!PersistentLevel)
		return std::vector<AActor *>();

	auto Actors = *(TArray<AActor *> *)((uintptr_t)PersistentLevel + Actors_Offset);

	std::vector<AActor *> actors;
	for (int i = 0; i < Actors.Num(); i++)
	{
		auto Actor = Actors[i];
		if (Actor)
		{
			actors.push_back(Actor);
		}
	}
	return actors;
}

//////GET Word Name Player

bool æ¼æ‰“ = false;
bool è‡ªå®šä¹‰;
float *Yè½´;
float *Zè½´;
float *Xè½´;
// ======================================================================= //
enum Aimfirst {
    DHead = 0,//å¤´éƒ¨
    Pelvis = 1,
    Lhand = 2,//å·¦æ‰‹
    Rhand = 3,//å³æ‰‹
    Lfoot = 4,//å·¦è„š
    Rfoot = 5//å³è„š
};

static int Corepriority = 0;

enum Aimmode{
    Mdp = 0, //æ¼å“ªæ‰“å“ª
    Fixed = 1,//å›ºå®šç‚¹ä½
    Nearest = 2//è·ç¦»å‡†æ˜Ÿæœ€è¿‘
};

enum EEsp {
  eno = 0,
  Line = 1,
  Mid = 2,
  Below = 3
  
};

enum EAimTarget
{
	Head = 0,
	Chest = 1,
	JJ = 2
};

enum AIMBOT
{
	SJ = 0,
	ZX = 1,
	LD = 2,
	PH = 3,
	QS = 4,
	NC = 5,
	CM = 6,
	SJZM = 7,
	MY = 8
};

enum RADAR
{
	KR = 0,
	QZ = 1,
	DNA = 2
};

enum AIMBOTA
{
	SJZZ = 0,
	QSZZ = 1,
	MYZZ = 2
};

enum EAimTrigger
{
	None = 0,
	Shooting = 1,
	Scoping = 2,
	Both = 3,
	Any = 4
};

enum BOXD
{
	BOX2D = 0,
	BOX3D = 1,
	CLOUD = 2
};

std::map<int, bool> Items;
std::map<int, bool> Itemss;
std::map<int, bool> Itemsss;

struct sConfig {
    bool è‡ªåŠ¨é€‰æ‹©;
    bool å†…é€1;
    bool å†…é€2;
    bool é˜²è¿½å°;
    bool é›·è¾¾;
    bool ç®­å¤´;
    bool é¢„è­¦;
    bool Crash1;
    bool è‡ªåŠ¨Z;
    bool Crash;
    bool é¢„åˆ¤;
    bool ç‰©èµ„1;
    bool ç‰©èµ„;
    bool FOV;
    bool æ‰‹æŒ;
    bool åŠ¨ä½œ;
    bool åœˆ;
    float Less;
    bool åŸºå€;
    bool RecoilComparison;
    bool ç™»é™†é¡µé¢;
    bool è‡ªåŠ¨å¼€ç«ON;
    bool è‡ªåŠ¨å¼€ç«OFF;
	float å‹æªç³»æ•°;
	bool SIT;
	BOXD BOX;
	bool æ®‹ç•™;
	float Xè½´;
	float ç§»åŠ¨;
	float RadarY;
	float RadarX;
    float ç¬å‡»;
	float Yè½´;
	float åååŠ›;
	float å­å¼¹å°„é€Ÿ;
	bool CHAMS;
	bool WH;
		bool CHAMSR;
		bool Hunt;
		bool GLOW;
		bool OUTLINE;
		
		
	struct sPlayerESP {
        bool ActiveEsp;
        RADAR RadarZX;
		bool ä¸Š;
		bool ä¸­;
		bool ä¸‹;
		bool å¼€å¯çº¿æ¡;
		bool AirDrop;
		bool AUTOGOODZ;
		bool AUTOGOODY;
		bool AUTOGOODX;
		bool AUTOGOODXX;
		bool AUTOGOODYY;
		bool Box;
		bool å‡†å¿ƒå°„çº¿;
		bool Alert360;
		bool Box3D;
		bool Health;
		bool Skeleton;
		bool Name;
		bool Radar;
		bool Distance;
		bool TeamID;
		bool Vehicle;
		bool NoBot;
		bool ME;
		bool WALL;
		bool Team;
		bool LootBox;
		bool Grenade;
		bool VehicleHP;
		bool VehicleFuel;
		EEsp By;
	};

	sPlayerESP PlayerESP{0};
	
	
	struct sGOODVIEW {
    	bool ENABLE;
		bool UP;
		bool ON;
		bool DOWN;
		bool FRONT;
		bool BEHIND;
		bool RIGHT;
		bool LEFT;
		
		
	};
	sGOODVIEW GOODVIEW;
	
	

	struct sAimMenu
	{
		bool Enable;
		bool Enable1;
		bool å¼€å¯è‡ªç„;
		bool å¼€å¯å­è¿½;
		Aimfirst HeadPriority;//å¤´éƒ¨ä¼˜å…ˆ
        Aimfirst PelvisPriority;//ç›†éª¨ä¼˜å…ˆ
        Aimfirst LhandPriority;//å·¦æ‰‹ä¼˜å…ˆ
        Aimfirst RhandPriority;//å³æ‰‹ä¼˜å…ˆ
        Aimfirst LfootPriority;//å·¦è„šä¼˜å…ˆ
        Aimfirst RfootPriority;//å³è„šä¼˜å…ˆ
        Aimmode  Amode;
		bool AimBot;
		float Meter;
		AIMBOT AINBOT;
		AIMBOTA AINBOTA;
		EAimTarget Target;
		EAimTrigger Trigger;
		bool IgnoreKnocked;
		bool IgnoreBot;
		bool ä»»ä½•;
		bool é»˜è®¤;
		bool å¼€ç«;
		bool å¼€é•œ;
		bool å¼€ç«å¼€é•œ;
		bool VisCheck;
		float Cross;
		bool Fov;
		float Recc;
	};
	sAimMenu SilentAim{0};
	sAimMenu AimBot{0};

	struct sHighRisk
	{
		bool Shake;
		bool Recoil;
		bool Instant;
		bool Prone;
		bool HitEffect;
		bool Flash;
		bool Less;
		bool Cross;
		//ğŸ”å€
		bool Fw;
	};
	sHighRisk HighRisk{0};

	struct sColorsESP
	{
		float *PVLine;
        float *PVILine;
        float *BVLine;
        float *BVILine;
        float *PVBox;
        float *PVIBox;
        float *BVBox;
        float *BVIBox;
        float *PVLinebot;
        float *PVILinebot;
        float *PVSkeleton;
        float *PVISkeleton;
        float *BVSkeleton;
        float *BVISkeleton;
        float *TeamID;
        float *PVName;
        float *PVIName;
        float *Name;
        float *Distance;
        float *Vehicle;
        float *Items;
        float *Itemss;
        float *Itemsss;
		float *Fov;
	};
	sColorsESP ColorsESP{0};
};
sConfig Config{0};



#define CREATE_COLOR(r, g, b, a) new float[4]{(float)r, (float)g, (float)b, (float)a};
// ======================================================================== //
typedef void (*ImGuiDemoMarkerCallback)(const char* file, int line, const char* section, void* user_data);
extern ImGuiDemoMarkerCallback  GImGuiDemoMarkerCallback;
extern void* GImGuiDemoMarkerCallbackUserData;
ImGuiDemoMarkerCallback         GImGuiDemoMarkerCallback = NULL;
void* GImGuiDemoMarkerCallbackUserData = NULL;
#define IMGUI_DEMO_MARKER(section)  do { if (GImGuiDemoMarkerCallback != NULL) GImGuiDemoMarkerCallback(__FILE__, __LINE__, section, GImGuiDemoMarkerCallbackUserData); } while (0)
// ======================================================================== //
struct sRegion
{
	uintptr_t start, end;
};

std::vector<sRegion> trapRegions;


bool isInsideFOV(int x, int y) {
    if (!Config.SilentAim.Cross)
        return true;

    int circle_x = screenWidth / 3.0f;
    int circle_y = screenHeight / 3.0f;
    int rad = Config.SilentAim.Cross*0.5f;
    return (x - circle_x) * (x - circle_x) + (y - circle_y) * (y - circle_y) <= rad * rad;
}
bool isInsideFOV2(int x, int y) {
    if (!Config.SilentAim.Cross)
        return true;

    int circle_x = screenWidth / 3.0f;
    int circle_y = screenHeight / 3.0f;
    int rad = Config.SilentAim.Cross*0.5f;
    return (x - circle_x) * (x - circle_x) + (y - circle_y) * (y - circle_y) <= rad * rad;
}

bool isObjectInvalid(UObject *obj)
{
	if (!Tools::IsPtrValid(obj))
	{
		return true;
	}
	if (!Tools::IsPtrValid(obj->ClassPrivate))
	{
		return true;
	}
	if (obj->InternalIndex <= 0)
	{
		return true;
	}
    if (obj->NamePrivate.ComparisonIndex <= 0)
	{
		return true;
	}
	if ((uintptr_t)(obj) % sizeof(uintptr_t) != 0x0 && (uintptr_t)(obj) % sizeof(uintptr_t) != 0x4)
	{
		return true;
	}
	if (std::any_of(trapRegions.begin(), trapRegions.end(), [obj](sRegion region) { return ((uintptr_t)obj) >= region.start && ((uintptr_t)obj) <= region.end; }) || std::any_of(trapRegions.begin(), trapRegions.end(), [obj](sRegion region) { return ((uintptr_t)obj->ClassPrivate) >= region.start && ((uintptr_t)obj->ClassPrivate) <= region.end; }))
	{
		return true;
	}
	return false;
}

FRotator ToRotator(FRotator inRot) {
    FRotator outRot = inRot;
    if (outRot.Pitch > 180)
        outRot.Pitch -= 360;
    if (outRot.Pitch < -180)
        outRot.Pitch += 360;

    if (outRot.Pitch < -75.f)
        outRot.Pitch = -75.f;
    else if (outRot.Pitch > 75.f)
        outRot.Pitch = 75.f;

    while (outRot.Yaw < -180.0f)
        outRot.Yaw += 360.0f;
    while (outRot.Yaw > 180.0f)
        outRot.Yaw -= 360.0f;
    return outRot;
}

FRotator ClampAngles(FRotator inRot) {
    FRotator outRot = inRot;
    if (outRot.Pitch > 180)
        outRot.Pitch -= 360;
    if (outRot.Pitch < -180)
        outRot.Pitch += 360;

    if (outRot.Pitch < -75.f)
        outRot.Pitch = -75.f;
    else if (outRot.Pitch > 75.f)
        outRot.Pitch = 75.f;

    while (outRot.Yaw < -180.0f)
        outRot.Yaw += 360.0f;
    while (outRot.Yaw > 180.0f)
        outRot.Yaw -= 360.0f;
    return outRot;
}
///360Â° NIKE AIMBOT 3.0
// ======================================================================== //
std::string getObjectPath(UObject *Object)
{
	std::string s;
	for (auto super = Object->ClassPrivate; super; super = (UClass *)super->SuperStruct)
	{
		if (!s.empty())
			s += ".";
		s += super->NamePrivate.GetName();
	}
	return s;
}

// ======================================================================== //
int32_t ToColor(float *col)
{
	return ImGui::ColorConvertFloat4ToU32(*(ImVec4 *)(col));
}

FRotator ToRotator(FVector local, FVector target)
{
	FVector rotation = UKismetMathLibrary::Subtract_VectorVector(local, target);
	float hyp = sqrt(rotation.X * rotation.X + rotation.Y * rotation.Y);
	FRotator newViewAngle = {0};
	newViewAngle.Pitch = -atan(rotation.Z / hyp) * (180.f / (float)3.14159265358979323846);
	newViewAngle.Yaw = atan(rotation.Y / rotation.X) * (180.f / (float)3.14159265358979323846);
	newViewAngle.Roll = (float)0.f;
	if (rotation.X >= 0.f)
		newViewAngle.Yaw += 180.0f;
	return newViewAngle;
}
// ======================================================================== //
//AiMBot3.0
#define W2S(w, s) UGameplayStatics::ProjectWorldToScreen(localController, w, true, s)
auto è‡ªç„360åº¦() {
if (Config.AimBot.å¼€å¯è‡ªç„) {
if (Config.AimBot.AINBOT == AIMBOT::SJ) {

    ASTExtraPlayerCharacter *result = 0;
    float max = std::numeric_limits<float>::infinity();

    auto GWorld = GetWorld();
    if (GWorld) {
        ULevel *PersistentLevel = GWorld->PersistentLevel;
        if (PersistentLevel) {
            TArray<AActor *> Actors = *(TArray<AActor *> *) ((uintptr_t) PersistentLevel +
                                                             Actors_Offset);
    auto localPlayer = g_LocalPlayer;
    auto localController = g_LocalController;

    if (localPlayer) {
for (int i = 0; i < Actors.Num(); i++) {
                    auto Actor = Actors[i];
                    if (isObjectInvalid(Actor))
                        continue;

            if (Actor->IsA(ASTExtraPlayerCharacter::StaticClass())) {
                auto Player = (ASTExtraPlayerCharacter *) Actor;
                
                float dist = localPlayer->GetDistanceTo(Player) / 100.0f;    
                if (dist > è‡ªç„è·ç¦»)
                    continue;

                if (Player->PlayerKey == localPlayer->PlayerKey)
                    continue;

                if (Player->TeamID == localPlayer->TeamID)
                    continue;

                if (Player->bDead)
                    continue;

                if (Config.AimBot.IgnoreKnocked) {
                    if (Player->Health == 0.0f)
                        continue;
                }

            
                    if (!localController->LineOfSightTo(Player, {0, 0, 0}, true))
                        continue;
                

                if (Config.AimBot.IgnoreBot) {
                    if (Player->bIsAI)
                        continue;
                }

            
                dist = localPlayer->GetDistanceTo(Player);
                        if (dist < max) {
                            max = dist;
                            result = Player;
                        }
                    }
                }
            }
        
    
    return result;
    }}}}}
    
    //=====///===///===///

//AimBot6.0

auto å†…å­˜è‡ªç„() {
if (Config.AimBot.å¼€å¯è‡ªç„) {
if (Config.AimBot.AINBOT == AIMBOT::NC) {
    ASTExtraPlayerCharacter *result = 0;
    float max = std::numeric_limits<float>::infinity();

    auto GWorld = GetWorld();
    if (GWorld) {
        ULevel *PersistentLevel = GWorld->PersistentLevel;
        if (PersistentLevel) {
            TArray<AActor *> Actors = *(TArray<AActor *> *) ((uintptr_t) PersistentLevel +
                                                             Actors_Offset);

            auto localPlayer = g_LocalPlayer;
            auto localController = g_LocalController;

            if (localPlayer) {
                for (int i = 0; i < Actors.Num(); i++) {
                    auto Actor = Actors[i];
                    if (isObjectInvalid(Actor))
                        continue;

                    if (Actor->IsA(ASTExtraPlayerCharacter::StaticClass())) {
                        auto Player = (ASTExtraPlayerCharacter *) Actor;
				         auto Target = (ASTExtraPlayerCharacter *) Actor;

        

                if (Player->PlayerKey == localPlayer->PlayerKey)
                    continue;

                if (Player->TeamID == localPlayer->TeamID)
                    continue;

                if (Player->bDead)
					continue;
					
					
             if (Config.AimBot.IgnoreKnocked) {
                    if (Player->Health == 0.0f)
                        continue;
                }

              
                    if (!localController->LineOfSightTo(Player, {0, 0, 0}, true))
                        continue;
                
                if (Config.AimBot.IgnoreBot) {
                    if (Player->bIsAI)
                        continue;
                        }

                        auto Root = Player->GetBonePos("Root", {});
                        auto Head = Player->GetBonePos("Head", {});

                        FVector2D RootSc, HeadSc;
                        if (W2S(Root, &RootSc) && W2S(Head, &HeadSc)) {
                            float height = abs(HeadSc.Y - RootSc.Y);
                            float width = height * 0.65f;

                            FVector middlePoint = {HeadSc.X + (width / 2), HeadSc.Y + (height / 2),
                                                   0};
                            if ((middlePoint.X >= 0 && middlePoint.X <= glWidth) &&
                                (middlePoint.Y >= 0 && middlePoint.Y <= glHeight)) {
                                FVector2D v2Middle = FVector2D((float) (glWidth / 2),
                                                               (float) (glHeight / 2));
                                FVector2D v2Loc = FVector2D(middlePoint.X, middlePoint.Y);
                                if(isInsideFOV((int)middlePoint.X, (int)middlePoint.Y)) {
                                float dist = FVector2D::Distance(v2Middle, v2Loc);

                                if (dist < max) {
                                    max = dist;
                                    result = Player;
                                }
                            }
                        }
                    }
                }
            }
             }
            return result;
        }
    }
}}}



auto é€šç”¨è‡ªç„() {
    ASTExtraPlayerCharacter *result = 0;
    float max = std::numeric_limits<float>::infinity();

    auto GWorld = GetWorld();
    if (GWorld) {
        ULevel *PersistentLevel = GWorld->PersistentLevel;
        if (PersistentLevel) {
            TArray<AActor *> Actors = *(TArray<AActor *> *) ((uintptr_t) PersistentLevel +
                                                             Actors_Offset);

            auto localPlayer = g_LocalPlayer;
            auto localController = g_LocalController;

            if (localPlayer) {
                for (int i = 0; i < Actors.Num(); i++) {
                    auto Actor = Actors[i];
                    if (isObjectInvalid(Actor))
                        continue;

                    if (Actor->IsA(ASTExtraPlayerCharacter::StaticClass())) {
                        auto Player = (ASTExtraPlayerCharacter *) Actor;
				         auto Target = (ASTExtraPlayerCharacter *) Actor;

            

                if (Player->PlayerKey == localPlayer->PlayerKey)
                    continue;

                if (Player->TeamID == localPlayer->TeamID)
                    continue;

                if (Player->bDead)
					continue;
					
					
             if (Config.AimBot.IgnoreKnocked) {
                    if (Player->Health == 0.0f)
                        continue;
                }

                
                    if (!localController->LineOfSightTo(Player, {0, 0, 0}, true))
                        continue;
                
                if (Config.AimBot.IgnoreBot) {
                    if (Player->bIsAI)
                        continue;
                        }

                        auto Root = Player->GetBonePos("Root", {});
                        auto Head = Player->GetBonePos("Head", {});

                        FVector2D RootSc, HeadSc;
                        if (W2S(Root, &RootSc) && W2S(Head, &HeadSc)) {
                            float height = abs(HeadSc.Y - RootSc.Y);
                            float width = height * 0.65f;

                            FVector middlePoint = {HeadSc.X + (width / 2), HeadSc.Y + (height / 2),
                                                   0};
                            if ((middlePoint.X >= 0 && middlePoint.X <= glWidth) &&
                                (middlePoint.Y >= 0 && middlePoint.Y <= glHeight)) {
                                FVector2D v2Middle = FVector2D((float) (glWidth / 2),
                                                               (float) (glHeight / 2));
                                FVector2D v2Loc = FVector2D(middlePoint.X, middlePoint.Y);
                                if(isInsideFOV((int)middlePoint.X, (int)middlePoint.Y)) {
                                float dist = FVector2D::Distance(v2Middle, v2Loc);

                                if (dist < max) {
                                    max = dist;
                                    result = Player;
                                }
                            }
                        }
                    }
                }
            }
             }
            return result;
        }
    }
}

//AimBot5.0
auto æ¼æ‰“è‡ªç„() {
if (Config.AimBot.å¼€å¯è‡ªç„) {
if (Config.AimBot.AINBOT == AIMBOT::LD || Config.AimBot.AINBOT == AIMBOT::SJZM) {

    ASTExtraPlayerCharacter *result = 0;
    float max = std::numeric_limits<float>::infinity();
    auto GWorld = GetWorld();
    if (GWorld) {
        ULevel *PersistentLevel = GWorld->PersistentLevel;
        if (PersistentLevel) {
            TArray<AActor *> Actors = *(TArray<AActor *> *) ((uintptr_t) PersistentLevel +
                                                             Actors_Offset);
    


    auto localPlayer = g_LocalPlayer;
    auto localController = g_LocalController;

    if (localPlayer) {
for (int i = 0; i < Actors.Num(); i++) {
                    auto Actor = Actors[i];
                    if (isObjectInvalid(Actor))
                        continue;

            if (Actor->IsA(ASTExtraPlayerCharacter::StaticClass())) {
                auto Player = (ASTExtraPlayerCharacter *) Actor;
                
                float dist = localPlayer->GetDistanceTo(Player) / 100.0f;    
                if (dist > è‡ªç„è·ç¦»)
                    continue;

                if (Player->PlayerKey == localPlayer->PlayerKey)
                    continue;

                if (Player->TeamID == localPlayer->TeamID)
                    continue;

                if (Player->bDead)
                    continue;

                if (Config.AimBot.IgnoreKnocked) {
                    if (Player->Health == 0.0f)
                        continue;
                }
                
                if (Config.AimBot.IgnoreBot) {
                    if (Player->bIsAI)
                        continue;
                }
                Visble = false;
                
                        {
                		auto HeadPos = Player->GetBonePos("Head", {});
						ImVec2 HeadPosSC;
						auto RootPos = Player->GetBonePos("Root", {});
						ImVec2 RootPosSC;
						auto upper_r = Player->GetBonePos("upperarm_r", {});
						ImVec2 upper_rPoSC;
						auto lowerarm_r = Player->GetBonePos("lowerarm_r", {});
						ImVec2 lowerarm_rPoSC;
						auto hand_r = Player->GetBonePos("hand_r", {});
						ImVec2 hand_rPoSC;
						auto upper_l = Player->GetBonePos("upperarm_l", {});
						ImVec2 upper_lPoSC;
						auto lowerarm_l = Player->GetBonePos("lowerarm_l", {});
						ImVec2 lowerarm_lSC;
						auto hand_l = Player->GetBonePos("hand_l", {});
						ImVec2 hand_lPoSC;
						auto thigh_l = Player->GetBonePos("thigh_l", {});
						ImVec2 thigh_lPoSC;
						auto calf_l = Player->GetBonePos("calf_l", {});
						ImVec2 calf_lPoSC;
						auto foot_l = Player->GetBonePos("foot_l", {});
						ImVec2 foot_lPoSC;
						auto thigh_r = Player->GetBonePos("thigh_r", {});
						ImVec2 thigh_rPoSC;
						auto calf_r = Player->GetBonePos("calf_r", {});
						ImVec2 calf_rPoSC;
						auto foot_r = Player->GetBonePos("foot_r", {});
						ImVec2 foot_rPoSC;
						auto neck_01 = Player->GetBonePos("neck_01", {});
						ImVec2 neck_01PoSC;
						auto pelvis = Player->GetBonePos("pelvis", {});
						ImVec2 pelvisPoSC;
						if (W2S(HeadPos, (FVector2D *)&HeadPosSC) && W2S(upper_r, (FVector2D *)&upper_rPoSC) && W2S(upper_l, (FVector2D *)&upper_lPoSC) && W2S(lowerarm_r, (FVector2D *)&lowerarm_rPoSC) && W2S(hand_r, (FVector2D *)&hand_rPoSC) && W2S(lowerarm_l, (FVector2D *)&lowerarm_lSC) && W2S(hand_l, (FVector2D *)&hand_lPoSC) && W2S(thigh_l, (FVector2D *)&thigh_lPoSC) && W2S(calf_l, (FVector2D *)&calf_lPoSC) && W2S(foot_l, (FVector2D *)&foot_lPoSC) && W2S(thigh_r, (FVector2D *)&thigh_rPoSC) && W2S(calf_r, (FVector2D *)&calf_rPoSC) && W2S(foot_r, (FVector2D *)&foot_rPoSC) && W2S(neck_01, (FVector2D *)&neck_01PoSC) && W2S(pelvis, (FVector2D *)&pelvisPoSC) && W2S(RootPos, (FVector2D *)&RootPosSC))
						{
                                
                     
                     
                     
                     
                     

                                             if(!localController->LineOfSightTo(localController->PlayerCameraManager, neck_01, false))
                        {//è„–å­
                            isè„–å­ = false;
                         }else{
                            isè„–å­ = true;
                         }
                        
                         
                        if(!localController->LineOfSightTo(localController->PlayerCameraManager, lowerarm_r, false))
                        {//å³å°è‡‚
                             iså³å°è‡‚ = false;
                         }else{
                             iså³å°è‡‚ = true;
                         }
                        
                        if(!localController->LineOfSightTo(localController->PlayerCameraManager, upper_r, false))
                        {//å³ä¸Šè‡‚
                           iså³ä¸Šè‡‚ = false;
                        }else{
                           iså³ä¸Šè‡‚ = true;
                        }
                        
                         if(!localController->LineOfSightTo(localController->PlayerCameraManager, upper_l, false))
                        {//å·¦ä¸Šè‡‚
                             iså·¦ä¸Šè‡‚ = false;
                        }else{
                            iså·¦ä¸Šè‡‚ = true;
                        }
                        
                        
                        if(!localController->LineOfSightTo(localController->PlayerCameraManager, hand_r, false))
                        {//å³æ‰‹
                            iså³æ‰‹ = false;
                        }else{
                            iså³æ‰‹ = true;
                        }
                        
                        
                        if(!localController->LineOfSightTo(localController->PlayerCameraManager, lowerarm_r, false))
                        {//å·¦å°è‡‚
                            iså·¦å°è‡‚ = false;
                        }else{
                            iså·¦å°è‡‚ = true;
                        }
                        
                        
                        if(!localController->LineOfSightTo(localController->PlayerCameraManager, hand_l, false))
                        {//å·¦æ‰‹
                            iså·¦æ‰‹ = false;
                         }else{
                            iså·¦æ‰‹ = true;
                         }
                        
                        if(!localController->LineOfSightTo(localController->PlayerCameraManager, thigh_l, false))
                        {//å·¦å¤§è…¿
                            iså·¦å¤§è…¿ = false;
                         }else{
                            iså·¦å¤§è…¿ = true;
                         }
                        
                         
                        if(!localController->LineOfSightTo(localController->PlayerCameraManager, calf_l, false))
                        {//å·¦å°è…¿
                             iså·¦å°è…¿ = false;
                        }else{
                             iså·¦å°è…¿ = true;
                        }
                        
                        if(!localController->LineOfSightTo(localController->PlayerCameraManager, foot_l, false))
                        {//å·¦è„š
                             iså·¦è„š = false;
                        }else{
                             iså·¦è„š = true;
                        }
                        
                        if(!localController->LineOfSightTo(localController->PlayerCameraManager, thigh_r, false))
                        {//å³å¤§è…¿
                             iså³å¤§è…¿ = false;
                         }else{
                             iså³å¤§è…¿ = true;
                         }
                        
                        if(!localController->LineOfSightTo(localController->PlayerCameraManager, calf_r, false))
                        {//å³å°è…¿
                             iså³å°è…¿ = false;
                         }else{
                             iså³å°è…¿ = true;
                         }
                        
                        if(!localController->LineOfSightTo(localController->PlayerCameraManager, foot_r, false))
                        {//å³è„š
                             iså³è„š = false;
                        }else{
                             iså³è„š = true;
                        }
                  
                        if(!localController->LineOfSightTo(localController->PlayerCameraManager, pelvis, false))
                        {//éª¨ç›†
                            isç›†éª¨ = false;
                        }else{
                            isç›†éª¨ = true;
                        }
                        
                        if(!localController->LineOfSightTo(localController->PlayerCameraManager, HeadPos, false))
                        {//å¤´
                          iså¤´ = false;
                         }else{
                           iså¤´ = true;
                         }
                         
                         
                         if (iså¤´) {
                         Visble = true;
                         }
                         if (isè„–å­) {
                         Visble = true;
                         }
                         if (iså³å°è‡‚) {
                         Visble = true;
                         }
                         if (iså³ä¸Šè‡‚) {
                         Visble = true;
                         }
                         if (iså·¦ä¸Šè‡‚) {
                         Visble = true;
                         }
                         if (iså³æ‰‹) {
                         Visble = true;
                         }
                         if (iså·¦å°è‡‚) {
                         Visble = true;
                         }
                         if (iså·¦æ‰‹) {
                         Visble = true;
                         }
                         if (iså·¦å¤§è…¿) {
                         Visble = true;
                         }
                         if (iså·¦å°è…¿) {
                         Visble = true;
                         }
                         if (iså·¦è„š) {
                         Visble = true;
                         }
                         if (iså³å¤§è…¿) {
                         Visble = true;
                         }
                         if (iså³å°è…¿) {
                         Visble = true;
                         }
                         if (iså³è„š) {
                         Visble = true;
                         }
                         if (isç›†éª¨) {
                         Visble = true;
                         }
                         
                         
                         
                         
                         
                     }}
                     
                     
                     
                é€šè¿‡ = false;
 
                if (Visble) {
                    
                     
             
é€šè¿‡ = true;
//Visble = false;


                
                        auto HeadPos = Player->GetBonePos("Head", {});
                        HeadPos.Z = HeadPos.Z + 1.0f; //head se line ooper
                        
                        


                        
                        auto RootPos = Player->GetBonePos("Root", {});
                        
                        
                        
                        
                        auto Head_RootZ = HeadPos.Z - RootPos.Z;
                        
                        

                        auto upper_r = Player->GetBonePos("upperarm_r", {});
                        
                        auto lowerarm_r = Player->GetBonePos("lowerarm_r", {});
                        
                        auto hand_r = Player->GetBonePos("hand_r", {});
                        
                        auto upper_l = Player->GetBonePos("upperarm_l", {});
                        
                        auto lowerarm_l = Player->GetBonePos("lowerarm_l", {});
                        
                        auto hand_l = Player->GetBonePos("hand_l", {});
                        
                        auto thigh_l = Player->GetBonePos("thigh_l", {});
                        
                        auto calf_l = Player->GetBonePos("calf_l", {});
                        
                        auto foot_l = Player->GetBonePos("foot_l", {});
                        
                        auto thigh_r = Player->GetBonePos("thigh_r", {});
                        
                        auto calf_r = Player->GetBonePos("calf_r", {});
                        
                        auto foot_r = Player->GetBonePos("foot_r", {});
                        
                        auto neck_01 = Player->GetBonePos("neck_01", {});
                        
                        auto pelvis = Player->GetBonePos("pelvis", {});
                        
                        

                       
                

                FVector2D RootPosSC, headPosSC,upper_rPoSC,upper_lPoSC,lowerarm_rPoSC,hand_rPoSC,lowerarm_lSC,hand_lPoSC,thigh_lPoSC,calf_lPoSC,foot_lPoSC,thigh_rPoSC,calf_rPoSC,foot_rPoSC,neck_01PoSC,pelvisPoSC;
                if (W2S(HeadPos,&headPosSC) &&W2S(upper_r,&upper_rPoSC) &&
                            W2S(upper_l,&upper_lPoSC) &&W2S(lowerarm_r,&lowerarm_rPoSC) &&
                            W2S(hand_r,&hand_rPoSC) &&W2S(lowerarm_l, &lowerarm_lSC) &&
                            W2S(hand_l,&hand_lPoSC) && W2S(thigh_l, &thigh_lPoSC) &&
                            W2S(calf_l,&calf_lPoSC) &&W2S(foot_l,&foot_lPoSC) &&
                            W2S(thigh_r, &thigh_rPoSC) &&W2S(calf_r, &calf_rPoSC) &&
                            W2S(foot_r,&foot_rPoSC) &&W2S(neck_01,&neck_01PoSC) &&
                            W2S(pelvis,&pelvisPoSC) &&W2S(RootPos,&RootPosSC)) {
                                
                     /*
                       ä¼˜å…ˆæ¬¡åº: å¤´ è„–å­ ç›†éª¨ 
                       å·¦ä¸Šè‡‚ å·¦å°è‡‚ å·¦æ‰‹ å·¦å¤§è…¿ å·¦å°è…¿ å·¦è„š
                       å³ä¸Šè‡‚ å³å°è‡‚ å³æ‰‹ å³å¤§è…¿ å³å°è…¿ å³é”®
                     */           

                                                   static bool å·²é€‰æ‹© = false;
Corepriority = 0;
å·²é€‰æ‹© = false;

isè„–å­ = false;
iså³å°è‡‚ = false;
iså³ä¸Šè‡‚ = false;
iså·¦ä¸Šè‡‚ = false;
iså³æ‰‹ = false;
iså·¦å°è‡‚ = false;
iså·¦æ‰‹ = false;
iså·¦å¤§è…¿ = false;
iså·¦å°è…¿ = false;
iså·¦è„š = false;
iså³å¤§è…¿ = false;
iså³å°è…¿ = false;
iså³è„š = false;
isç›†éª¨ = false;
iså¤´ = false;

                                             if(!localController->LineOfSightTo(localController->PlayerCameraManager, neck_01, false))
                        {//è„–å­
                            isè„–å­ = false;
                         }else{
                            isè„–å­ = true;
                         }
                        
                         
                        if(!localController->LineOfSightTo(localController->PlayerCameraManager, lowerarm_r, false))
                        {//å³å°è‡‚
                             iså³å°è‡‚ = false;
                         }else{
                             iså³å°è‡‚ = true;
                         }
                        
                        if(!localController->LineOfSightTo(localController->PlayerCameraManager, upper_r, false))
                        {//å³ä¸Šè‡‚
                           iså³ä¸Šè‡‚ = false;
                        }else{
                           iså³ä¸Šè‡‚ = true;
                        }
                        
                         if(!localController->LineOfSightTo(localController->PlayerCameraManager, upper_l, false))
                        {//å·¦ä¸Šè‡‚
                             iså·¦ä¸Šè‡‚ = false;
                        }else{
                            iså·¦ä¸Šè‡‚ = true;
                        }
                        
                        
                        if(!localController->LineOfSightTo(localController->PlayerCameraManager, hand_r, false))
                        {//å³æ‰‹
                            iså³æ‰‹ = false;
                        }else{
                            iså³æ‰‹ = true;
                        }
                        
                        
                        if(!localController->LineOfSightTo(localController->PlayerCameraManager, lowerarm_r, false))
                        {//å·¦å°è‡‚
                            iså·¦å°è‡‚ = false;
                        }else{
                            iså·¦å°è‡‚ = true;
                        }
                        
                        
                        if(!localController->LineOfSightTo(localController->PlayerCameraManager, hand_l, false))
                        {//å·¦æ‰‹
                            iså·¦æ‰‹ = false;
                         }else{
                            iså·¦æ‰‹ = true;
                         }
                        
                        if(!localController->LineOfSightTo(localController->PlayerCameraManager, thigh_l, false))
                        {//å·¦å¤§è…¿
                            iså·¦å¤§è…¿ = false;
                         }else{
                            iså·¦å¤§è…¿ = true;
                         }
                        
                         
                        if(!localController->LineOfSightTo(localController->PlayerCameraManager, calf_l, false))
                        {//å·¦å°è…¿
                             iså·¦å°è…¿ = false;
                        }else{
                             iså·¦å°è…¿ = true;
                        }
                        
                        if(!localController->LineOfSightTo(localController->PlayerCameraManager, foot_l, false))
                        {//å·¦è„š
                             iså·¦è„š = false;
                        }else{
                             iså·¦è„š = true;
                        }
                        
                        if(!localController->LineOfSightTo(localController->PlayerCameraManager, thigh_r, false))
                        {//å³å¤§è…¿
                             iså³å¤§è…¿ = false;
                         }else{
                             iså³å¤§è…¿ = true;
                         }
                        
                        if(!localController->LineOfSightTo(localController->PlayerCameraManager, calf_r, false))
                        {//å³å°è…¿
                             iså³å°è…¿ = false;
                         }else{
                             iså³å°è…¿ = true;
                         }
                        
                        if(!localController->LineOfSightTo(localController->PlayerCameraManager, foot_r, false))
                        {//å³è„š
                             iså³è„š = false;
                        }else{
                             iså³è„š = true;
                        }
                  
                        if(!localController->LineOfSightTo(localController->PlayerCameraManager, pelvis, false))
                        {//éª¨ç›†
                            isç›†éª¨ = false;
                        }else{
                            isç›†éª¨ = true;
                        }
                        
                        if(!localController->LineOfSightTo(localController->PlayerCameraManager, HeadPos, false))
                        {//å¤´
                          iså¤´ = false;
                         }else{
                           iså¤´ = true;
                         }
                         
                         
                      
                      if (!å·²é€‰æ‹©)
                      if(iså¤´)
                             {
                                 Corepriority = 1;
                                 å·²é€‰æ‹© = true;
                             }else{
                                 å·²é€‰æ‹© = false;
                             }
                      if (!å·²é€‰æ‹©)
                      if(isç›†éª¨)
                             {
                                 Corepriority = 2;
                                 å·²é€‰æ‹© = true;
                             }else{
                                 å·²é€‰æ‹© = false;
                             }
                      if (!å·²é€‰æ‹©)
                      if(iså·¦æ‰‹)
                             {
                                 Corepriority = 3;
                                 å·²é€‰æ‹© = true;
                             }else{
                                 å·²é€‰æ‹© = false;
                             }
                      if (!å·²é€‰æ‹©)
                      if(iså³æ‰‹)
                             {
                                 Corepriority = 4;   
                                 å·²é€‰æ‹© = true;
                             }else{
                                 å·²é€‰æ‹© = false;
                             }
                      if (!å·²é€‰æ‹©)
                      if(iså·¦è„š)
                             {
                                 Corepriority = 5;
                                 å·²é€‰æ‹© = true;
                             }else{
                                 å·²é€‰æ‹© = false;
                             }
                      if (!å·²é€‰æ‹©)
                      if(iså³è„š)
                             {
                                 Corepriority = 6;
                                 å·²é€‰æ‹© = true;
                             }else{
                                 å·²é€‰æ‹© = false;
                             }
                      if (!å·²é€‰æ‹©)
                      if(iså³å°è…¿)
                         {
                             Corepriority = 14;
                             å·²é€‰æ‹© = true;
                         }else{
                             å·²é€‰æ‹© = false;
                         }
                      if (!å·²é€‰æ‹©)
                      if(iså³å¤§è…¿)
                         {
                             Corepriority = 13;
                             å·²é€‰æ‹© = true;
                         }else{
                             å·²é€‰æ‹© = false;
                         }
                      if (!å·²é€‰æ‹©)
                      if(iså³å°è‡‚)
                         {
                             Corepriority = 12;
                             å·²é€‰æ‹© = true;
                         }else{
                             å·²é€‰æ‹© = false;
                         }
                      if (!å·²é€‰æ‹©)
                      if(iså³ä¸Šè‡‚)
                         {
                             Corepriority = 11;
                             å·²é€‰æ‹© = true;
                         }else{
                             å·²é€‰æ‹© = false;
                         }
                      if (!å·²é€‰æ‹©)
                      if(iså·¦å°è…¿)
                         {
                             Corepriority = 10;
                             å·²é€‰æ‹© = true;
                         }else{
                             å·²é€‰æ‹© = false;
                         }
                      if (!å·²é€‰æ‹©)
                      if(iså·¦å¤§è…¿)
                         {
                             Corepriority = 9;
                             å·²é€‰æ‹© = true;
                         }else{
                             å·²é€‰æ‹© = false;
                         }
                      if (!å·²é€‰æ‹©)
                      if(iså·¦å°è‡‚)
                         {
                             Corepriority = 8;
                             å·²é€‰æ‹© = true;
                         }else{
                             å·²é€‰æ‹© = false;
                         }
                      if (!å·²é€‰æ‹©)
                      if(iså·¦ä¸Šè‡‚)
                         {
                             Corepriority = 7;
                             å·²é€‰æ‹© = true;
                         }else{
                             å·²é€‰æ‹© = false;
                         }
                         
                         if (!æ¼æ‰“) {
                         if (!å·²é€‰æ‹©){
                         if(Config.SilentAim.HeadPriority == Aimfirst::DHead)
                         {
                             if(iså¤´)
                             {
                                 Corepriority = 1;
                                 å·²é€‰æ‹© = true;
                             }else{
                                 å·²é€‰æ‹© = false;
                             }
                             
                         }else if(Config.SilentAim.HeadPriority == Aimfirst::Pelvis){
                             if(isç›†éª¨)
                             {
                                 Corepriority = 2;
                                 å·²é€‰æ‹© = true;
                             }else{
                                 å·²é€‰æ‹© = false;
                             }
                             
                         }else if(Config.SilentAim.HeadPriority == Aimfirst::Lhand){
                             if(iså·¦æ‰‹)
                             {
                                 Corepriority = 3;
                                 å·²é€‰æ‹© = true;
                             }else{
                                 å·²é€‰æ‹© = false;
                             }
                         }else if(Config.SilentAim.HeadPriority == Aimfirst::Rhand){
                             if(iså³æ‰‹)
                             {
                                 Corepriority = 4;   
                                 å·²é€‰æ‹© = true;
                             }else{
                                 å·²é€‰æ‹© = false;
                             }
                         }else if(Config.SilentAim.HeadPriority == Aimfirst::Lfoot){
                             if(iså·¦è„š)
                             {
                                 Corepriority = 5;
                                 å·²é€‰æ‹© = true;
                             }else{
                                 å·²é€‰æ‹© = false;
                             }
                         }else if(Config.SilentAim.HeadPriority == Aimfirst::Rfoot){
                             if(iså³è„š)
                             {
                                 Corepriority = 6;
                                 å·²é€‰æ‹© = true;
                             }else{
                                 å·²é€‰æ‹© = false;
                             }
                             
                         }}
                         
                         
                         
                         
                         
                         if (!å·²é€‰æ‹©) {
                         if(Config.SilentAim.PelvisPriority == Aimfirst::DHead)
                         {
                             if(iså¤´)
                             {
                                 Corepriority = 1;
                                 å·²é€‰æ‹© = true;
                             }else{
                                 å·²é€‰æ‹© = false;
                             }
                             
                         }else if(Config.SilentAim.PelvisPriority == Aimfirst::Pelvis){
                             if(isç›†éª¨)
                             {
                                 Corepriority = 2;
                                 å·²é€‰æ‹© = true;
                             }else{
                                 å·²é€‰æ‹© = false;
                             }
                             
                         }else if(Config.SilentAim.PelvisPriority == Aimfirst::Lhand){
                             if(iså·¦æ‰‹)
                             {
                                 Corepriority = 3;
                                 å·²é€‰æ‹© = true;
                             }else{
                                 å·²é€‰æ‹© = false;
                             }
                         }else if(Config.SilentAim.PelvisPriority == Aimfirst::Rhand){
                             if(iså³æ‰‹)
                             {
                                 Corepriority = 4;   
                                 å·²é€‰æ‹© = true;
                             }else{
                                 å·²é€‰æ‹© = false;
                             }
                         }else if(Config.SilentAim.PelvisPriority == Aimfirst::Lfoot){
                             if(iså·¦è„š)
                             {
                                 Corepriority = 5;
                                 å·²é€‰æ‹© = true;
                             }else{
                                 å·²é€‰æ‹© = false;
                             }
                         }else if(Config.SilentAim.PelvisPriority == Aimfirst::Rfoot){
                             if(iså³è„š)
                             {
                                 Corepriority = 6;
                                 å·²é€‰æ‹© = true;
                             }else{
                                 å·²é€‰æ‹© = false;
                             }
                             
                         }}
                         
                         
                         if (!å·²é€‰æ‹©){
                         if(Config.SilentAim.LhandPriority == Aimfirst::DHead)
                         {
                             if(iså¤´)
                             {
                                 Corepriority = 1;
                                 å·²é€‰æ‹© = true;
                             }else{
                                 å·²é€‰æ‹© = false;
                             }
                             
                         }else if(Config.SilentAim.LhandPriority == Aimfirst::Pelvis){
                             if(isç›†éª¨)
                             {
                                 Corepriority = 2;
                                 å·²é€‰æ‹© = true;
                             }else{
                                 å·²é€‰æ‹© = false;
                             }
                             
                         }else if(Config.SilentAim.LhandPriority == Aimfirst::Lhand){
                             if(iså·¦æ‰‹)
                             {
                                 Corepriority = 3;
                                 å·²é€‰æ‹© = true;
                             }else{
                                 å·²é€‰æ‹© = false;
                             }
                         }else if(Config.SilentAim.LhandPriority == Aimfirst::Rhand){
                             if(iså³æ‰‹)
                             {
                                 Corepriority = 4;   
                                 å·²é€‰æ‹© = true;
                             }else{
                                 å·²é€‰æ‹© = false;
                             }
                         }else if(Config.SilentAim.LhandPriority == Aimfirst::Lfoot){
                             if(iså·¦è„š)
                             {
                                 Corepriority = 5;
                                 å·²é€‰æ‹© = true;
                             }else{
                                 å·²é€‰æ‹© = false;
                             }
                         }else if(Config.SilentAim.LhandPriority == Aimfirst::Rfoot){
                             if(iså³è„š)
                             {
                                 Corepriority = 6;
                                 å·²é€‰æ‹© = true;
                             }else{
                                 å·²é€‰æ‹© = false;
                             }
                             
                         }}
                         
                         
                         
                         if (!å·²é€‰æ‹©){
                         if(Config.SilentAim.RhandPriority == Aimfirst::DHead)
                         {
                             if(iså¤´)
                             {
                                 Corepriority = 1;
                                 å·²é€‰æ‹© = true;
                             }else{
                                 å·²é€‰æ‹© = false;
                             }
                             
                         }else if(Config.SilentAim.RhandPriority == Aimfirst::Pelvis){
                             if(isç›†éª¨)
                             {
                                 Corepriority = 2;
                                 å·²é€‰æ‹© = true;
                             }else{
                                 å·²é€‰æ‹© = false;
                             }
                             
                         }else if(Config.SilentAim.RhandPriority == Aimfirst::Lhand){
                             if(iså·¦æ‰‹)
                             {
                                 Corepriority = 3;
                                 å·²é€‰æ‹© = true;
                             }else{
                                 å·²é€‰æ‹© = false;
                             }
                         }else if(Config.SilentAim.RhandPriority == Aimfirst::Rhand){
                             if(iså³æ‰‹)
                             {
                                 Corepriority = 4;   
                                 å·²é€‰æ‹© = true;
                             }else{
                                 å·²é€‰æ‹© = false;
                             }
                         }else if(Config.SilentAim.RhandPriority == Aimfirst::Lfoot){
                             if(iså·¦è„š)
                             {
                                 Corepriority = 5;
                                 å·²é€‰æ‹© = true;
                             }else{
                                 å·²é€‰æ‹© = false;
                             }
                         }else if(Config.SilentAim.RhandPriority == Aimfirst::Rfoot){
                             if(iså³è„š)
                             {
                                 Corepriority = 6;
                                 å·²é€‰æ‹© = true;
                             }else{
                                 å·²é€‰æ‹© = false;
                             }
                             
                         }}
                         
                         
                         
                         
                         if (!å·²é€‰æ‹©){
                         if(Config.SilentAim.LfootPriority == Aimfirst::DHead)
                         {
                             if(iså¤´)
                             {
                                 Corepriority = 1;
                                 å·²é€‰æ‹© = true;
                             }else{
                                 å·²é€‰æ‹© = false;
                             }
                             
                         }else if(Config.SilentAim.LfootPriority == Aimfirst::Pelvis){
                             if(isç›†éª¨)
                             {
                                 Corepriority = 2;
                                 å·²é€‰æ‹© = true;
                             }else{
                                 å·²é€‰æ‹© = false;
                             }
                             
                         }else if(Config.SilentAim.LfootPriority == Aimfirst::Lhand){
                             if(iså·¦æ‰‹)
                             {
                                 Corepriority = 3;
                                 å·²é€‰æ‹© = true;
                             }else{
                                 å·²é€‰æ‹© = false;
                             }
                         }else if(Config.SilentAim.LfootPriority == Aimfirst::Rhand){
                             if(iså³æ‰‹)
                             {
                                 Corepriority = 4;   
                                 å·²é€‰æ‹© = true;
                             }else{
                                 å·²é€‰æ‹© = false;
                             }
                         }else if(Config.SilentAim.LfootPriority == Aimfirst::Lfoot){
                             if(iså·¦è„š)
                             {
                                 Corepriority = 5;
                                 å·²é€‰æ‹© = true;
                             }else{
                                 å·²é€‰æ‹© = false;
                             }
                         }else if(Config.SilentAim.LfootPriority == Aimfirst::Rfoot){
                             if(iså³è„š)
                             {
                                 Corepriority = 6;
                                 å·²é€‰æ‹© = true;
                             }else{
                                 å·²é€‰æ‹© = false;
                             }
                             
                         }}
                         
                         
                         
                         if (!å·²é€‰æ‹©){
                         if(Config.SilentAim.RfootPriority == Aimfirst::DHead)
                         {
                             if(iså¤´)
                             {
                                 Corepriority = 1;
                                 å·²é€‰æ‹© = true;
                             }else{
                                 å·²é€‰æ‹© = false;
                             }
                             
                         }else if(Config.SilentAim.RfootPriority == Aimfirst::Pelvis){
                             if(isç›†éª¨)
                             {
                                 Corepriority = 2;
                                 å·²é€‰æ‹© = true;
                             }else{
                                 å·²é€‰æ‹© = false;
                             }
                             
                         }else if(Config.SilentAim.RfootPriority == Aimfirst::Lhand){
                             if(iså·¦æ‰‹)
                             {
                                 Corepriority = 3;
                                 å·²é€‰æ‹© = true;
                             }else{
                                 å·²é€‰æ‹© = false;
                             }
                         }else if(Config.SilentAim.RfootPriority == Aimfirst::Rhand){
                             if(iså³æ‰‹)
                             {
                                 Corepriority = 4;   
                                 å·²é€‰æ‹© = true;
                             }else{
                                 å·²é€‰æ‹© = false;
                             }
                         }else if(Config.SilentAim.RfootPriority == Aimfirst::Lfoot){
                             if(iså·¦è„š)
                             {
                                 Corepriority = 5;
                                 å·²é€‰æ‹© = true;
                             }else{
                                 å·²é€‰æ‹© = false;
                             }
                         }else if(Config.SilentAim.RfootPriority == Aimfirst::Rfoot){
                             if(iså³è„š)
                             {
                                 Corepriority = 6;
                                 å·²é€‰æ‹© = true;
                             }else{
                                 å·²é€‰æ‹© = false;
                             }
                             
                         }}






                     
                      }

                      
             
                    float height = abs(headPosSC.Y - RootPosSC.Y);
                    float width = height * 0.65f;

                    FVector middlePoint = {headPosSC.X + (width / 2), headPosSC.Y + (height / 2), 0};
                    if ((middlePoint.X >= 0 && middlePoint.X <= glWidth) &&
                        (middlePoint.Y >= 0 && middlePoint.Y <= glHeight)) {
                        FVector2D v2Middle = FVector2D((float) (glWidth / 2),
                                                       (float) (glHeight / 2));
                        FVector2D v2Loc = FVector2D(middlePoint.X, middlePoint.Y);

                        float dist = FVector2D::Distance(v2Middle, v2Loc);
                        if (Config.åœˆ) {
                        if (isInsideFOV((int) middlePoint.X, (int) middlePoint.Y)) {
                       
                        if (dist < max) {
                            max = dist;
                            result = Player;
                            }
                            
                        
                         }} else {
                         
                       
                        if (dist < max) {
                            max = dist;
                            result = Player;
                            }
                            
                        
                         }
                    }
                }
            }}
        }
    }
   // å·²é€‰æ‹© = false;
    return result;
    
}}}}}


//Aimbot 5.1
auto å¹³æ»‘è‡ªç„() {
if (Config.AimBot.å¼€å¯è‡ªç„) {
if (Config.AimBot.AINBOT == AIMBOT::PH) {

    ASTExtraPlayerCharacter *result = 0;
    float max = std::numeric_limits<float>::infinity();
    
    auto GWorld = GetWorld();
    if (GWorld) {
        ULevel *PersistentLevel = GWorld->PersistentLevel;
        if (PersistentLevel) {
            TArray<AActor *> Actors = *(TArray<AActor *> *) ((uintptr_t) PersistentLevel +
                                                             Actors_Offset);

    
    auto localPlayer = g_LocalPlayer;
    auto localController = g_LocalController;

    if (localPlayer) {
for (int i = 0; i < Actors.Num(); i++) {
                    auto Actor = Actors[i];
                    if (isObjectInvalid(Actor))
                        continue;

            if (Actor->IsA(ASTExtraPlayerCharacter::StaticClass())) {
                auto Player = (ASTExtraPlayerCharacter *) Actor;
                
                float dist = localPlayer->GetDistanceTo(Player) / 100.0f;    
                if (dist > è‡ªç„è·ç¦»)
                    continue;

                if (Player->PlayerKey == localPlayer->PlayerKey)
                    continue;

                if (Player->TeamID == localPlayer->TeamID)
                    continue;

                if (Player->bDead)
                    continue;

                if (Config.AimBot.IgnoreKnocked) {
                    if (Player->Health == 0.0f)
                        continue;
                }
                
                if (Config.AimBot.IgnoreBot) {
                    if (Player->bIsAI)
                        continue;
                }
                
                if (!localController->LineOfSightTo(Player, {0, 0, 0}, true))
                        continue;



                
                        auto HeadPos = Player->GetBonePos("Head", {});
                        HeadPos.Z = HeadPos.Z + 1.0f; //head se line ooper
                        auto RootPos = Player->GetBonePos("Root", {});

                FVector2D RootPosSC, headPosSC;
                if (W2S(HeadPos,&headPosSC) &&W2S(RootPos,&RootPosSC)) {
                                
                 
                      

                      
             
                    float height = abs(headPosSC.Y - RootPosSC.Y);
                    float width = height * 0.65f;

                    FVector middlePoint = {headPosSC.X + (width / 2), headPosSC.Y + (height / 2), 0};
                    if ((middlePoint.X >= 0 && middlePoint.X <= glWidth) &&
                        (middlePoint.Y >= 0 && middlePoint.Y <= glHeight)) {
                        FVector2D v2Middle = FVector2D((float) (glWidth / 2),
                                                       (float) (glHeight / 2));
                        FVector2D v2Loc = FVector2D(middlePoint.X, middlePoint.Y);

                        float dist = FVector2D::Distance(v2Middle, v2Loc);
                        if (Config.åœˆ) {
                        if (isInsideFOV((int) middlePoint.X, (int) middlePoint.Y)) {
                       
                        if (dist < max) {
                            max = dist;
                            result = Player;
                            }
                            
                        
                         }} else {
                         
                       
                        if (dist < max) {
                            max = dist;
                            result = Player;
                            }
                            
                        
                         }
                    }
                }
            }
        }
    }
   // å·²é€‰æ‹© = false;
    return result;
    }}}}
}


//AimBot2.0
auto GetTargetForAimBot() {
if (Config.AimBot.å¼€å¯è‡ªç„) {
if (Config.AimBot.AINBOT == AIMBOT::ZX) {

    ASTExtraPlayerCharacter *result = 0;
    float max = std::numeric_limits<float>::infinity();

    auto GWorld = GetWorld();
    if (GWorld) {
        ULevel *PersistentLevel = GWorld->PersistentLevel;
        if (PersistentLevel) {
            TArray<AActor *> Actors = *(TArray<AActor *> *) ((uintptr_t) PersistentLevel +
                                                             Actors_Offset);
    auto localPlayer = g_LocalPlayer;
    auto localController = g_LocalController;

    if (localPlayer) {
for (int i = 0; i < Actors.Num(); i++) {
                    auto Actor = Actors[i];
                    if (isObjectInvalid(Actor))
                        continue;

            if (Actor->IsA(ASTExtraPlayerCharacter::StaticClass())) {
                auto Player = (ASTExtraPlayerCharacter *) Actor;
                auto Target = (ASTExtraPlayerCharacter *) Actor;
                
                float dist = localPlayer->GetDistanceTo(Target) / 100.0f;    
                if (dist > è‡ªç„è·ç¦»)
                    continue;

                if (Player->PlayerKey == localPlayer->PlayerKey)
                    continue;

                if (Player->TeamID == localPlayer->TeamID)
                    continue;

                if (Player->bDead)
                    continue;

                if (Config.AimBot.IgnoreKnocked) {
                    if (Player->Health == 0.0f)
                        continue;
                }

               
                    if (!localController->LineOfSightTo(Player, {0, 0, 0}, true))
                        continue;
                

                if (Config.AimBot.IgnoreBot) {
                    if (Player->bIsAI)
                        continue;
                }

                auto Root = Player->GetBonePos("Root", {});
                auto Head = Player->GetBonePos("Head", {});

                FVector2D RootSc, HeadSc;
                if (W2S(Root, &RootSc) && W2S(Head, &HeadSc)) {
                    float height = abs(HeadSc.Y - RootSc.Y);
                    float width = height * 0.65f;

                    FVector middlePoint = {HeadSc.X + (width / 2), HeadSc.Y + (height / 2), 0};
                    if ((middlePoint.X >= 0 && middlePoint.X <= glWidth) && (middlePoint.Y >= 0 && middlePoint.Y <= glHeight)) {
                        FVector2D v2Middle = FVector2D((float) (glWidth / 2), (float) (glHeight / 2));
                        FVector2D v2Loc = FVector2D(middlePoint.X, middlePoint.Y);
                        
                        if (Config.åœˆ) {
                        if (isInsideFOV((int) middlePoint.X, (int) middlePoint.Y)) {

                        float dist = FVector2D::Distance(v2Middle, v2Loc);

                        if (dist < max) {
                            max = dist;
                            result = Player;
                        }
                      }} else {
                  

                        float dist = FVector2D::Distance(v2Middle, v2Loc);

                        if (dist < max) {
                            max = dist;
                            result = Player;
                        }
                      }
                    }
                }
            }
        }
    }
    

    return result;
}}}}}

auto è§¦æ‘¸è‡ªç„() {
if (Config.AimBot.å¼€å¯è‡ªç„) {
if (Config.AimBot.AINBOT == AIMBOT::CM) {

    ASTExtraPlayerCharacter *result = 0;
    float max = std::numeric_limits<float>::infinity();

    auto GWorld = GetWorld();
    if (GWorld) {
        ULevel *PersistentLevel = GWorld->PersistentLevel;
        if (PersistentLevel) {
            TArray<AActor *> Actors = *(TArray<AActor *> *) ((uintptr_t) PersistentLevel +
                                                             Actors_Offset);
    auto localPlayer = g_LocalPlayer;
    auto localController = g_LocalController;

    if (localPlayer) {
for (int i = 0; i < Actors.Num(); i++) {
                    auto Actor = Actors[i];
                    if (isObjectInvalid(Actor))
                        continue;

            if (Actor->IsA(ASTExtraPlayerCharacter::StaticClass())) {
                auto Player = (ASTExtraPlayerCharacter *) Actor;
                auto Target = (ASTExtraPlayerCharacter *) Actor;
                
                float dist = localPlayer->GetDistanceTo(Target) / 100.0f;    
                if (dist > è‡ªç„è·ç¦»)
                    continue;

                if (Player->PlayerKey == localPlayer->PlayerKey)
                    continue;

                if (Player->TeamID == localPlayer->TeamID)
                    continue;

                if (Player->bDead)
                    continue;

                if (Config.AimBot.IgnoreKnocked) {
                    if (Player->Health == 0.0f)
                        continue;
                }

               
                    if (!localController->LineOfSightTo(Player, {0, 0, 0}, true))
                        continue;
                

                if (Config.AimBot.IgnoreBot) {
                    if (Player->bIsAI)
                        continue;
                }

                auto Root = Player->GetBonePos("Root", {});
                auto Head = Player->GetBonePos("Head", {});

                FVector2D RootSc, HeadSc;
                if (W2S(Root, &RootSc) && W2S(Head, &HeadSc)) {
                    float height = abs(HeadSc.Y - RootSc.Y);
                    float width = height * 0.65f;

                    FVector middlePoint = {HeadSc.X + (width / 2), HeadSc.Y + (height / 2), 0};
                    if ((middlePoint.X >= 0 && middlePoint.X <= glWidth) && (middlePoint.Y >= 0 && middlePoint.Y <= glHeight)) {
                        FVector2D v2Middle = FVector2D((float) (glWidth / 2), (float) (glHeight / 2));
                        FVector2D v2Loc = FVector2D(middlePoint.X, middlePoint.Y);
                        
                  

                        float dist = FVector2D::Distance(v2Middle, v2Loc);

                        if (dist < max) {
                            max = dist;
                            result = Player;
                        }
                      
                    }
                }
            }
        }
    }
    

    return result;
}}}}}

auto è¶…çº§å­è¿½() {
if (Config.AimBot.å¼€å¯å­è¿½) {
if (Config.SilentAim.AINBOTA == AIMBOTA::QSZZ) {

    ASTExtraPlayerCharacter *result = 0;
    float max = std::numeric_limits<float>::infinity();

    auto GWorld = GetWorld();
    if (GWorld) {
        ULevel *PersistentLevel = GWorld->PersistentLevel;
        if (PersistentLevel) {
            TArray<AActor *> Actors = *(TArray<AActor *> *) ((uintptr_t) PersistentLevel +
                                                             Actors_Offset);
    auto localPlayer = g_LocalPlayer;
    auto localController = g_LocalController;

    if (localPlayer) {
for (int i = 0; i < Actors.Num(); i++) {
                    auto Actor = Actors[i];
                    if (isObjectInvalid(Actor))
                        continue;

            if (Actor->IsA(ASTExtraPlayerCharacter::StaticClass())) {
                auto Player = (ASTExtraPlayerCharacter *) Actor;

                if (Player->PlayerKey == localPlayer->PlayerKey)
                    continue;

                if (Player->TeamID == localPlayer->TeamID)
                    continue;

                if (Player->bDead)
                    continue;

                if (Config.SilentAim.IgnoreKnocked) {
                    if (Player->Health == 0.0f)
                        continue;
                }

                if (Config.SilentAim.VisCheck) {
                    if (!localController->LineOfSightTo(Player, {0, 0, 0}, true))
                        continue;
                }

                if (Config.SilentAim.IgnoreBot) {
                    if (Player->bIsAI)
                        continue;
                }

            
float dist = localPlayer->GetDistanceTo(Player);
                        if (dist < max) {
                            max = dist;
                            result = Player;
                        }
                    }
                }
            }
        
    
    return result;
    }}}}}
auto GetTargetByCrossDist() {
if (Config.AimBot.å¼€å¯å­è¿½) {
if (Config.SilentAim.AINBOTA == AIMBOTA::SJZZ) {

    ASTExtraPlayerCharacter *result = 0;
    float max = std::numeric_limits<float>::infinity();

   auto GWorld = GetWorld();
    if (GWorld) {
        ULevel *PersistentLevel = GWorld->PersistentLevel;
        if (PersistentLevel) {
            TArray<AActor *> Actors = *(TArray<AActor *> *) ((uintptr_t) PersistentLevel +
                                                             Actors_Offset);

    auto localPlayer = g_LocalPlayer;
    auto localController = g_LocalController;

    if (localPlayer) {
        for (int i = 0; i < Actors.Num(); i++) {
            auto Actor = Actors[i];
            if (isObjectInvalid(Actor))
                continue;

            if (Actor->IsA(ASTExtraPlayerCharacter::StaticClass())) {
                auto Player = (ASTExtraPlayerCharacter *) Actor;
                auto Target = (ASTExtraPlayerCharacter *) Actor;
                
                float dist = localPlayer->GetDistanceTo(Target) / 100.0f;
                if (dist > 50.0f)
                    continue;

                if (Player->PlayerKey == localPlayer->PlayerKey)
                    continue;

                if (Player->TeamID == localPlayer->TeamID)
                    continue;

                if (Player->bDead)
                    continue;

                if (Config.SilentAim.IgnoreKnocked) {
                    if (Player->Health == 0.0f)
                        continue;
                }

                if (Config.SilentAim.VisCheck) {
                    if (!localController->LineOfSightTo(Player, {0, 0, 0}, true))
                        continue;
                }
                if (Config.SilentAim.IgnoreBot) {
                    if (Player->bIsAI)
                        continue;
                }

                auto Root = Player->GetBonePos("Root", {});
                auto Head = Player->GetBonePos("Head", {});

                FVector2D RootSc, HeadSc;
                if (W2S(Root, &RootSc) && W2S(Head, &HeadSc)) {
                    float height = abs(HeadSc.Y - RootSc.Y);
                    float width = height * 0.65f;

                    FVector middlePoint = {HeadSc.X + (width / 2), HeadSc.Y + (height / 2), 0};
                    if ((middlePoint.X >= 0 && middlePoint.X <= glWidth) && (middlePoint.Y >= 0 && middlePoint.Y <= glHeight)) {
                        FVector2D v2Middle = FVector2D((float) (glWidth / 2), (float) (glHeight / 2));
                        FVector2D v2Loc = FVector2D(middlePoint.X, middlePoint.Y);

                                                 if(isInsideFOV((int)middlePoint.X, (int)middlePoint.Y)) {
                        float dist = FVector2D::Distance(v2Middle, v2Loc);

                        if (dist < max) {
                            max = dist;
                            result = Player;
                        }
                    }
                    }
                    }
                  }
                }
            }
        }
    }

    


    return result;
}}}





const char *GetVehicleName(ASTExtraVehicleBase *Vehicle) {
    switch (Vehicle->VehicleShapeType) {
        case ESTExtraVehicleShapeType::ESTExtraVehicleShapeType__VST_Motorbike:
        case ESTExtraVehicleShapeType::ESTExtraVehicleShapeType__VST_Motorbike_SideCart:
            return "æ‘©æ‰˜è½¦";
            break;
        case ESTExtraVehicleShapeType::ESTExtraVehicleShapeType__VST_Dacia:
        case ESTExtraVehicleShapeType::ESTExtraVehicleShapeType__VST_HeavyDacia:
            return "è½¿è½¦";
            break;
        case ESTExtraVehicleShapeType::ESTExtraVehicleShapeType__VST_MiniBus:
            return "å·´å£«";
            break;
        case ESTExtraVehicleShapeType::ESTExtraVehicleShapeType__VST_PickUp:
        case ESTExtraVehicleShapeType::ESTExtraVehicleShapeType__VST_PickUp01:
        case ESTExtraVehicleShapeType::ESTExtraVehicleShapeType__VST_HeavyPickup:
            return "å¤å¤";
            break;
        case ESTExtraVehicleShapeType::ESTExtraVehicleShapeType__VST_Buggy:
        case ESTExtraVehicleShapeType::ESTExtraVehicleShapeType__VST_HeavyBuggy:
            return "è¹¦è¹¦";
            break;
        case ESTExtraVehicleShapeType::ESTExtraVehicleShapeType__VST_UAZ:
        case ESTExtraVehicleShapeType::ESTExtraVehicleShapeType__VST_UAZ01:
        case ESTExtraVehicleShapeType::ESTExtraVehicleShapeType__VST_UAZ02:
        case ESTExtraVehicleShapeType::ESTExtraVehicleShapeType__VST_UAZ03:
        case ESTExtraVehicleShapeType::ESTExtraVehicleShapeType__VST_HeavyUAZ:
            return "å‰æ™®";
            break;
        case ESTExtraVehicleShapeType::ESTExtraVehicleShapeType__VST_PG117:
            return "å¿«è‰‡";
            break;
        case ESTExtraVehicleShapeType::ESTExtraVehicleShapeType__VST_Aquarail:
            return "æ‘©æ‰˜è‰‡";
            break;
        case ESTExtraVehicleShapeType::ESTExtraVehicleShapeType__VST_Mirado:
        case ESTExtraVehicleShapeType::ESTExtraVehicleShapeType__VST_Mirado01:
            return "å››äººè·‘è½¦";
            break;
        case ESTExtraVehicleShapeType::ESTExtraVehicleShapeType__VST_Rony:
            return "çš®å¡";
            break;
        case ESTExtraVehicleShapeType::ESTExtraVehicleShapeType__VST_Scooter:
            return "å°å‹æ‘©æ‰˜è½¦";
            break;
        case ESTExtraVehicleShapeType::ESTExtraVehicleShapeType__VST_SnowMobile:
            return "é›ªæ©‡è½¦";
            break;
        case ESTExtraVehicleShapeType::ESTExtraVehicleShapeType__VST_TukTukTuk:
            return "ä¸‰è½®è½¦";
            break;
        case ESTExtraVehicleShapeType::ESTExtraVehicleShapeType__VST_SnowBike:
            return "é›ªåœ°è‡ªè¡Œè½¦";
            break;
        case ESTExtraVehicleShapeType::ESTExtraVehicleShapeType__VST_Surfboard:
            return "å†²æµªæ¿";
            break;
        case ESTExtraVehicleShapeType::ESTExtraVehicleShapeType__VST_Snowboard:
            return "é›ªæ¿";
            break;
        case ESTExtraVehicleShapeType::ESTExtraVehicleShapeType__VST_Amphibious:
            return "è£…ç”²è½¦";
            break;
        case ESTExtraVehicleShapeType::ESTExtraVehicleShapeType__VST_LadaNiva:
            return "é›ªåœ°è¶Šé‡è½¦";
            break;
        case ESTExtraVehicleShapeType::ESTExtraVehicleShapeType__VST_UAV:
            return "æ— äººæœº";
            break;
        case ESTExtraVehicleShapeType::ESTExtraVehicleShapeType__VST_MegaDrop:
            return "è·³æ¥¼æœº";
            break;
        case ESTExtraVehicleShapeType::ESTExtraVehicleShapeType__VST_Lamborghini:
        case ESTExtraVehicleShapeType::ESTExtraVehicleShapeType__VST_Lamborghini01:
            return "å…°åšåŸºå°¼";
            break;
        case ESTExtraVehicleShapeType::ESTExtraVehicleShapeType__VST_GoldMirado:
            return "å››äººè·‘è½¦[é‡‘è‰²]";
            break;
        case ESTExtraVehicleShapeType::ESTExtraVehicleShapeType__VST_BigFoot:
            return "å¤§è„šè½¦";
            break;
        case ESTExtraVehicleShapeType::ESTExtraVehicleShapeType__VST_HeavyUH60:
            return "ç›´å‡æœº";
            break;
        default:
            return "è½½å…·";
            break;
    }
    return "Vehicle";
}

std::string playerstatus(int GetEnemyState)
{    
     switch (GetEnemyState)
     {
        case 0:
            return "å‘å‘†";
            break;
        case 1032:
            return "æ¢å¤´";
            break;
        case 268435464:
            return "å‘æŒ¥æƒ…æ„Ÿ";
            break;
        case 1552:
            return "åœ¨å–µä»€ä¹ˆ";
            break;
        case 8388616:
            return "é™è½ä¸­";
            break;
        case 131072:
            return "è¢«æ‰“å€’äº†";
            break;
        case 33554440:
            return "åé£æœº";
            break;
        case 8205:
            return "åœ¨å°„å‡»";
            break;
        case 32:
            return "åä¸‹æ¥äº†";
            break;
        case 4194303:
            return "æ­£åœ¨æ¸¸æ³³";
            break;
        case 72:
            return "åœ¨è¹¦è¿ª";
            break;
        case 8388608:
            return "é™è½ä¸­";
            break;
        case 16392:
            return "åœ¨ä¸¢ä»€ä¹ˆ";
            break;
        case 262:
            return "å†è£…";
            break;
        case 1048584:
            return "éª‘è¡Œ";
            break;
        case 8200:
            return "æŒ¥æ‹³";
            break;
        case 2056:
            return "åˆ‡æª";
            break;
        case 4194302:
            return "æ­£åœ¨æ¸¸æ³³";
            break;
        case 269:
            return "å†è£…";
            break;
        case 16777224:
            return "æ­£åœ¨çˆ¬";
            break;
        case 10:
            return "åœ¨è·‘æ­¥";
            break;
        case 263:
            return "å†è£…";
            break;
        case 65568 || 65544:
            return "åœ¨æ‰“è¯";
            break;
        case 4194308:
            return "æ­£åœ¨æ¸¸æ³³";
            break;
        case 268:
            return "å†è£…";
            break;
        case 35:
            return "åä¸‹æ¥äº†";
            break;
        case 8388617:
            return "é™è½ä¸­";
            break;
        case 33:
            return "åœ¨ç„å‡†";
            break;
        case 75:
            return "åœ¨è¹¦è¿ª";
            break;
        case 8201:
            return "æŒ¥æ‹³";
            break;
        case 266:
            return "å†è£…";
            break;
        case 32776:
            return "è¢«æ‰“å€’äº†";
            break;
        case 270:
            return "å†è£…";
            break;
        case 4194301:
            return "æ­£åœ¨æ¸¸æ³³";
            break;
        case 1033:
            return "åœ¨è·‘æ­¥";
            break;
        case 131073:
            return "è¢«æ‰“å€’äº†";
            break;
        case 524296:
            return "åœ¨å¼€è½¦è½¦";
            break;
        case 1114120:
            return "åœ¨æ‰“è¯";
            break;
        case 265:
            return "å†è£…";
            break;
        case 9:
            return "åœ¨è·‘æ­¥";
            break;
        case 262144:
            return "åœ¨æŠ½çƒŸ";
            break;
        case 8203:
            return "æŒ¥æ‹³";
            break;
        case 8202:
            return "åœ¨å°„å‡»";
            break;
        case 262152:
            return "å—å±äº†";
            break;
        case 17416:
            return "åœ¨æ‰”ä»€ä¹ˆ";
            break;
        case 17:
            return "åä¸‹æ¥äº†";
            break;
        case 11:
            return "åœ¨è·‘æ­¥";
            break;
        case 65545:
            return "åœ¨æ‰“è¯å‘¢";
            break;
        case 33554432:
            return "åé£æœº";
            break;
        case 19:
            return "è¹²ç€çš„";
            break;
        case 8208:
            return "åœ¨å°„å‡»";
            break;
        case 520:
            return "åœ¨å–µä»€ä¹ˆ";
            break;
        case 8206:
            return "åœ¨å°„å‡»";
            break;
        case 8:
            return "ç«‹èµ·æ¥äº†";
            break;
        case 16:
            return "åä¸‹æ¥äº†";
            break;
        case 13180:
            return "è¢«æ‰“å€’äº†";
            break;
        case 4194310:
            return "æ­£åœ¨æ¸¸æ³³";
            break;
        case 16393:
            return "åœ¨ä¸¢ä»€ä¹ˆ";
            break;
        case 4194309:
            return "æ­£åœ¨æ¸¸æ³³";
            break;
        case 264:
            return "å†è£…";
            break;
        case 4194305:
            return "æ­£åœ¨æ¸¸æ³³";
            break;
        case 8207:
            return "åœ¨å°„å‡»";
            break;
        case 4194307:
            return "æ­£åœ¨æ¸¸æ³³";
            break;
        return "";
    }
}

// ================================================================================================================================ //
void (*orig_shoot_event)(USTExtraShootWeaponComponent *thiz, FVector start, FRotator rot, void *unk1, int unk2) = 0;
void shoot_event(USTExtraShootWeaponComponent *thiz, FVector start, FRotator rot, ASTExtraShootWeapon *weapon, int unk1) {
if (Config.AimBot.AINBOT == AIMBOT::ZX) {
ASTExtraPlayerCharacter *Target = GetTargetForAimBot();
if (Target) {
bool triggerOk = false;
if (Config.AimBot.Trigger != EAimTrigger::None) {
if (Config.AimBot.Trigger == EAimTrigger::Shooting) {
triggerOk = g_LocalPlayer->bIsWeaponFiring;
} else if (Config.AimBot.Trigger == EAimTrigger::Scoping) {
triggerOk = g_LocalPlayer->bIsGunADS;
} else if (Config.AimBot.Trigger == EAimTrigger::Both) {
triggerOk = g_LocalPlayer->bIsWeaponFiring && g_LocalPlayer->bIsGunADS;
} else if (Config.AimBot.Trigger == EAimTrigger::Any) {
triggerOk = g_LocalPlayer->bIsWeaponFiring || g_LocalPlayer->bIsGunADS;
}
} else triggerOk = true;
if (triggerOk) {
FVector targetAimPos = Target->GetBonePos("Head", {});
if (Config.AimBot.Target == EAimTarget::Chest) {
targetAimPos.Z -= 25.0f;
}
if (Config.AimBot.Target == EAimTarget::JJ) {
                                targetAimPos.Z -= 65.0f;
                            }


UShootWeaponEntity *ShootWeaponEntityComponent = thiz->ShootWeaponEntityComponent;//é¢„åˆ¤ å‚»é€¼æºç è‡ªå¸¦çš„ç©æ„
                if (ShootWeaponEntityComponent) {
					if (Config.é¢„åˆ¤) {
                    ASTExtraVehicleBase *CurrentVehicle = Target->CurrentVehicle;
                    if (CurrentVehicle) {
                        FVector LinearVelocity = CurrentVehicle->ReplicatedMovement.LinearVelocity;

                        float dist = g_LocalPlayer->GetDistanceTo(Target);
                        auto timeToTravel = dist / ShootWeaponEntityComponent->BulletFireSpeed;

                        targetAimPos = UKismetMathLibrary::Add_VectorVector(targetAimPos, UKismetMathLibrary::Multiply_VectorFloat(LinearVelocity, timeToTravel));
                    } else {
                        FVector Velocity = Target->GetVelocity();

                        float dist = g_LocalPlayer->GetDistanceTo(Target);
                        auto timeToTravel = dist / ShootWeaponEntityComponent->BulletFireSpeed;

                        targetAimPos = UKismetMathLibrary::Add_VectorVector(targetAimPos, UKismetMathLibrary::Multiply_VectorFloat(Velocity, timeToTravel));
                    }
				}
                    FVector fDir = UKismetMathLibrary::Subtract_VectorVector(targetAimPos, g_LocalController->PlayerCameraManager->CameraCache.POV.Location);
                    rot = UKismetMathLibrary::Conv_VectorToRotator(fDir);
                }

FVector fDir = UKismetMathLibrary::Subtract_VectorVector(targetAimPos, g_LocalController->PlayerCameraManager->CameraCache.POV.Location);
rot = UKismetMathLibrary::Conv_VectorToRotator(fDir);
}

}
}

    if (Config.AimBot.å¼€å¯å­è¿½) {
        if (Config.SilentAim.AINBOTA == AIMBOTA::QSZZ) {
        ASTExtraPlayerCharacter *Target = è¶…çº§å­è¿½();
        if (Target)
					{
						bool triggerOk = false;						
							if (Config.AimBot.Trigger == EAimTrigger::Shooting)
							{
								triggerOk = g_LocalPlayer->bIsWeaponFiring;
							}
							else if (Config.AimBot.Trigger == EAimTrigger::Scoping)
							{
								triggerOk = g_LocalPlayer->bIsGunADS;
							}
							else if (Config.AimBot.Trigger == EAimTrigger::Both)
							{
								triggerOk = g_LocalPlayer->bIsWeaponFiring && g_LocalPlayer->bIsGunADS;
							}
							else if (Config.AimBot.Trigger == EAimTrigger::Any)
							{
								triggerOk = g_LocalPlayer->bIsWeaponFiring || g_LocalPlayer->bIsGunADS;
							}
						
						else
							triggerOk = true;
            if (triggerOk) {
                FVector targetAimPos = Target->GetBonePos("Head", {});
                if (Config.AimBot.Trigger == EAimTarget::Chest) {
                    targetAimPos.Z -= 25.0f;
                }
                
                
                UShootWeaponEntity *ShootWeaponEntityComponent = thiz->ShootWeaponEntityComponent;

				
			
                if (ShootWeaponEntityComponent) {
                    ASTExtraVehicleBase *CurrentVehicle = Target->CurrentVehicle;
                    if (CurrentVehicle) {
                        FVector LinearVelocity = CurrentVehicle->ReplicatedMovement.LinearVelocity;

                        float dist = g_LocalPlayer->GetDistanceTo(Target);
                        auto timeToTravel = dist / ShootWeaponEntityComponent->BulletFireSpeed;

                        targetAimPos = UKismetMathLibrary::Add_VectorVector(targetAimPos, UKismetMathLibrary::Multiply_VectorFloat(LinearVelocity, timeToTravel));
                    } else {
                        FVector Velocity = Target->GetVelocity();

                        float dist = g_LocalPlayer->GetDistanceTo(Target);
                        auto timeToTravel = dist / ShootWeaponEntityComponent->BulletFireSpeed;

                        targetAimPos = UKismetMathLibrary::Add_VectorVector(targetAimPos, UKismetMathLibrary::Multiply_VectorFloat(Velocity, timeToTravel));
                    }
                    rot = ToRotator(g_LocalController->PlayerCameraManager->CameraCache.POV.Location, targetAimPos);
                                                       
                                        
                                    
                                }
                            }
                        }
    }
}

    if (Config.AimBot.å¼€å¯å­è¿½) {
        if (Config.SilentAim.AINBOTA == AIMBOTA::SJZZ) {
ASTExtraPlayerCharacter *Target = GetTargetByCrossDist();
        if (Target)
					{
						bool triggerOk = false;						
							if (Config.AimBot.Trigger == EAimTrigger::Shooting)
							{
								triggerOk = g_LocalPlayer->bIsWeaponFiring;
							}
							else if (Config.AimBot.Trigger == EAimTrigger::Scoping)
							{
								triggerOk = g_LocalPlayer->bIsGunADS;
							}
							else if (Config.AimBot.Trigger == EAimTrigger::Both)
							{
								triggerOk = g_LocalPlayer->bIsWeaponFiring && g_LocalPlayer->bIsGunADS;
							}
							else if (Config.AimBot.Trigger == EAimTrigger::Any)
							{
								triggerOk = g_LocalPlayer->bIsWeaponFiring || g_LocalPlayer->bIsGunADS;
							}
						
						else
							triggerOk = true;
            if (triggerOk) {
                FVector targetAimPos = Target->GetBonePos("Head", {});
                if (Config.AimBot.Trigger == EAimTarget::Chest) {
                    targetAimPos.Z -= 25.0f;
                }
                
                
                UShootWeaponEntity *ShootWeaponEntityComponent = thiz->ShootWeaponEntityComponent;

				
			
                if (ShootWeaponEntityComponent) {
                    ASTExtraVehicleBase *CurrentVehicle = Target->CurrentVehicle;
                    if (CurrentVehicle) {
                        FVector LinearVelocity = CurrentVehicle->ReplicatedMovement.LinearVelocity;

                        float dist = g_LocalPlayer->GetDistanceTo(Target);
                        auto timeToTravel = dist / ShootWeaponEntityComponent->BulletFireSpeed;

                        targetAimPos = UKismetMathLibrary::Add_VectorVector(targetAimPos, UKismetMathLibrary::Multiply_VectorFloat(LinearVelocity, timeToTravel));
                    } else {
                        FVector Velocity = Target->GetVelocity();

                        float dist = g_LocalPlayer->GetDistanceTo(Target);
                        auto timeToTravel = dist / ShootWeaponEntityComponent->BulletFireSpeed;

                        targetAimPos = UKismetMathLibrary::Add_VectorVector(targetAimPos, UKismetMathLibrary::Multiply_VectorFloat(Velocity, timeToTravel));
                    }
                    rot = ToRotator(g_LocalController->PlayerCameraManager->CameraCache.POV.Location, targetAimPos);
                                                       
                                        
                                    
                                }
                            }
                        }
    }}





return orig_shoot_event(thiz, start, rot, weapon, unk1);
}
class FPSCounter
{
  protected:
	unsigned int m_fps;
	unsigned int m_fpscount;
	long m_fpsinterval;

  public:
	FPSCounter() : m_fps(0), m_fpscount(0), m_fpsinterval(0)
	{
	}

	void update()
	{
		m_fpscount++;

		if (m_fpsinterval < time(0))
		{
			m_fps = m_fpscount;

			m_fpscount = 0;
			m_fpsinterval = time(0) + 1;
		}
	}

	unsigned int get() const
	{
		return m_fps;
	}
};

FPSCounter fps;


	void loadConfig()
{
int fd = open("/data/data/com.tencent.ig/files/sc.ini", O_RDONLY);

read(fd, &Config, sizeof(Config));   



close(fd);


}
void loadfov()
{
int fd = open("/data/data/com.tencent.ig/files/fov.ini", O_RDONLY);


read(fd, &fov, sizeof(fov));

close(fd);


}

void loadaim10()
{  
int fd = open("/data/data/com.tencent.ig/files/aim10.ini", O_RDONLY);


read(fd, &Aim10, sizeof(Aim10));

close(fd);

}

void loadaim50()
{  
int fd = open("/data/data/com.tencent.ig/files/aim50.ini", O_RDONLY);


read(fd, &Aim50, sizeof(Aim50));

close(fd);

}
void loadaim100()
{
int fd = open("/data/data/com.tencent.ig/files/aim100.ini", O_RDONLY);


read(fd, &Aim100, sizeof(Aim100));

close(fd);

}

void loadaim150()
{
int fd = open("/data/data/com.tencent.ig/files/aim150.ini", O_RDONLY);


read(fd, &Aim150, sizeof(Aim150));

close(fd);

}

void loadaim200()
{
int fd = open("/data/data/com.tencent.ig/files/aim200.ini", O_RDONLY);


read(fd, &Aim200, sizeof(Aim200));

close(fd);

}

void loadaim250()
{
int fd = open("/data/data/com.tencent.ig/files/aim250.ini", O_RDONLY);


read(fd, &Aim250, sizeof(Aim250));

close(fd);

}

void loadaim300()
{
int fd = open("/data/data/com.tencent.ig/files/aim300.ini", O_RDONLY);


read(fd, &Aim300, sizeof(Aim300));

close(fd);

}



void saveConfig()
{

int fd = open("/data/data/com.tencent.ig/files/sc.ini", O_WRONLY | O_CREAT);
system("chmod 777 /data/data/com.tencent.ig/files/sc.ini");
write(fd, &Config , sizeof(Config));   // å†™å…¥æ–‡æœ¬


close(fd);
}

void savefov()
{

int fd = open("/data/data/com.tencent.ig/files/fov.ini", O_WRONLY | O_CREAT);
system("chmod 777 /data/data/com.tencent.ig/files/fov.ini");

write(fd, &fov , sizeof(fov));
close(fd);
}

void saveaim10()
{

int fd = open("/data/data/com.tencent.ig/files/aim10.ini", O_WRONLY | O_CREAT);
system("chmod 777 /data/data/com.tencent.ig/files/aim10.ini");

write(fd, &Aim10 , sizeof(Aim10));
close(fd);
}

void saveaim50()
{

int fd = open("/data/data/com.tencent.ig/files/aim50.ini", O_WRONLY | O_CREAT);
system("chmod 777 /data/data/com.tencent.ig/files/aim50.ini");

write(fd, &Aim50 , sizeof(Aim50));
close(fd);
}

void saveaim100()
{

int fd = open("/data/data/com.tencent.ig/files/aim100.ini", O_WRONLY | O_CREAT);
system("chmod 777 /data/data/com.tencent.ig/files/aim100.ini");

write(fd, &Aim100 , sizeof(Aim100));
close(fd);
}

void saveaim150()
{

int fd = open("/data/data/com.tencent.ig/files/aim150.ini", O_WRONLY | O_CREAT);
system("chmod 777 /data/data/com.tencent.ig/files/aim150.ini");

write(fd, &Aim150 , sizeof(Aim150));
close(fd);
}
void saveaim200()
{

int fd = open("/data/data/com.tencent.ig/files/aim200.ini", O_WRONLY | O_CREAT);
system("chmod 777 /data/data/com.tencent.ig/files/aim200.ini");

write(fd, &Aim200 , sizeof(Aim200));
close(fd);
}

void saveaim250()
{

int fd = open("/data/data/com.tencent.ig/files/aim250.ini", O_WRONLY | O_CREAT);
system("chmod 777 /data/data/com.tencent.ig/files/aim250.ini");

write(fd, &Aim250 , sizeof(Aim250));
close(fd);
}

void saveaim300()
{

int fd = open("/data/data/com.tencent.ig/files/aim300.ini", O_WRONLY | O_CREAT);
system("chmod 777 /data/data/com.tencent.ig/files/aim300.ini");

write(fd, &Aim300 , sizeof(Aim300));
close(fd);
}





void loadCFG(){
loadConfig();
loadfov();
loadaim10();
loadaim50();
loadaim100();
loadaim150();
loadaim200();
loadaim250();
loadaim300();
}

void saveCFG(){
saveConfig();
savefov();
saveaim10();
saveaim50();
saveaim100();
saveaim150();
saveaim200();
saveaim250();
saveaim300();
}

std::string getClipboardText()
{
	if (!g_App)
		return "";
	auto activity = g_App->activity;
	if (!activity)
		return "";
	auto vm = activity->vm;
	if (!vm)
		return "";
	auto object = activity->clazz;
	if (!object)
		return "";
	std::string result;
	JNIEnv *env;
	vm->AttachCurrentThread(&env, 0);
	{
		auto ContextClass = env->FindClass("android/content/Context");
		auto getSystemServiceMethod = env->GetMethodID(ContextClass, "getSystemService", "(Ljava/lang/String;)Ljava/lang/Object;");
		auto str = env->NewStringUTF("clipboard");
		auto clipboardManager = env->CallObjectMethod(object, getSystemServiceMethod, str);
		env->DeleteLocalRef(str);
		auto ClipboardManagerClass = env->FindClass("android/content/ClipboardManager");
		auto getText = env->GetMethodID(ClipboardManagerClass, "getText", "()Ljava/lang/CharSequence;");
		auto CharSequenceClass = env->FindClass("java/lang/CharSequence");
		auto toStringMethod = env->GetMethodID(CharSequenceClass, "toString", "()Ljava/lang/String;");
		auto text = env->CallObjectMethod(clipboardManager, getText);
		if (text)
		{
			str = (jstring)env->CallObjectMethod(text, toStringMethod);
			result = env->GetStringUTFChars(str, 0);
			env->DeleteLocalRef(str);
			env->DeleteLocalRef(text);
		}
		env->DeleteLocalRef(CharSequenceClass);
		env->DeleteLocalRef(ClipboardManagerClass);
		env->DeleteLocalRef(clipboardManager);
		env->DeleteLocalRef(ContextClass);
	}
	vm->DetachCurrentThread();
	return result;
}

// ======================================================================== //
#include "ç™»é™†.h"


int éšæœºé¢œè‰²(){
	 int çº¢;
	 int ç»¿;
	 int è“;
	 int é¢œè‰²=70;
	 çº¢=(0+255*rand());
	 ç»¿=(0+255*rand());
	 è“=(0+255*rand());
	 if(sizeof(çº¢)==1) çº¢=çº¢+çº¢;
	 if(sizeof(ç»¿)==1) ç»¿=ç»¿+ç»¿;
	 if(sizeof(è“)==1) è“=è“+è“;
	 return é¢œè‰²+çº¢+ç»¿+è“;
}
int é¢œè‰²æ•°ç»„[100];   // å¿…é¡»åˆ†é…ç©ºé—´
void é¢œè‰²åˆå§‹åŒ–(){
    srand((unsigned)time(NULL));
	for(int æ•°é‡=0;æ•°é‡<100;æ•°é‡++){
		é¢œè‰²æ•°ç»„[æ•°é‡]=éšæœºé¢œè‰²();
	}
}

int è·å–é¢œè‰²(int é¢„å·){
	if(é¢œè‰²æ•°ç»„[é¢„å·-1]==NULL)
		return 88303030;
	else
	    return é¢œè‰²æ•°ç»„[é¢„å·-1];
}

int é˜Ÿä¼é¢œè‰²(int é˜Ÿä¼){
	if(é˜Ÿä¼<=100 && é˜Ÿä¼>0)
		return è·å–é¢œè‰²(é˜Ÿä¼);
	else
		return 3411641396;
}






void RotateTriangle(std::array<Vector3, 3> & points, float rotation) {
 const auto points_center = (points.at(0) + points.at(1) + points.at(2)) / 3;
 for (auto & point : points) {
  point = point - points_center;
  const auto temp_x = point.X;
  const auto temp_y = point.Y;
  const auto theta = DEG2RAD(rotation);
  const auto c = cosf(theta);
  const auto s = sinf(theta);
  point.X = temp_x * c - temp_y * s;
  point.Y = temp_x * s + temp_y * c;
  point = point + points_center;
 }
}
FVector WorldToRadar(float Yaw, FVector Origin, FVector LocalOrigin, float PosX, float PosY, Vector3 Size, bool &outbuff) {
 bool flag = false;
 double num = (double)Yaw;
 double num2 = num * 0.017453292519943295;
 float num3 = (float)std::cos(num2);
 float num4 = (float)std::sin(num2);
 float num5 = Origin.X - LocalOrigin.X;
 float num6 = Origin.Y - LocalOrigin.Y;
 struct FVector Xector;
 Xector.X = (num6 * num3 - num5 * num4) / 150.f;
 Xector.Y = (num5 * num3 + num6 * num4) / 150.f;
 struct FVector Xector2;
 Xector2.X = Xector.X + PosX + Size.X / 2.f;
 Xector2.Y = -Xector.Y + PosY + Size.Y / 2.f;
 bool flag2 = Xector2.X > PosX + Size.X;
 if (flag2) {
  Xector2.X = PosX + Size.X;
 }else{
  bool flag3 = Xector2.X < PosX;
  if (flag3) {
   Xector2.X = PosX;
  }
 }
 bool flag4 = Xector2.Y > PosY + Size.Y;
 if (flag4) {
  Xector2.Y = PosY + Size.Y;
 }else{
  bool flag5 = Xector2.Y < PosY;
  if (flag5){
   Xector2.Y = PosY;
  }
 }
 bool flag6 = Xector2.Y == PosY || Xector2.X == PosX;
 if (flag6){
  flag = true;
 }
 outbuff = flag;
 return Xector2;
}
void VectorAnglesRadar(Vector3 & forward, FVector & angles) {
 if (forward.X == 0.f && forward.Y == 0.f) {
  angles.X = forward.Z > 0.f ? -90.f : 90.f;
  angles.Y = 0.f;
 } else {
  angles.X = RAD2DEG(atan2(-forward.Z, forward.Magnitude(forward)));
  angles.Y = RAD2DEG(atan2(forward.Y, forward.X));
 }
 angles.Z = 0.f;
}
//æ–¹æ¡†
void Box3D(ImDrawList *draw, FVector origin, FVector extends, ImColor col) {
    origin.X -= extends.X / 2.f;
    origin.Y -= extends.Y / 2.f;
    origin.Z -= extends.Z / 2.f;
    
    
 FVector one = origin;
 FVector two = origin; two.X += extends.X;
 FVector tree = origin; tree.X += extends.X; tree.Y += extends.Y;
 FVector four = origin; four.Y += extends.Y;

 FVector five = one; five.Z += extends.Z;
 FVector six = two; six.Z += extends.Z;
 FVector seven = tree; seven.Z += extends.Z;
 FVector eight = four; eight.Z += extends.Z;
}
FVector2D pushToScreenBorder(FVector2D Pos, FVector2D screen, int borders, int offset) {
int x = (int)Pos.X;
int y = (int)Pos.Y;
if ((borders & 1) == 1) {
y = 0 - offset;
}
if ((borders & 2) == 2) {
x = (int)screen.X + offset;
}
if ((borders & 4) == 4) {
y = (int)screen.Y + offset;
}
if ((borders & 8) == 8) {
x = 0 - offset;
}
return FVector2D(x, y);
}
int isOutsideSafezone(FVector2D pos, FVector2D screen) {
FVector2D mSafezoneTopLeft(screen.X * 0.04f, screen.Y * 0.04f);
FVector2D mSafezoneBottomRight(screen.X * 0.96f, screen.Y * 0.96f);
int result = 0;
if (pos.Y < mSafezoneTopLeft.Y) {
result |= 1;
}
if (pos.X > mSafezoneBottomRight.X) {
result |= 2;
}
if (pos.Y > mSafezoneBottomRight.Y) {
result |= 4;
}
if (pos.X < mSafezoneTopLeft.X) {
result |= 8;
}
return result;
}




//#include "ä¸Šè‰².h"



//ESP/////=====NIKE///=IMGUI PLUS
void DrawESP(ImDrawList *draw){


if (çª—å£éšè—) {
ImGuiIO& io = ImGui::GetIO(); if (io.MousePos.y == çª—å£Y && io.MousePos.x == çª—å£X) { } else {
éšè— = false;
çª—å£Y = io.MousePos.y;
çª—å£X = io.MousePos.x; if (io.MousePos.x > 0 && io.MousePos.x < 100) { if (io.MousePos.y > 0 && io.MousePos.y < 100) { if (éšè—1 < 2) { if (!éšè—) {
éšè—1 = éšè—1 + 1;
éšè— = true; }} else { if (éšè—çª—å£) {
éšè—çª—å£ = false;
éšè—1 = 0; } else {
éšè—çª—å£ = true;
éšè—1 = 0; }}} else {
éšè—1 = 0; }} else {
éšè—1 = 0; }}} else {
éšè—çª—å£ = false;
éšè—1 = 0; }
if (æ˜¾ç¤ºæ–‡å­— || Config.åœˆ || æ˜¾ç¤ºåˆ°æœŸæ—¶é—´) { if (æ–‡å­—8 == 0) { if (æ–‡å­—1 == 255) { if (æ–‡å­—2 == 255) { if (æ–‡å­—3 == 255) {
æ–‡å­—8 = 1; } else {
æ–‡å­—3 = æ–‡å­—3 + 1; }} else {
æ–‡å­—2 = æ–‡å­—2 + 1; }} else {
æ–‡å­—1 = æ–‡å­—1 + 1; }} else { if (æ–‡å­—1 == 0) { if (æ–‡å­—2 == 0) { if (æ–‡å­—3 == 0) {
æ–‡å­—8 = 0; } else {
æ–‡å­—3 = æ–‡å­—3 - 1; }} else {
æ–‡å­—2 = æ–‡å­—2 - 1; }} else {
æ–‡å­—1 = æ–‡å­—1 - 1; }} if (æ–‡å­—6 == 0) {
æ–‡å­—4 = æ–‡å­—4 + 1; if (æ–‡å­—4 == 255) {
æ–‡å­—6 = 1; }} else {
æ–‡å­—4 = æ–‡å­—4 - 1; if (æ–‡å­—4 == 100) {
æ–‡å­—6 = 0; }} if (æ–‡å­—7 == 0) {
æ–‡å­—5 = æ–‡å­—5 + 0.5; if (æ–‡å­—5 == 300) {
æ–‡å­—7 = 1; }} else {
æ–‡å­—5 = æ–‡å­—5 - 0.5; if (æ–‡å­—5 == 150) {
æ–‡å­—7 = 0; }} 

/*if (æ–‡å­—8 == 0) { if (æ–‡å­—11 == 0) {
æ–‡å­—12 + 1;
if (æ–‡å­—12 == 6) {
æ–‡å­—12 = 0; }
æ–‡å­—11 = 1; }} else if (æ–‡å­—8 == 1) { if (æ–‡å­—11 == 1) {
æ–‡å­—11 = 0; }}*/
if (æ–‡å­—xx = 1500) {
æ–‡å­—12 + 1; if (æ–‡å­—12 = 6) {
æ–‡å­—12 = 0; }
æ–‡å­—xx = 0; } else { æ–‡å­—xx + 1; }}









 if (æ˜¾ç¤ºæ–‡å­—) {

if (æ–‡å­—12 == 0) {
draw->AddText({ ((float) density / 20.0f), æ–‡å­—5}, IM_COL32(æ–‡å­—1,æ–‡å­—2,æ–‡å­—3, æ–‡å­—4),OBFUSCATE("\n\nï½œPUSSY CHEAT ä¸Šå¸‚V2ï½œ"));
}
if (æ–‡å­—12 == 1) {
draw->AddText({ ((float) density / 20.0f), æ–‡å­—5}, IM_COL32(æ–‡å­—1,æ–‡å­—2,æ–‡å­—3, æ–‡å­—4),OBFUSCATE("\n\nï½œç¨³å®šç›´è£…ï½œ"));
}
if (æ–‡å­—12 == 2) {
draw->AddText({ ((float) density / 20.0f), æ–‡å­—5}, IM_COL32(æ–‡å­—1,æ–‡å­—2,æ–‡å­—3, æ–‡å­—4),OBFUSCATE("\n\nï½œåŠ å…¥å®˜æ–¹ç”µæŠ¥ç¾¤ï½œ"));
}
if (æ–‡å­—12 == 3) {
draw->AddText({ ((float) density / 20.0f), æ–‡å­—5}, IM_COL32(æ–‡å­—1,æ–‡å­—2,æ–‡å­—3, æ–‡å­—4),OBFUSCATE("\n\nï½œ@PUSSYCHEATS69ï½œ"));
}
if (æ–‡å­—12 == 4) {
draw->AddText({ ((float) density / 20.0f), æ–‡å­—5}, IM_COL32(æ–‡å­—1,æ–‡å­—2,æ–‡å­—3, æ–‡å­—4),OBFUSCATE("\n\nï½œå¿…é¡»æ¼”æˆ/ä¸æ¼”å°å·ï½œ"));
}
if (æ–‡å­—12 == 5) {
draw->AddText({ ((float) density / 20.0f), æ–‡å­—5}, IM_COL32(æ–‡å­—1,æ–‡å­—2,æ–‡å­—3, æ–‡å­—4),OBFUSCATE("\n\nï½œç¥ä½ æœ‰ä¸ªå¥½ç”Ÿæ´»ï½œ"));
}
if (æ˜¾ç¤ºåˆ°æœŸæ—¶é—´) {
std::string åˆ°æœŸ = "\n\n\nåˆ°æœŸæ—¶é—´:";
åˆ°æœŸ += EXP;
åˆ°æœŸ += "\n";
åˆ°æœŸ += Mobile.c_str();
draw->AddText({ ((float) density / 10.0f), æ–‡å­—5}, IM_COL32(æ–‡å­—1, æ–‡å­—2, æ–‡å­—3, æ–‡å­—4), åˆ°æœŸ.c_str()); }}
if (è¯­è¨€ == 0) {
	if (Config.AimBot.å¼€å¯è‡ªç„) {
 draw->AddText({ ((float) density / 10.0f), 150}, IM_COL32(255,000,000, 255),OBFUSCATE("è‡ªåŠ¨ç„å‡†[ON]"));
}
if (Config.AimBot.å¼€å¯å­è¿½) {
 draw->AddText({ ((float) density / 10.0f), 150}, IM_COL32(255,000,000, 255),OBFUSCATE("å­å¼¹è¿½è¸ª[ON]"));
}} else if (è¯­è¨€ == 1) {
if (Config.AimBot.å¼€å¯è‡ªç„) {
 draw->AddText({ ((float) density / 10.0f), 150}, IM_COL32(255,000,000, 255),OBFUSCATE("AIMBOT[ON]"));
}
if (Config.AimBot.å¼€å¯å­è¿½) {
 draw->AddText({ ((float) density / 10.0f), 150}, IM_COL32(255,000,000, 255),OBFUSCATE("BULLET[ON]"));
}
}
if (Config.åœˆ) {
draw->AddRect({(screenWidth/3)-(Config.SilentAim.Cross/2), (screenHeight/3)-(Config.SilentAim.Cross/2)}, {(screenWidth/3)+(Config.SilentAim.Cross/2), (screenHeight/3)+(Config.SilentAim.Cross/2)}, IM_COL32(æ–‡å­—1,æ–‡å­—2,æ–‡å­—3,æ–‡å­—4), 15, 0, 1.7);
}


/*if (clear) {
"rm -rf /storage/emulated/0/Android/data/com.tencent.ig/files/UE4Game/ShadowTrackerExtra/ShadowTrackerExtra/Saved/Paks/game_patch_2.4.1.17122.pak"
"rm -rf /storage/emulated/0/Android/data/com.tencent.ig/files/UE4Game/ShadowTrackerExtra/ShadowTrackerExtra/Saved/Paks/game_patch_2.4.1.17123.pak"
"rm -rf /storage/emulated/0/Android/data/com.tencent.ig/files/UE4Game/ShadowTrackerExtra/ShadowTrackerExtra/Saved/Paks/game_patch_2.4.1.17124.pak"
"rm -rf /storage/emulated/0/Android/data/com.tencent.ig/files/UE4Game/ShadowTrackerExtra/ShadowTrackerExtra/Saved/Paks/game_patch_2.4.1.17125.pak"
"rm -rf /storage/emulated/0/Android/data/com.tencent.ig/files/UE4Game/ShadowTrackerExtra/ShadowTrackerExtra/Saved/Paks/game_patch_2.4.1.17126.pak"
"rm -rf /storage/emulated/0/Android/data/com.tencent.ig/files/UE4Game/ShadowTrackerExtra/ShadowTrackerExtra/Saved/Paks/game_patch_2.4.1.17127.pak"
"rm -rf /storage/emulated/0/Android/data/com.tencent.ig/files/UE4Game/ShadowTrackerExtra/ShadowTrackerExtra/Saved/Paks/game_patch_2.4.1.17128.pak"
"rm -rf /storage/emulated/0/Android/data/com.tencent.ig/files/UE4Game/ShadowTrackerExtra/ShadowTrackerExtra/Saved/Paks/game_patch_2.4.1.17129.pak"
"rm -rf /storage/emulated/0/Android/data/com.tencent.ig/files/UE4Game/ShadowTrackerExtra/ShadowTrackerExtra/Saved/Paks/game_patch_2.4.1.17130.pak"
"rm -rf /storage/emulated/0/Android/data/com.tencent.ig/files/UE4Game/ShadowTrackerExtra/ShadowTrackerExtra/Saved/Paks/game_patch_2.4.1.17132.pak"
"rm -rf /storage/emulated/0/Android/data/com.tencent.ig/files/UE4Game/ShadowTrackerExtra/ShadowTrackerExtra/Saved/Paks/game_patch_2.4.1.17134.pak"
"rm -rf /storage/emulated/0/Android/data/com.tencent.ig/files/UE4Game/ShadowTrackerExtra/ShadowTrackerExtra/Saved/Paks/game_patch_2.4.1.17135.pak"
"rm -rf /storage/emulated/0/Android/data/com.tencent.ig/files/UE4Game/ShadowTrackerExtra/ShadowTrackerExtra/Saved/Paks/1375135419_59_2.4.1.17136_20230117180727_351170870_cures.ifs.res"
"rm -rf /storage/emulated/0/Android/data/com.tencent.ig/files/UE4Game/ShadowTrackerExtra/ShadowTrackerExtra/Saved/Paks/apollo_reslist.flist"
"rm -rf /storage/emulated/0/Android/data/com.tencent.ig/files/UE4Game/ShadowTrackerExtra/ShadowTrackerExtra/Saved/Paks/core_patch_2.4.1.17136.pak");
clear = false;
}*/

/*if (clear) {
system("rm -rf /data/data/com.tencent.ig/app_appcache"
"rm -rf /data/data/com.tencent.ig/app_bugly"
"rm -rf /data/data/com.tencent.ig/app_crashrecord"
"rm -rf /data/data/com.tencent.ig/app_databases"
"rm -rf /data/data/com.tencent.ig/app_geolocation"
"rm -rf /storage/emulated/0/Android/data/com.tencent.ig/files/UE4Game/ShadowTrackerExtra/ShadowTrackerExtra/Saved/Logs"
"rm -rf /storage/emulated/0/Android/data/com.tencent.ig/files/UE4Game/ShadowTrackerExtra/ShadowTrackerExtra/Saved/GameErrorNoRecords"
"rm -rf /storage/emulated/0/Android/data/com.tencent.ig/files/UE4Game/ShadowTrackerExtra/ShadowTrackerExtra/Saved/Config"
"rm -rf /storage/emulated/0/Android/data/com.tencent.ig/files/UE4Game/ShadowTrackerExtra/ShadowTrackerExtra/Saved/Pandora"
"rm -rf /data/data/com.tencent.ig/app_appcache"
"rm -rf /data/data/com.tencent.ig/app_bugly"
"rm -rf /data/data/com.tencent.ig/app_crashrecord"
"rm -rf /data/data/com.tencent.ig/app_databases"
"rm -rf /data/data/com.tencent.ig/app_geolocation"
"rm -rf /storage/emulated/0/Android/data/com.tencent.ig/files/UE4Game/ShadowTrackerExtra/ShadowTrackerExtra/Saved/Logs"
"rm -rf /storage/emulated/0/Android/data/com.tencent.ig/files/UE4Game/ShadowTrackerExtra/ShadowTrackerExtra/Saved/GameErrorNoRecords"
"rm -rf /storage/emulated/0/Android/data/com.tencent.ig/files/UE4Game/ShadowTrackerExtra/ShadowTrackerExtra/Saved/Config"
"rm -rf /storage/emulated/0/Android/data/com.tencent.ig/files/UE4Game/ShadowTrackerExtra/ShadowTrackerExtra/Saved/Pandora"
"rm -rf /data/data/com.tencent.ig/app_appcache"
"rm -rf /data/data/com.tencent.ig/app_bugly"
"rm -rf /data/data/com.tencent.ig/app_crashrecord"
"rm -rf /data/data/com.tencent.ig/app_databases"
"rm -rf /data/data/com.tencent.ig/app_geolocation"
"rm -rf /storage/emulated/0/Android/data/com.tencent.ig/files/UE4Game/ShadowTrackerExtra/ShadowTrackerExtra/Saved/Logs"
"rm -rf /storage/emulated/0/Android/data/com.tencent.ig/files/UE4Game/ShadowTrackerExtra/ShadowTrackerExtra/Saved/GameErrorNoRecords"
"rm -rf /storage/emulated/0/Android/data/com.tencent.ig/files/UE4Game/ShadowTrackerExtra/ShadowTrackerExtra/Saved/Config"
"rm -rf /storage/emulated/0/Android/data/com.tencent.ig/files/UE4Game/ShadowTrackerExtra/ShadowTrackerExtra/Saved/Pandora"
"rm -rf /data/data/com.tencent.ig/app_appcache"
"rm -rf /data/data/com.tencent.ig/app_bugly"
"rm -rf /data/data/com.tencent.ig/app_crashrecord"
"rm -rf /data/data/com.tencent.ig/app_databases"
"rm -rf /data/data/com.tencent.ig/app_geolocation"
"rm -rf /storage/emulated/0/Android/data/com.tencent.ig/files/UE4Game/ShadowTrackerExtra/ShadowTrackerExtra/Saved/Logs"
"rm -rf /storage/emulated/0/Android/data/com.tencent.ig/files/UE4Game/ShadowTrackerExtra/ShadowTrackerExtra/Saved/GameErrorNoRecords"
"rm -rf /storage/emulated/0/Android/data/com.tencent.ig/files/UE4Game/ShadowTrackerExtra/ShadowTrackerExtra/Saved/Config"
"rm -rf /storage/emulated/0/Android/data/com.tencent.ig/files/UE4Game/ShadowTrackerExtra/ShadowTrackerExtra/Saved/Pandora"
"rm -rf /data/data/com.tencent.ig/app_appcache"
"rm -rf /data/data/com.tencent.ig/app_bugly"
"rm -rf /data/data/com.tencent.ig/app_crashrecord"
"rm -rf /data/data/com.tencent.ig/app_databases"
"rm -rf /data/data/com.tencent.ig/app_geolocation"
"rm -rf /storage/emulated/0/Android/data/com.tencent.ig/files/UE4Game/ShadowTrackerExtra/ShadowTrackerExtra/Saved/Logs"
"rm -rf /storage/emulated/0/Android/data/com.tencent.ig/files/UE4Game/ShadowTrackerExtra/ShadowTrackerExtra/Saved/GameErrorNoRecords"
"rm -rf /storage/emulated/0/Android/data/com.tencent.ig/files/UE4Game/ShadowTrackerExtra/ShadowTrackerExtra/Saved/Config"
"rm -rf /storage/emulated/0/Android/data/com.tencent.ig/files/UE4Game/ShadowTrackerExtra/ShadowTrackerExtra/Saved/Pandora"
"rm -rf /data/data/com.tencent.ig/app_appcache"
"rm -rf /data/data/com.tencent.ig/app_bugly"
"rm -rf /data/data/com.tencent.ig/app_crashrecord"
"rm -rf /data/data/com.tencent.ig/app_databases"
"rm -rf /data/data/com.tencent.ig/app_geolocation"
"rm -rf /storage/emulated/0/Android/data/com.tencent.ig/files/UE4Game/ShadowTrackerExtra/ShadowTrackerExtra/Saved/Logs"
"rm -rf /storage/emulated/0/Android/data/com.tencent.ig/files/UE4Game/ShadowTrackerExtra/ShadowTrackerExtra/Saved/GameErrorNoRecords"
"rm -rf /storage/emulated/0/Android/data/com.tencent.ig/files/UE4Game/ShadowTrackerExtra/ShadowTrackerExtra/Saved/Config"
"rm -rf /storage/emulated/0/Android/data/com.tencent.ig/files/UE4Game/ShadowTrackerExtra/ShadowTrackerExtra/Saved/Pandora"
"rm -rf /data/data/com.tencent.ig/app_appcache"
"rm -rf /data/data/com.tencent.ig/app_bugly"
"rm -rf /data/data/com.tencent.ig/app_crashrecord"
"rm -rf /data/data/com.tencent.ig/app_databases"
"rm -rf /data/data/com.tencent.ig/app_geolocation"
"rm -rf /storage/emulated/0/Android/data/com.tencent.ig/files/UE4Game/ShadowTrackerExtra/ShadowTrackerExtra/Saved/Logs"
"rm -rf /storage/emulated/0/Android/data/com.tencent.ig/files/UE4Game/ShadowTrackerExtra/ShadowTrackerExtra/Saved/GameErrorNoRecords"
"rm -rf /storage/emulated/0/Android/data/com.tencent.ig/files/UE4Game/ShadowTrackerExtra/ShadowTrackerExtra/Saved/Config"
"rm -rf /storage/emulated/0/Android/data/com.tencent.ig/files/UE4Game/ShadowTrackerExtra/ShadowTrackerExtra/Saved/Pandora"
"rm -rf /data/data/com.tencent.ig/app_appcache"
"rm -rf /data/data/com.tencent.ig/app_bugly"
"rm -rf /data/data/com.tencent.ig/app_crashrecord"
"rm -rf /data/data/com.tencent.ig/app_databases"
"rm -rf /data/data/com.tencent.ig/app_geolocation"
"rm -rf /storage/emulated/0/Android/data/com.tencent.ig/files/UE4Game/ShadowTrackerExtra/ShadowTrackerExtra/Saved/Logs"
"rm -rf /storage/emulated/0/Android/data/com.tencent.ig/files/UE4Game/ShadowTrackerExtra/ShadowTrackerExtra/Saved/GameErrorNoRecords"
"rm -rf /storage/emulated/0/Android/data/com.tencent.ig/files/UE4Game/ShadowTrackerExtra/ShadowTrackerExtra/Saved/Config"
"rm -rf /storage/emulated/0/Android/data/com.tencent.ig/files/UE4Game/ShadowTrackerExtra/ShadowTrackerExtra/Saved/Pandora"
"rm -rf /sdcard/.backups/com.tencent.ig/helpshift/database"
"rm -rf /sdcard/Android/data/com.tencent.ig/files/UE4Game/ShadowTrackerExtra/ShadowTrackerExtra/Saved/SaveGames/Match"
"rm -rf /sdcard/Android/data/com.tencent.ig/files/UE4Game/ShadowTrackerExtra/ShadowTrackerExtra/Saved/Logs"
"rm -rf /sdcard/Android/data/com.tencent.ig/files/UE4Game/ShadowTrackerExtra/ShadowTrackerExtra/Saved/Paks/filelist.json"
"rm -rf /sdcard/Android/data/com.tencent.ig/files/UE4Game/ShadowTrackerExtra/ShadowTrackerExtra/Saved/Paks/puffer_res.eifs"
"rm -rf /sdcard/Android/data/com.tencent.ig/files/UE4Game/ShadowTrackerExtra/ShadowTrackerExtra/Saved/Paks/apollo_reslist.flist"
"rm -rf /sdcard/Android/data/com.tencent.ig/files/UE4Game/ShadowTrackerExtra/ShadowTrackerExtra/Saved/Paks/puffer_temp"
"rm -rf /sdcard/Android/data/com.tencent.ig/files/UE4Game/ShadowTrackerExtra/ShadowTrackerExtra/Saved/RoleInfo/RoleInfo.json"
"rm -rf /sdcard/Android/data/com.tencent.ig/files/UE4Game/ShadowTrackerExtra/ShadowTrackerExtra/Saved/Paks/PufferFileList.json"
"rm -rf /sdcard/Android/data/com.tencent.ig/files/UE4Game/ShadowTrackerExtra/ShadowTrackerExtra/Saved/StatEventReportedFlag"
"rm -rf /sdcard/Android/data/com.tencent.ig/files/UE4Game/ShadowTrackerExtra/ShadowTrackerExtra/Saved/PufferTmpDir"
"rm -rf /sdcard/.backups"
"rm -rf /sdcard/Tencent"
"rm -rf /storage/emulated/0/Android/data/com.tencent.ig/cache"
"rm -rf /storage/emulated/0/Android/data/com.tencent.ig/files/tbslog"
"rm -rf /storage/emulated/0/Android/data/com.tencent.ig/files/ca-bundle.pem"
"rm -rf /storage/emulated/0/Android/data/com.tencent.ig/files/cacheFile.txt"
"rm -rf /storage/emulated/0/Android/data/com.tencent.ig/files/login-identifier.txt"
"rm -rf /storage/emulated/0/Android/data/com.tencent.ig/files/vmpcloudconfig.json"
"rm -rf /storage/emulated/0/.backups/com.tencent.ig/helpshift/database"
"rm -rf /storage/emulated/0/Android/data/com.tencent.ig/files/UE4Game/ShadowTrackerExtra/ShadowTrackerExtra/Saved/SaveGames/Match"
"rm -rf /storage/emulated/0/Android/data/com.tencent.ig/files/UE4Game/ShadowTrackerExtra/ShadowTrackerExtra/Saved/Logs"
"rm -rf /storage/emulated/0/Android/data/com.tencent.ig/files/UE4Game/ShadowTrackerExtra/ShadowTrackerExtra/Saved/Paks/filelist.json"
"rm -rf /storage/emulated/0/Android/data/com.tencent.ig/files/UE4Game/ShadowTrackerExtra/ShadowTrackerExtra/Saved/Paks/puffer_res.eifs"
"rm -rf /storage/emulated/0/Android/data/com.tencent.ig/files/UE4Game/ShadowTrackerExtra/ShadowTrackerExtra/Saved/Paks/apollo_reslist.flist"
"rm -rf /storage/emulated/0/Android/data/com.tencent.ig/files/UE4Game/ShadowTrackerExtra/ShadowTrackerExtra/Saved/Paks/puffer_temp"
"rm -rf /storage/emulated/0/Android/data/com.tencent.ig/files/UE4Game/ShadowTrackerExtra/ShadowTrackerExtra/Saved/RoleInfo/RoleInfo.json"
"rm -rf /storage/emulated/0/Android/data/com.tencent.ig/files/UE4Game/ShadowTrackerExtra/ShadowTrackerExtra/Saved/Paks/PufferFileList.json"
"rm -rf /storage/emulated/0/Android/data/com.tencent.ig/files/UE4Game/ShadowTrackerExtra/ShadowTrackerExtra/Saved/StatEventReportedFlag"
"rm -rf /storage/emulated/0/Android/data/com.tencent.ig/files/UE4Game/ShadowTrackerExtra/ShadowTrackerExtra/Saved/PufferTmpDir"
"rm -rf /storage/emulated/0/.backups"
"rm -rf /storage/emulated/0/Tencent"
"rm -rf /data/user/0/com.tencent.ig/cache"
"rm -rf /storage/emulated/0/Android/data/com.tencent.ig/files/UE4Game/ShadowTrackerExtra/ShadowTrackerExtra/Saved/Paks/game_patch_2.4.1.17122.pak"
"rm -rf /storage/emulated/0/Android/data/com.tencent.ig/files/UE4Game/ShadowTrackerExtra/ShadowTrackerExtra/Saved/Paks/game_patch_2.4.1.17123.pak"
"rm -rf /storage/emulated/0/Android/data/com.tencent.ig/files/UE4Game/ShadowTrackerExtra/ShadowTrackerExtra/Saved/Paks/game_patch_2.4.1.17124.pak"
"rm -rf /storage/emulated/0/Android/data/com.tencent.ig/files/UE4Game/ShadowTrackerExtra/ShadowTrackerExtra/Saved/Paks/game_patch_2.4.1.17125.pak");
clear = false;
}*/



if (Bypass10) {
//æ—è·¯

}






if (å…¨å±€ç¦»çº¿) {
MemoryPatch::createWithHex("libgcloud.so",0x42A168, "FF FF FF FF",4).Modify();
MemoryPatch::createWithHex("libgcloud.so",0x4A4618, "FF FF FF FF",4).Modify();
//å…¨å±€ç¦»çº¿ æ–­ç½‘ 
} else {
MemoryPatch::createWithHex("libgcloud.so",0x42A168, "26 35 13 13",4).Modify();
MemoryPatch::createWithHex("libgcloud.so",0x4A4618, "26 35 13 13",4).Modify();
//å…¨å±€ç¦»çº¿ æ¢å¤è”ç½‘
}



if (BypassLOGO) {

//å·¥å…·å†™åœ°å€
//Bypass();
}


//#include "MemoryTools (1).h"
//long int get_module_base(int pid,const char*module_name)



if (å¤§å…æ—è·¯) {


}





/*if(ç¨³å®šé™¤é›¾){
å†™å…¥Dç±»(UE4 + 0x6DF5FB0,706675684);
}*/

if(ç¨³å®šåŠ é€Ÿå¼€){
å†™å…¥Dç±»(UE4 + 0x7D68B40,505453825);
}

if(ç¨³å®šåŠ é€Ÿå…³){
å†™å…¥Dç±»(UE4 + 0x7D68B40,505453824);
}

if(æ— å){
å†™å…¥Dç±»(UE4 + 0x4C451A4,449318186);
}
           
if(é˜²æŠ–){
å†™å…¥Dç±»(UE4 + 0x57E2650,1409287170);
å†™å…¥Dç±»(UE4 + 0x7C5A398,449318186);
}

if(èšç‚¹){
å†™å…¥Dç±»(UE4 +0x4C42B2C,505425152);                
}

if(ç¬å‡»){
å†™å…¥Dç±»(UE4 + 0x7DA4058,506015752);
}

if(è‡ªç„){
å†™å…¥Fç±»(UE4 + 0x3dbba6c,0);
}

/*if(é™¤è‰){
å†™å…¥Dç±»(UE4 + 0x3dad878,0);
}   

if(é™¤æ ‘){
å†™å…¥Fç±»(UE4 + 0x56ac6c8,-1.86389771e-20);
}

if(é»‘å¤©){
å†™å…¥Dç±»(UE4 + 0x576cd10,-1222130000);
}

if(å¹³æ¿è§†è§’123){
å†™å…¥Fç±»(UE4 + 0x5483064,å¹³æ¿è§†è§’è°ƒæ•´);
}

if(é«˜ä¼¤å®³){
å†™å…¥Fç±»(UE4 + 0x58fe1f0,10);
}

if(é»‘ä½“){
å†™å…¥Fç±»(UE4 + 0x4649548,é»‘ä½“é¢œè‰²);
}*/






if (Config.PlayerESP.ActiveEsp) {
		auto Actors = getActors();
		int totalEnemies = 0, totalBots = 0, oozing = 0;
		ASTExtraPlayerCharacter *localPlayer = 0;
		ASTExtraPlayerController *localController = 0;
		
		std::string sFPS = "\n\n\n\nFPS:";
		sFPS += std::to_string(fps.get());
        draw->AddText({((float)density / 10.0f), 40}, IM_COL32(255, 255, 255, 255), sFPS.c_str());
		for (int i = 0; i < Actors.size(); i++)
		{
			auto Actor = Actors[i];
			if (isObjectInvalid(Actor))
				continue;
			if (Actor->IsA(ASTExtraPlayerController::StaticClass()))
			{
				localController = (ASTExtraPlayerController *)Actor;
				break;
			}
		}
		if (localController)
		{
			for (int i = 0; i < Actors.size(); i++)
			{
				auto Actor = Actors[i];
				if (isObjectInvalid(Actor))
					continue;
				if (Actor->IsA(ASTExtraPlayerCharacter::StaticClass()))
				{
					if (((ASTExtraPlayerCharacter *)Actor)->PlayerKey ==
						localController->PlayerKey)
					{
						localPlayer = (ASTExtraPlayerCharacter *)Actor;
						break;
					}
				}
			}
			if (localPlayer)
			{
				if (localPlayer->PartHitComponent)
				{
					auto ConfigCollisionDistSqAngles = localPlayer->PartHitComponent->ConfigCollisionDistSqAngles;
					for (int j = 0; j < ConfigCollisionDistSqAngles.Num(); j++)
					{
						ConfigCollisionDistSqAngles[j].Angle = 90.0f;
					}
					localPlayer->PartHitComponent->ConfigCollisionDistSqAngles = ConfigCollisionDistSqAngles;
				}
				//===================== åŸºå€ SDK BASE ====================//
			

if (Config.HighRisk.Recoil || Config.HighRisk.Shake || Config.HighRisk.Prone || Config.HighRisk.HitEffect || Config.HighRisk.Instant || Config.HighRisk.Cross || Config.HighRisk.Less) {
                auto WeaponManagerComponent = localPlayer->WeaponManagerComponent;
                if (WeaponManagerComponent) {
                    auto Slot = WeaponManagerComponent->GetCurrentUsingPropSlot();
                    if ((int) Slot.GetValue() >= 1 && (int) Slot.GetValue() <= 3) {
                        auto CurrentWeaponReplicated = (ASTExtraShootWeapon *) WeaponManagerComponent->CurrentWeaponReplicated;
                        if (CurrentWeaponReplicated) {
                            auto ShootWeaponEntityComp = CurrentWeaponReplicated->ShootWeaponEntityComp;
                            auto ShootWeaponEffectComp = CurrentWeaponReplicated->ShootWeaponEffectComp;
                            if (ShootWeaponEntityComp && ShootWeaponEffectComp) {
                                if (Config.HighRisk.Recoil) {
                                    ShootWeaponEntityComp->AccessoriesVRecoilFactor = 0.0f;
                                    ShootWeaponEntityComp->AccessoriesHRecoilFactor = 0.0f;
                                    ShootWeaponEntityComp->AccessoriesRecoveryFactor = 0.0f;

                                    ShootWeaponEntityComp->RecoilKickADS = 0.0f;
                                }
                               /* if (Config.HighRisk.Less) {
                                //> 0.100 = safe
                                    ShootWeaponEntityComp->AccessoriesVRecoilFactor = Config.Less;
                                    ShootWeaponEntityComp->AccessoriesHRecoilFactor = Config.Less;
                                    ShootWeaponEntityComp->AccessoriesRecoveryFactor = Config.Less;
                                    }*/
                                    
                                    if (Config.HighRisk.Shake) {
                                    ShootWeaponEffectComp->CameraShakeInnerRadius = 0.0f;
                                    ShootWeaponEffectComp->CameraShakeOuterRadius = 0.0f;
                                    ShootWeaponEffectComp->CameraShakFalloff = 0.0f;
                                }

                   
                                if (Config.HighRisk.Cross) {
                                                          ShootWeaponEntityComp->GameDeviationFactor = 0.0f;
                                    }

                                if (Config.HighRisk.HitEffect) {
                                       ShootWeaponEntityComp->ExtraHitPerformScale = 50.0f;
                                }
								 if (Config.HighRisk.Instant) {
                               
    ShootWeaponEntityComp->BulletFireSpeed = 1000000.0f;
 
                                }
                          
                            }
                        }
                    }
                }
            }






//=====å­è¿½ç®—æ³•   NIKE IMGUI 3.0






///360Â° å­å¼¹è¿½è¸ª
//è§†è§’å­è¿½
//è‡ªç„ç®—æ³•3.0
if (Config.AimBot.å¼€å¯è‡ªç„) {
if (Config.AimBot.AINBOT == AIMBOT::SJ) {
                                                    
         ASTExtraPlayerCharacter *Target = è‡ªç„360åº¦();     
         long PlayerAimLineColor = IM_COL32(254, 0, 0, 255);
        if (Target) {
FVector HEAD = Target->GetBonePos("Head", {});
ImVec2 HEADSC;
if (W2S(HEAD, (FVector2D *)&HEADSC)) {
draw->AddLine({(float) glWidth / 2,  (float) (glHeight / 2)}, HEADSC, PlayerAimLineColor, 1.0f);
}
   
        
                        }
                    if (Target) {
                        bool triggerOk = false;
                        if (Config.AimBot.Trigger != EAimTrigger::None) {
                            if (Config.AimBot.Trigger == EAimTrigger::Shooting) {
                                triggerOk = localPlayer->bIsWeaponFiring;
                            } else if (Config.AimBot.Trigger == EAimTrigger::Scoping) {
                                triggerOk = localPlayer->bIsGunADS;
                            } else if (Config.AimBot.Trigger == EAimTrigger::Both) {
                                triggerOk = localPlayer->bIsWeaponFiring && localPlayer->bIsGunADS;
                            } else if (Config.AimBot.Trigger == EAimTrigger::Any) {
                                triggerOk = localPlayer->bIsWeaponFiring || localPlayer->bIsGunADS;
                            }
                        } else triggerOk = true;
                        if (triggerOk) {
                            FVector targetAimPos = Target->GetBonePos("Head", {});
                            if (Config.AimBot.Target == EAimTarget::Chest) {
                                targetAimPos.Z -= 25.0f;
                            }
                            if (Config.AimBot.Target == EAimTarget::JJ) {
                                targetAimPos.Z -= 65.0f;
                            }

                            auto WeaponManagerComponent = g_LocalPlayer->WeaponManagerComponent;
                                        if (WeaponManagerComponent) {
                                            auto propSlot = WeaponManagerComponent->GetCurrentUsingPropSlot();
                                            if ((int)propSlot.GetValue() >= 1 && (int)propSlot.GetValue() <= 3) {
                                                auto CurrentWeaponReplicated = (ASTExtraShootWeapon *)WeaponManagerComponent->CurrentWeaponReplicated;
                                                if (CurrentWeaponReplicated) {
                                                    auto ShootWeaponComponent = CurrentWeaponReplicated->ShootWeaponComponent;
                                                    if (ShootWeaponComponent) {
                                                        UShootWeaponEntity * ShootWeaponEntityComponent = ShootWeaponComponent->ShootWeaponEntityComponent;
                                                        if (ShootWeaponEntityComponent) {
                                                    
                                                            ASTExtraVehicleBase * CurrentVehicle = Target->CurrentVehicle;
                                                            if (CurrentVehicle) {
                                                                FVector LinearVelocity = CurrentVehicle->ReplicatedMovement.LinearVelocity;
                                                                float dist = g_LocalPlayer->GetDistanceTo(Target);
                                                                auto timeToTravel = dist / ShootWeaponEntityComponent->BulletFireSpeed;
                                                                targetAimPos = UKismetMathLibrary::Add_VectorVector(targetAimPos, UKismetMathLibrary::Multiply_VectorFloat(LinearVelocity, timeToTravel));
                                                            } else {
                                                                FVector Velocity = Target->GetVelocity();
                                                                float dist = g_LocalPlayer->GetDistanceTo(Target);
                                                                auto timeToTravel = dist / ShootWeaponEntityComponent->BulletFireSpeed;
                                                                targetAimPos = UKismetMathLibrary::Add_VectorVector(targetAimPos, UKismetMathLibrary::Multiply_VectorFloat(Velocity, timeToTravel));
                                                            }
                                                            
                                                            if (g_LocalPlayer->bIsGunADS) {
                                                        if (g_LocalPlayer->bIsWeaponFiring) {
                                                            float dist = g_LocalPlayer->GetDistanceTo(Target) / 100.f;                                                                                 
                                                            
                                                        }  
                                                    }
                                                                                                        if (g_LocalController) {
                                            auto PlayerCameraManage = g_LocalController->PlayerCameraManager;
                                            if (PlayerCameraManage) {                                                                                                                                          
                                                FVector currViewAngle = PlayerCameraManage->CameraCache.POV.Location;                                                
                                                auto aimRotation = ToRotator(currViewAngle, targetAimPos);  
                                                g_LocalController->PlayerCameraManager->CameraCache.POV.Rotation = aimRotation;          
                                               }
                                               }
                                               }
                                                }
                                                }
                                                }
                                                }
                                                }
                                                }
                                                }}
                //è‡ªç„ç®—æ³•6.0
                if (Config.AimBot.å¼€å¯è‡ªç„) {
                            if (Config.AimBot.AINBOT == AIMBOT::NC) {
ASTExtraPlayerCharacter *Target = å†…å­˜è‡ªç„();
					if (Target)
					{
						bool triggerOk = false;						
							if (Config.AimBot.Trigger == EAimTrigger::Shooting)
							{
								triggerOk = g_LocalPlayer->bIsWeaponFiring;
							}
							else if (Config.AimBot.Trigger == EAimTrigger::Scoping)
							{
								triggerOk = g_LocalPlayer->bIsGunADS;
							}
							else if (Config.AimBot.Trigger == EAimTrigger::Both)
							{
								triggerOk = g_LocalPlayer->bIsWeaponFiring && g_LocalPlayer->bIsGunADS;
							}
							else if (Config.AimBot.Trigger == EAimTrigger::Any)
							{
								triggerOk = g_LocalPlayer->bIsWeaponFiring || g_LocalPlayer->bIsGunADS;
							}
						
						else
							triggerOk = true;
						if (triggerOk)
						{
						FVector targetAimPos = Target->GetBonePos("Head", {});
							if (Config.AimBot.Target == EAimTarget::Chest)
							{
								targetAimPos.Y -= 1.228f;
								targetAimPos.Z -= 25.0f;
							//	targetAimPos.X -= Config.Skill4;
							}
										
										auto WeaponManagerComponent = localPlayer->WeaponManagerComponent;
                                if (WeaponManagerComponent) {
                                    auto propSlot = WeaponManagerComponent->GetCurrentUsingPropSlot();
                                    if ((int) propSlot.GetValue() >= 1 && (int) propSlot.GetValue() <= 3) {
                                        auto CurrentWeaponReplicated = (ASTExtraShootWeapon *) WeaponManagerComponent->CurrentWeaponReplicated;
                                        if (CurrentWeaponReplicated) {
                                            auto ShootWeaponComponent = CurrentWeaponReplicated->ShootWeaponComponent;
                                            if (ShootWeaponComponent) {
                                                UShootWeaponEntity *ShootWeaponEntityComponent = ShootWeaponComponent->ShootWeaponEntityComponent;
                                                if (ShootWeaponEntityComponent) {
                                                    ASTExtraVehicleBase *CurrentVehicle = Target->CurrentVehicle;
                                                    if (CurrentVehicle) {
                                                        FVector LinearVelocity = CurrentVehicle->ReplicatedMovement.LinearVelocity;

                                                        float dist = localPlayer->GetDistanceTo(Target);
                                                        auto timeToTravel = dist / ShootWeaponEntityComponent->BulletFireSpeed;

                                                        targetAimPos = UKismetMathLibrary::Add_VectorVector(targetAimPos, UKismetMathLibrary::Multiply_VectorFloat(LinearVelocity, timeToTravel));
                                                    } else {
                                                        FVector Velocity = Target->GetVelocity();

                                                        float dist = localPlayer->GetDistanceTo(Target);
                                                        auto timeToTravel = dist / ShootWeaponEntityComponent->BulletFireSpeed;

                                                        targetAimPos = UKismetMathLibrary::Add_VectorVector(targetAimPos, UKismetMathLibrary::Multiply_VectorFloat(Velocity, timeToTravel));
                                                    
													
													/*targetAimPos.Z += Velocity.Z * timeToTravel + 0.5 * Config.Line * timeToTravel * timeToTravel;    */
												}
												
												
                            if (g_LocalPlayer->bIsGunADS) {
                               if (g_LocalPlayer->bIsWeaponFiring) {
                                float dist = g_LocalPlayer->GetDistanceTo(Target) / 100.f;                                                                                 
                                targetAimPos.Z -= dist * 1.25f;        
                                
                                                          
                                }  
                             }
                           
                            if (è‡ªç„æ¥å£ == 0) {
localController->ControlRotation =ToRotator(localController->PlayerCameraManager->CameraCache.POV.Location,targetAimPos);
} else if (è‡ªç„æ¥å£ == 1) {
FRotator fAimRotation = UKismetMathLibrary::Conv_VectorToRotator(UKismetMathLibrary::Subtract_VectorVector(targetAimPos, localController->PlayerCameraManager->CameraCache.POV.Location));
localController->ControlRotation = fAimRotation;
}
                                        }
									}
								}
							}
						}
					}
				}
                }}


//è‡ªåŠ¨ç„å‡†5.1

                            if (Config.AimBot.å¼€å¯è‡ªç„) {
                            if (Config.AimBot.AINBOT == AIMBOT::PH) {
                    
                
                    ASTExtraPlayerCharacter *Target = å¹³æ»‘è‡ªç„();
                    
                  
                    long PlayerAimLineColor = IM_COL32(254, 0, 0, 255);
                    
                    
                    

                    if (Target) {
                        FVector HEAD = Target->GetBonePos("Head", {});
                        
                        ImVec2 headPosSC;
                        if (W2S(HEAD, (FVector2D *)&headPosSC)) {
                    
                           
                          draw->AddLine({(float) glWidth / 2,  (float) (glHeight / 2)}, headPosSC,
                                              PlayerAimLineColor, 1.0f);
                            
                        }
                        
if (Config.è‡ªåŠ¨Z){
float AimDis= localPlayer->GetDistanceTo(Target) / 100.f;

if(AimDis > 0.0f && AimDis <= 28.0f){
AimYQ = Aim10;
}
if(AimDis > 28.0f && AimDis <= 50.0f){
AimYQ = Aim50;
}
if(AimDis > 50.0f && AimDis <= 100.0f){
AimYQ = Aim100;
}
if(AimDis > 100.0f && AimDis <= 150.0f){
AimYQ = Aim150;
}
if(AimDis > 150.0f && AimDis <= 200.0f){
AimYQ = Aim200;
}
if(AimDis > 200.0f && AimDis <= 250.0f){
AimYQ = Aim250;
}
if(AimDis > 250.0f && AimDis <= 300.0f){
AimYQ = Aim300;
}}
                     
                        bool triggerOk = false;
                        if (Config.AimBot.Trigger != EAimTrigger::None) {
                            if (Config.AimBot.Trigger == EAimTrigger::Shooting) {
                                triggerOk = localPlayer->bIsWeaponFiring;
                            } else if (Config.AimBot.Trigger == EAimTrigger::Scoping) {
                                triggerOk = localPlayer->bIsGunADS;
                            } else if (Config.AimBot.Trigger == EAimTrigger::Both) {
                                triggerOk = localPlayer->bIsWeaponFiring && localPlayer->bIsGunADS;
                            } else if (Config.AimBot.Trigger == EAimTrigger::Any) {
                                triggerOk = localPlayer->bIsWeaponFiring || localPlayer->bIsGunADS;
                            }
                        } else triggerOk = true;
                        if (triggerOk) {




FVector targetAimPos = Target->GetBonePos("Head", {});

if (Config.AimBot.Target == EAimTarget::Chest) {
targetAimPos.Z -= 25.0f;
}
if (Config.AimBot.Target == EAimTarget::JJ) {
targetAimPos.Z -= 65.0f;
}
if (Config.è‡ªåŠ¨Z){
if (localPlayer->bIsWeaponFiring)
targetAimPos.Z -= AimYQ;
}






auto WeaponManagerComponent = localPlayer->WeaponManagerComponent;
if (WeaponManagerComponent) {
auto propSlot = WeaponManagerComponent->GetCurrentUsingPropSlot();
if ((int) propSlot.GetValue() >= 1 &&
(int) propSlot.GetValue() <= 3) {
auto CurrentWeaponReplicated = (ASTExtraShootWeapon *) WeaponManagerComponent->CurrentWeaponReplicated;
if (CurrentWeaponReplicated) {
auto ShootWeaponComponent = CurrentWeaponReplicated->ShootWeaponComponent;
if (ShootWeaponComponent) {
UShootWeaponEntity *ShootWeaponEntityComponent = ShootWeaponComponent->ShootWeaponEntityComponent;
if (ShootWeaponEntityComponent) {
ASTExtraVehicleBase *CurrentVehicle = Target->CurrentVehicle;
if (CurrentVehicle) {
FVector LinearVelocity = CurrentVehicle->ReplicatedMovement.LinearVelocity;
float dist = localPlayer->GetDistanceTo(Target);
auto timeToTravel = dist / ShootWeaponEntityComponent->BulletFireSpeed;
targetAimPos = UKismetMathLibrary::Add_VectorVector(targetAimPos, UKismetMathLibrary::Multiply_VectorFloat(LinearVelocity, timeToTravel));
} else {
FVector Velocity = Target->GetVelocity();
float dist = localPlayer->GetDistanceTo(Target);
auto timeToTravel = dist / ShootWeaponEntityComponent->BulletFireSpeed;
targetAimPos = UKismetMathLibrary::Add_VectorVector(targetAimPos, UKismetMathLibrary::Multiply_VectorFloat(Velocity, timeToTravel));
}
if (è‡ªç„æ¥å£ == 0) {
localController->ControlRotation =ToRotator(localController->PlayerCameraManager->CameraCache.POV.Location,targetAimPos);
} else if (è‡ªç„æ¥å£ == 1) {
FRotator fAimRotation = UKismetMathLibrary::Conv_VectorToRotator(UKismetMathLibrary::Subtract_VectorVector(targetAimPos, localController->PlayerCameraManager->CameraCache.POV.Location));
localController->ControlRotation = fAimRotation;
}
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                  
                }}


//è‡ªç„ç®—æ³•5.2
                            if (Config.AimBot.å¼€å¯è‡ªç„) {
                            if (Config.AimBot.AINBOT == AIMBOT::SJZM) {
                    
                
                    ASTExtraPlayerCharacter *Target = æ¼æ‰“è‡ªç„();
                    
                  
                    long PlayerAimLineColor = IM_COL32(254, 0, 0, 255);
                    
                    
                    

                    if (Target) {
                        FVector HEAD = Target->GetBonePos("Head", {});
                        
                        ImVec2 headPosSC;
                        if (W2S(HEAD, (FVector2D *)&headPosSC)) {
                    
                           
                          draw->AddLine({(float) glWidth / 2,  (float) (glHeight / 2)}, headPosSC,
                                              PlayerAimLineColor, 1.0f);
                            
                        }
                     
                        bool triggerOk = false;
                        if (Config.AimBot.Trigger != EAimTrigger::None) {
                            if (Config.AimBot.Trigger == EAimTrigger::Shooting) {
                                triggerOk = localPlayer->bIsWeaponFiring;
                            } else if (Config.AimBot.Trigger == EAimTrigger::Scoping) {
                                triggerOk = localPlayer->bIsGunADS;
                            } else if (Config.AimBot.Trigger == EAimTrigger::Both) {
                                triggerOk = localPlayer->bIsWeaponFiring && localPlayer->bIsGunADS;
                            } else if (Config.AimBot.Trigger == EAimTrigger::Any) {
                                triggerOk = localPlayer->bIsWeaponFiring || localPlayer->bIsGunADS;
                            }
                        } else triggerOk = true;
                        if (triggerOk) {
                              /*
                       å…¶ä½™æ¬¡åº:  
                         1      2     3      4
                         å¤´    ç›†éª¨   å·¦æ‰‹   å³æ‰‹
                         å·¦è„š  å³è„š   
                          5     6
                         7     8       9    10
                       å·¦ä¸Šè‡‚ å·¦å°è‡‚  å·¦å¤§è…¿ å·¦å°è…¿ 
                       å³ä¸Šè‡‚ å³å°è‡‚  å³å¤§è…¿ å³å°è…¿ 
                         11    12     13    14
                        */
                      FVector targetAimPos;
                     
                        if(Random == 1)
                        {
                             targetAimPos = Target->GetBonePos("Head", {});
                        }else if(Random == 2){
//                             targetAimPos = Target->GetBonePos("pelvis", {});
                        }else if(Random == 3){
                             targetAimPos = Target->GetBonePos("hand_l", {});
                        }else if(Random == 4){
                             targetAimPos = Target->GetBonePos("hand_r", {});
                        }else if(Random == 5){
                             targetAimPos = Target->GetBonePos("foot_l", {});
                        }else if(Random == 6){
                             targetAimPos = Target->GetBonePos("foot_r", {});
                        }else if(Random == 7){
                             targetAimPos = Target->GetBonePos("upper_l", {});
                        }else if(Random == 8){
                             targetAimPos = Target->GetBonePos("lowerarm_r", {});
                        }else if(Random == 9){
                             targetAimPos = Target->GetBonePos("thigh_l", {});
                        }else if(Random == 10){
                             targetAimPos = Target->GetBonePos("calf_l", {});
                        }else if(Random == 11){
                             targetAimPos = Target->GetBonePos("upper_r", {});
                        }else if(Random == 12){
                             targetAimPos = Target->GetBonePos("lowerarm_r", {});
                        }else if(Random == 13){
                             targetAimPos = Target->GetBonePos("thigh_r", {});
                        }else if(Random == 14){
                             targetAimPos = Target->GetBonePos("calf_r", {});
                        }
                        if (localPlayer->bIsWeaponFiring) {
                        Random = Random + 1;
                        if (Random == 14) {
                        Random = 1;
                        }}
                           
                          
                           
                          
              
auto WeaponManagerComponent = localPlayer->WeaponManagerComponent;
if (WeaponManagerComponent) {
auto propSlot = WeaponManagerComponent->GetCurrentUsingPropSlot();
if ((int) propSlot.GetValue() >= 1 &&
(int) propSlot.GetValue() <= 3) {
auto CurrentWeaponReplicated = (ASTExtraShootWeapon *) WeaponManagerComponent->CurrentWeaponReplicated;
if (CurrentWeaponReplicated) {
auto ShootWeaponComponent = CurrentWeaponReplicated->ShootWeaponComponent;
if (ShootWeaponComponent) {
UShootWeaponEntity *ShootWeaponEntityComponent = ShootWeaponComponent->ShootWeaponEntityComponent;
if (ShootWeaponEntityComponent) {
ASTExtraVehicleBase *CurrentVehicle = Target->CurrentVehicle;
if (CurrentVehicle) {
FVector LinearVelocity = CurrentVehicle->ReplicatedMovement.LinearVelocity;
float dist = localPlayer->GetDistanceTo(Target);
auto timeToTravel = dist / ShootWeaponEntityComponent->BulletFireSpeed;
targetAimPos = UKismetMathLibrary::Add_VectorVector(targetAimPos, UKismetMathLibrary::Multiply_VectorFloat(LinearVelocity, timeToTravel));
} else {
FVector Velocity = Target->GetVelocity();
float dist = localPlayer->GetDistanceTo(Target);
auto timeToTravel = dist / ShootWeaponEntityComponent->BulletFireSpeed;
targetAimPos = UKismetMathLibrary::Add_VectorVector(targetAimPos, UKismetMathLibrary::Multiply_VectorFloat(Velocity, timeToTravel));
}
if (è‡ªç„æ¥å£ == 0) {
localController->ControlRotation =ToRotator(localController->PlayerCameraManager->CameraCache.POV.Location,targetAimPos);
} else if (è‡ªç„æ¥å£ == 1) {
FRotator fAimRotation = UKismetMathLibrary::Conv_VectorToRotator(UKismetMathLibrary::Subtract_VectorVector(targetAimPos, localController->PlayerCameraManager->CameraCache.POV.Location));
localController->ControlRotation = fAimRotation;
}
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                  
                }}

//è‡ªç„ç®—æ³•5.0
                            if (Config.AimBot.å¼€å¯è‡ªç„) {
                            if (Config.AimBot.AINBOT == AIMBOT::LD) {
                    
                
                    ASTExtraPlayerCharacter *Target = æ¼æ‰“è‡ªç„();
                    
                  
                    long PlayerAimLineColor = IM_COL32(254, 0, 0, 255);
                    
                    
                    

                    if (Target) {
                        FVector HEAD = Target->GetBonePos("Head", {});
                        
                        ImVec2 headPosSC;
                        if (W2S(HEAD, (FVector2D *)&headPosSC)) {
                    
                           
                          draw->AddLine({(float) glWidth / 2,  (float) (glHeight / 2)}, headPosSC,
                                              PlayerAimLineColor, 1.0f);
                            
                        }
                     
                        bool triggerOk = false;
                        if (Config.AimBot.Trigger != EAimTrigger::None) {
                            if (Config.AimBot.Trigger == EAimTrigger::Shooting) {
                                triggerOk = localPlayer->bIsWeaponFiring;
                            } else if (Config.AimBot.Trigger == EAimTrigger::Scoping) {
                                triggerOk = localPlayer->bIsGunADS;
                            } else if (Config.AimBot.Trigger == EAimTrigger::Both) {
                                triggerOk = localPlayer->bIsWeaponFiring && localPlayer->bIsGunADS;
                            } else if (Config.AimBot.Trigger == EAimTrigger::Any) {
                                triggerOk = localPlayer->bIsWeaponFiring || localPlayer->bIsGunADS;
                            }
                        } else triggerOk = true;
                        if (triggerOk) {
                              /*
                       å…¶ä½™æ¬¡åº:  
                         1      2     3      4
                         å¤´    ç›†éª¨   å·¦æ‰‹   å³æ‰‹
                         å·¦è„š  å³è„š   
                          5     6
                         7     8       9    10
                       å·¦ä¸Šè‡‚ å·¦å°è‡‚  å·¦å¤§è…¿ å·¦å°è…¿ 
                       å³ä¸Šè‡‚ å³å°è‡‚  å³å¤§è…¿ å³å°è…¿ 
                         11    12     13    14
                        */
                      FVector targetAimPos;
                     
                        if(Corepriority == 1)
                        {
                             targetAimPos = Target->GetBonePos("Head", {});
                        }else if(Corepriority == 2){
//                             targetAimPos = Target->GetBonePos("pelvis", {});
                        }else if(Corepriority == 3){
                             targetAimPos = Target->GetBonePos("hand_l", {});
                        }else if(Corepriority == 4){
                             targetAimPos = Target->GetBonePos("hand_r", {});
                        }else if(Corepriority == 5){
                             targetAimPos = Target->GetBonePos("foot_l", {});
                        }else if(Corepriority == 6){
                             targetAimPos = Target->GetBonePos("foot_r", {});
                        }else if(Corepriority == 7){
                             targetAimPos = Target->GetBonePos("upper_l", {});
                        }else if(Corepriority == 8){
                             targetAimPos = Target->GetBonePos("lowerarm_r", {});
                        }else if(Corepriority == 9){
                             targetAimPos = Target->GetBonePos("thigh_l", {});
                        }else if(Corepriority == 10){
                             targetAimPos = Target->GetBonePos("calf_l", {});
                        }else if(Corepriority == 11){
                             targetAimPos = Target->GetBonePos("upper_r", {});
                        }else if(Corepriority == 12){
                             targetAimPos = Target->GetBonePos("lowerarm_r", {});
                        }else if(Corepriority == 13){
                             targetAimPos = Target->GetBonePos("thigh_r", {});
                        }else if(Corepriority == 14){
                             targetAimPos = Target->GetBonePos("calf_r", {});
                        }
                        
                           
                          
                           
                          
              
auto WeaponManagerComponent = localPlayer->WeaponManagerComponent;
if (WeaponManagerComponent) {
auto propSlot = WeaponManagerComponent->GetCurrentUsingPropSlot();
if ((int) propSlot.GetValue() >= 1 &&
(int) propSlot.GetValue() <= 3) {
auto CurrentWeaponReplicated = (ASTExtraShootWeapon *) WeaponManagerComponent->CurrentWeaponReplicated;
if (CurrentWeaponReplicated) {
auto ShootWeaponComponent = CurrentWeaponReplicated->ShootWeaponComponent;
if (ShootWeaponComponent) {
UShootWeaponEntity *ShootWeaponEntityComponent = ShootWeaponComponent->ShootWeaponEntityComponent;
if (ShootWeaponEntityComponent) {
ASTExtraVehicleBase *CurrentVehicle = Target->CurrentVehicle;
if (CurrentVehicle) {
FVector LinearVelocity = CurrentVehicle->ReplicatedMovement.LinearVelocity;
float dist = localPlayer->GetDistanceTo(Target);
auto timeToTravel = dist / ShootWeaponEntityComponent->BulletFireSpeed;
targetAimPos = UKismetMathLibrary::Add_VectorVector(targetAimPos, UKismetMathLibrary::Multiply_VectorFloat(LinearVelocity, timeToTravel));
} else {
FVector Velocity = Target->GetVelocity();
float dist = localPlayer->GetDistanceTo(Target);
auto timeToTravel = dist / ShootWeaponEntityComponent->BulletFireSpeed;
targetAimPos = UKismetMathLibrary::Add_VectorVector(targetAimPos, UKismetMathLibrary::Multiply_VectorFloat(Velocity, timeToTravel));
}

if (è‡ªç„æ¥å£ == 0) {
localController->ControlRotation =ToRotator(localController->PlayerCameraManager->CameraCache.POV.Location,targetAimPos);
} else if (è‡ªç„æ¥å£ == 1) {
FRotator fAimRotation = UKismetMathLibrary::Conv_VectorToRotator(UKismetMathLibrary::Subtract_VectorVector(targetAimPos, localController->PlayerCameraManager->CameraCache.POV.Location));
localController->ControlRotation = fAimRotation;
}
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                  
                }}



//è‡ªç„ç®—æ³•2.0

                                if (Config.AimBot.å¼€å¯è‡ªç„) {
								if (Config.AimBot.AINBOT == AIMBOT::ZX) {
ASTExtraPlayerCharacter *Target = GetTargetForAimBot();

long PlayerAimLineColor = IM_COL32(254, 0, 0, 255);

if (Target) {
FVector HEAD = Target->GetBonePos("Head", {});
ImVec2 HEADSC;
if (W2S(HEAD, (FVector2D *)&HEADSC)) {
draw->AddLine({(float) glWidth / 2,  (float) (glHeight / 2)}, HEADSC, PlayerAimLineColor, 1.0f);
}

if (Config.è‡ªåŠ¨Z){
float AimDis= localPlayer->GetDistanceTo(Target) / 100.f;

if(AimDis > 0.0f && AimDis <= 28.0f){
AimYQ = Aim10;
}
if(AimDis > 28.0f && AimDis <= 50.0f){
AimYQ = Aim50;
}
if(AimDis > 50.0f && AimDis <= 100.0f){
AimYQ = Aim100;
}
if(AimDis > 100.0f && AimDis <= 150.0f){
AimYQ = Aim150;
}
if(AimDis > 150.0f && AimDis <= 200.0f){
AimYQ = Aim200;
}
if(AimDis > 200.0f && AimDis <= 250.0f){
AimYQ = Aim250;
}
if(AimDis > 250.0f && AimDis <= 300.0f){
AimYQ = Aim300;
}}


bool triggerOk = false;
if (Config.AimBot.Trigger != EAimTrigger::None) {
if (Config.AimBot.Trigger == EAimTrigger::Shooting) {
triggerOk = localPlayer->bIsWeaponFiring;
} else if (Config.AimBot.Trigger == EAimTrigger::Scoping) {
triggerOk = localPlayer->bIsGunADS;
} else if (Config.AimBot.Trigger == EAimTrigger::Both) {
triggerOk = localPlayer->bIsWeaponFiring && localPlayer->bIsGunADS;
} else if (Config.AimBot.Trigger == EAimTrigger::Any) {
triggerOk = localPlayer->bIsWeaponFiring || localPlayer->bIsGunADS;
}
} else triggerOk = true;
if (triggerOk) {
FVector targetAimPos = Target->GetBonePos("Head", {});

if (Config.AimBot.Target == EAimTarget::Chest) {
targetAimPos.Z -= 25.0f;
}
if (Config.AimBot.Target == EAimTarget::JJ) {
                                targetAimPos.Z -= 65.0f;
                            }
if (Config.è‡ªåŠ¨Z){
if (localPlayer->bIsWeaponFiring)
targetAimPos.Z -= AimYQ;
}


auto WeaponManagerComponent = localPlayer->WeaponManagerComponent;
if (WeaponManagerComponent) {
auto propSlot = WeaponManagerComponent->GetCurrentUsingPropSlot();
if ((int) propSlot.GetValue() >= 1 &&
(int) propSlot.GetValue() <= 3) {
auto CurrentWeaponReplicated = (ASTExtraShootWeapon *) WeaponManagerComponent->CurrentWeaponReplicated;
if (CurrentWeaponReplicated) {
auto ShootWeaponComponent = CurrentWeaponReplicated->ShootWeaponComponent;
if (ShootWeaponComponent) {
    UShootWeaponEntity *ShootWeaponEntityComponent = ShootWeaponComponent->ShootWeaponEntityComponent;
    if (ShootWeaponEntityComponent) {
				
                    ASTExtraVehicleBase *CurrentVehicle = Target->CurrentVehicle;
                    if (CurrentVehicle) {
                        FVector LinearVelocity = CurrentVehicle->ReplicatedMovement.LinearVelocity;

                        float dist = g_LocalPlayer->GetDistanceTo(Target);
                        auto timeToTravel = dist / ShootWeaponEntityComponent->BulletFireSpeed;

                        targetAimPos = UKismetMathLibrary::Add_VectorVector(targetAimPos, UKismetMathLibrary::Multiply_VectorFloat(LinearVelocity, timeToTravel));
                    } else {
                        FVector Velocity = Target->GetVelocity();

                        float dist = g_LocalPlayer->GetDistanceTo(Target);
                        auto timeToTravel = dist / ShootWeaponEntityComponent->BulletFireSpeed;

                        targetAimPos = UKismetMathLibrary::Add_VectorVector(targetAimPos, UKismetMathLibrary::Multiply_VectorFloat(Velocity, timeToTravel));
                    }
				



        if (è‡ªç„æ¥å£ == 0) {
localController->ControlRotation =ToRotator(localController->PlayerCameraManager->CameraCache.POV.Location,targetAimPos);
} else if (è‡ªç„æ¥å£ == 1) {
FRotator fAimRotation = UKismetMathLibrary::Conv_VectorToRotator(UKismetMathLibrary::Subtract_VectorVector(targetAimPos, localController->PlayerCameraManager->CameraCache.POV.Location));
localController->ControlRotation = fAimRotation;
}
    }
}
}
}
}

}
}

}}





//è‡ªç„ç®—æ³•1.0

if (Config.AimBot.å¼€å¯è‡ªç„) {
if (Config.AimBot.AINBOT == AIMBOT::QS) {
ASTExtraPlayerCharacter *Target = GetTargetForAimBot();
long PlayerAimLineColor = IM_COL32(254, 0, 0, 255);
if (Target) {
FVector HEAD = Target->GetBonePos("Head", {});
ImVec2 HEADSC;
if (W2S(HEAD, (FVector2D *)&HEADSC)) {
draw->AddLine({(float) glWidth / 2,  (float) (glHeight / 2)}, HEADSC, PlayerAimLineColor, 1.0f);
}
if (Config.è‡ªåŠ¨Z){
float AimDis= localPlayer->GetDistanceTo(Target) / 100.f;
if(AimDis > 0.0f && AimDis <= 28.0f){
AimYQ = Aim10;
}
if(AimDis > 28.0f && AimDis <= 50.0f){
AimYQ = Aim50;
}
if(AimDis > 50.0f && AimDis <= 100.0f){
AimYQ = Aim100;
}
if(AimDis > 100.0f && AimDis <= 150.0f){
AimYQ = Aim150;
}
if(AimDis > 150.0f && AimDis <= 200.0f){
AimYQ = Aim200;
}
if(AimDis > 200.0f && AimDis <= 250.0f){
AimYQ = Aim250;
}
if(AimDis > 250.0f && AimDis <= 300.0f){
AimYQ = Aim300;
}}
bool triggerOk = false;
if (Config.AimBot.Trigger != EAimTrigger::None) {
if (Config.AimBot.Trigger == EAimTrigger::Shooting) {
triggerOk = localPlayer->bIsWeaponFiring;
} else if (Config.AimBot.Trigger == EAimTrigger::Scoping) {
triggerOk = localPlayer->bIsGunADS;
} else if (Config.AimBot.Trigger == EAimTrigger::Both) {
triggerOk = localPlayer->bIsWeaponFiring && localPlayer->bIsGunADS;
} else if (Config.AimBot.Trigger == EAimTrigger::Any) {
triggerOk = localPlayer->bIsWeaponFiring || localPlayer->bIsGunADS;
}
} else triggerOk = true;
if (triggerOk) {
FVector targetAimPos = Target->GetBonePos("Head", {});
if (Config.AimBot.Target == EAimTarget::Chest) {
targetAimPos.Z -= 25.0f;
}
if (Config.AimBot.Target == EAimTarget::JJ) {
targetAimPos.Z -= 65.0f;
}
if (Config.è‡ªåŠ¨Z){
if (localPlayer->bIsWeaponFiring)
targetAimPos.Z -= AimYQ;
}
auto WeaponManagerComponent = localPlayer->WeaponManagerComponent;
if (WeaponManagerComponent) {
auto propSlot = WeaponManagerComponent->GetCurrentUsingPropSlot();
if ((int) propSlot.GetValue() >= 1 &&
(int) propSlot.GetValue() <= 3) {
auto CurrentWeaponReplicated = (ASTExtraShootWeapon *) WeaponManagerComponent->CurrentWeaponReplicated;
if (CurrentWeaponReplicated) {
auto ShootWeaponComponent = CurrentWeaponReplicated->ShootWeaponComponent;
if (ShootWeaponComponent) {
UShootWeaponEntity *ShootWeaponEntityComponent = ShootWeaponComponent->ShootWeaponEntityComponent;
if (ShootWeaponEntityComponent) {
if (è‡ªç„æ¥å£ == 0) {
localController->ControlRotation =ToRotator(localController->PlayerCameraManager->CameraCache.POV.Location,targetAimPos);
} else if (è‡ªç„æ¥å£ == 1) {
FRotator fAimRotation = UKismetMathLibrary::Conv_VectorToRotator(UKismetMathLibrary::Subtract_VectorVector(targetAimPos, localController->PlayerCameraManager->CameraCache.POV.Location));
localController->ControlRotation = fAimRotation;
}
}}}}}}}}}


if (Config.AimBot.å¼€å¯è‡ªç„) {
if (Config.AimBot.AINBOT == AIMBOT::CM) {
ASTExtraPlayerCharacter *Target = è§¦æ‘¸è‡ªç„();

for (int i = 0; i < Actors.size(); i++)
				{
					auto Actor = Actors[i];
					if (isObjectInvalid(Actor))
						continue;
					if (Actor->IsA(ASTExtraPlayerCharacter::StaticClass()))
					{

auto Player = (ASTExtraPlayerCharacter *)Actor;

if (Player->TeamID == localController->TeamID)
							continue;
							
long PlayerAimLineColor = IM_COL32(254, 0, 0, 255);
if (Target) {
FVector HEAD = Player->GetBonePos("Head", {});
ImVec2 HEADSC;
if (W2S(HEAD, (FVector2D *)&HEADSC)) {
draw->AddLine({(float) glWidth / 2,  (float) (glHeight / 2)}, HEADSC, PlayerAimLineColor, 1.0f);
}
if (Config.è‡ªåŠ¨Z){
float AimDis= localPlayer->GetDistanceTo(Player) / 100.f;
if(AimDis > 0.0f && AimDis <= 28.0f){
AimYQ = Aim10;
}
if(AimDis > 28.0f && AimDis <= 50.0f){
AimYQ = Aim50;
}
if(AimDis > 50.0f && AimDis <= 100.0f){
AimYQ = Aim100;
}
if(AimDis > 100.0f && AimDis <= 150.0f){
AimYQ = Aim150;
}
if(AimDis > 150.0f && AimDis <= 200.0f){
AimYQ = Aim200;
}
if(AimDis > 200.0f && AimDis <= 250.0f){
AimYQ = Aim250;
}
if(AimDis > 250.0f && AimDis <= 300.0f){
AimYQ = Aim300;
}}
bool triggerOk = false;
if (Target) {
FVector è§¦æ‘¸è°ƒç”¨ = Player->GetBonePos("Head", {});
ImVec2 è§¦æ‘¸è°ƒç”¨SC;
if (W2S(è§¦æ‘¸è°ƒç”¨, (FVector2D *)&è§¦æ‘¸è°ƒç”¨SC)) {
è§¦æ‘¸å¯¹è±¡X = è§¦æ‘¸è°ƒç”¨SC.x - 30;
è§¦æ‘¸å¯¹è±¡XX = è§¦æ‘¸è°ƒç”¨SC.x + 30;

è§¦æ‘¸å¯¹è±¡Y = è§¦æ‘¸è°ƒç”¨SC.y - 10;
è§¦æ‘¸å¯¹è±¡YY = è§¦æ‘¸è°ƒç”¨SC.y +100;


}}

ImGuiIO& io = ImGui::GetIO();

if (è§¦æ‘¸å¯¹è±¡X < io.MousePos.x && è§¦æ‘¸å¯¹è±¡XX > io.MousePos.x) {
if (è§¦æ‘¸å¯¹è±¡Y < io.MousePos.y && è§¦æ‘¸å¯¹è±¡YY > io.MousePos.y) {
if (è§¦æ‘¸X == io.MousePos.x && è§¦æ‘¸Y == io.MousePos.y) {} else {
if (è§¦æ‘¸å¯¹è±¡é˜Ÿä¼ == 0) {
è§¦æ‘¸æ¬¡æ•° + 1;
if (è§¦æ‘¸æ¬¡æ•° > 1) {
è§¦æ‘¸å¯¹è±¡é˜Ÿä¼ = Player->TeamID;
è§¦æ‘¸æ¬¡æ•° = 0;
}} else {
if (è§¦æ‘¸å¯¹è±¡é˜Ÿä¼ == Player->TeamID) {
è§¦æ‘¸æ¬¡æ•° + 1;
if (è§¦æ‘¸æ¬¡æ•° > 1) {
è§¦æ‘¸å¯¹è±¡é˜Ÿä¼ = 0;
è§¦æ‘¸æ¬¡æ•° = 0;
}} else {
è§¦æ‘¸æ¬¡æ•° + 1;
if (è§¦æ‘¸æ¬¡æ•° > 1) {
è§¦æ‘¸å¯¹è±¡é˜Ÿä¼ = Player->TeamID;
è§¦æ‘¸æ¬¡æ•° = 0;
}}}
è§¦æ‘¸X = io.MousePos.x;
è§¦æ‘¸Y = io.MousePos.y;
}} else {
è§¦æ‘¸æ¬¡æ•° = 0;
}} else {
è§¦æ‘¸æ¬¡æ•° = 0;
}

if (è§¦æ‘¸å¯¹è±¡é˜Ÿä¼ == 0) {
triggerOk = false;
} else {
if (Config.AimBot.Trigger != EAimTrigger::None) {
if (Config.AimBot.Trigger == EAimTrigger::Shooting) {
triggerOk = localPlayer->bIsWeaponFiring;
} else if (Config.AimBot.Trigger == EAimTrigger::Scoping) {
triggerOk = localPlayer->bIsGunADS;
} else if (Config.AimBot.Trigger == EAimTrigger::Both) {
triggerOk = localPlayer->bIsWeaponFiring && localPlayer->bIsGunADS;
} else if (Config.AimBot.Trigger == EAimTrigger::Any) {
triggerOk = localPlayer->bIsWeaponFiring || localPlayer->bIsGunADS;
}
} else triggerOk = true;
}

/*if (è§¦æ‘¸X == io.MousePos.x) {
if (è§¦æ‘¸Y == io.MousePos.y) {
} else {
è§¦æ‘¸Y = io.MousePos.y;
triggerOk = true;
}
} else {
è§¦æ‘¸X = io.MousePos.x;
triggerOk = true;
}*/



if (triggerOk) {
if (è§¦æ‘¸å¯¹è±¡é˜Ÿä¼ == Player->TeamID) {
FVector targetAimPos = Player->GetBonePos("Head", {});
if (Config.AimBot.Target == EAimTarget::Chest) {
targetAimPos.Z -= 25.0f;
}
if (Config.AimBot.Target == EAimTarget::JJ) {
targetAimPos.Z -= 65.0f;
}
if (Config.è‡ªåŠ¨Z){
if (localPlayer->bIsWeaponFiring)
targetAimPos.Z -= AimYQ;
}
auto WeaponManagerComponent = localPlayer->WeaponManagerComponent;
if (WeaponManagerComponent) {
auto propSlot = WeaponManagerComponent->GetCurrentUsingPropSlot();
if ((int) propSlot.GetValue() >= 1 &&
(int) propSlot.GetValue() <= 3) {
auto CurrentWeaponReplicated = (ASTExtraShootWeapon *) WeaponManagerComponent->CurrentWeaponReplicated;
if (CurrentWeaponReplicated) {
auto ShootWeaponComponent = CurrentWeaponReplicated->ShootWeaponComponent;
if (ShootWeaponComponent) {
UShootWeaponEntity *ShootWeaponEntityComponent = ShootWeaponComponent->ShootWeaponEntityComponent;
if (ShootWeaponEntityComponent) {
if (è‡ªç„æ¥å£ == 0) {
localController->ControlRotation =ToRotator(localController->PlayerCameraManager->CameraCache.POV.Location,targetAimPos);
} else if (è‡ªç„æ¥å£ == 1) {
FRotator fAimRotation = UKismetMathLibrary::Conv_VectorToRotator(UKismetMathLibrary::Subtract_VectorVector(targetAimPos, localController->PlayerCameraManager->CameraCache.POV.Location));
localController->ControlRotation = fAimRotation;
}
}}}}}}}}}}}}


if (Config.AimBot.å¼€å¯å­è¿½) {
if (Config.SilentAim.AINBOTA == AIMBOTA::SJZZ) {
Â Â Â Â                                      auto WeaponManagerComponent = localPlayer->WeaponManagerComponent;
                    if (WeaponManagerComponent) {
                        auto propSlot = WeaponManagerComponent->GetCurrentUsingPropSlot();
                        if ((int) propSlot.GetValue() >= 1 && (int) propSlot.GetValue() <= 3) {
                            auto CurrentWeaponReplicated = (ASTExtraShootWeapon *) WeaponManagerComponent->CurrentWeaponReplicated;
                            if (CurrentWeaponReplicated) {
                                auto ShootWeaponComponent = CurrentWeaponReplicated->ShootWeaponComponent;
                                if (ShootWeaponComponent) {
                                    int shoot_event_idx = 163;
                                    auto f_mprotect = [](uintptr_t addr, size_t len, int32_t prot) -> int32_t {
                                      static_assert(PAGE_SIZE == 4096);
                                      constexpr size_t page_size = static_cast<size_t>(PAGE_SIZE);
                                      void* start = reinterpret_cast<void*>(addr & -page_size);
                                      uintptr_t end = (addr + len + page_size - 1) & -page_size;
                                      return mprotect(start, end - reinterpret_cast<uintptr_t>(start), prot);
                                    };
                                    auto VTable = (void **) ShootWeaponComponent->VTable;
                                    if (VTable && (VTable[shoot_event_idx] != shoot_event)) {
                                        orig_shoot_event = decltype(orig_shoot_event)(
                                                VTable[shoot_event_idx]);
                                        f_mprotect((uintptr_t)(&VTable[shoot_event_idx]), sizeof(uintptr_t), PROT_READ | PROT_WRITE);
                                        VTable[shoot_event_idx] = (void *) shoot_event;
                                    }
                                }
                            }
                        }
                    }
                }
            }

if (Config.AimBot.å¼€å¯å­è¿½) {
if (Config.SilentAim.AINBOTA == AIMBOTA::QSZZ) {
Â Â Â Â                                      auto WeaponManagerComponent = localPlayer->WeaponManagerComponent;
                    if (WeaponManagerComponent) {
                        auto propSlot = WeaponManagerComponent->GetCurrentUsingPropSlot();
                        if ((int) propSlot.GetValue() >= 1 && (int) propSlot.GetValue() <= 3) {
                            auto CurrentWeaponReplicated = (ASTExtraShootWeapon *) WeaponManagerComponent->CurrentWeaponReplicated;
                            if (CurrentWeaponReplicated) {
                                auto ShootWeaponComponent = CurrentWeaponReplicated->ShootWeaponComponent;
                                if (ShootWeaponComponent) {
                                    int shoot_event_idx = 163;
                                    auto f_mprotect = [](uintptr_t addr, size_t len, int32_t prot) -> int32_t {
                                      static_assert(PAGE_SIZE == 4096);
                                      constexpr size_t page_size = static_cast<size_t>(PAGE_SIZE);
                                      void* start = reinterpret_cast<void*>(addr & -page_size);
                                      uintptr_t end = (addr + len + page_size - 1) & -page_size;
                                      return mprotect(start, end - reinterpret_cast<uintptr_t>(start), prot);
                                    };
                                    auto VTable = (void **) ShootWeaponComponent->VTable;
                                    if (VTable && (VTable[shoot_event_idx] != shoot_event)) {
                                        orig_shoot_event = decltype(orig_shoot_event)(
                                                VTable[shoot_event_idx]);
                                        f_mprotect((uintptr_t)(&VTable[shoot_event_idx]), sizeof(uintptr_t), PROT_READ | PROT_WRITE);
                                        VTable[shoot_event_idx] = (void *) shoot_event;
                                    }
                                }
                            }
                        }
                    }
                }
             }

				
		
                                    
                                

                                    if (Config.é›·è¾¾) {             
                                    if (Config.PlayerESP.RadarZX == RADAR::KR) {                    
                     struct Vector3 åæ ‡;
                     åæ ‡.X = Config.RadarX*10;
                     åæ ‡.Y = Config.RadarY*10;
                     struct Vector3 Size;
                     Size.X = 200; //Width of Radar Box.
                     Size.Y = 210; //Height of Radar Box.
                     float é›·è¾¾Xè½´ = åæ ‡.X + (Size.X / 2);
                     float é›·è¾¾Yè½´ = åæ ‡.Y + (Size.Y / 2);
    draw->AddLine({é›·è¾¾Xè½´,é›·è¾¾Yè½´},{é›·è¾¾Xè½´+200,é›·è¾¾Yè½´}, IM_COL32(255, 255, 0, 255),2.0f);
    draw->AddLine({é›·è¾¾Xè½´,é›·è¾¾Yè½´}, {é›·è¾¾Xè½´,é›·è¾¾Yè½´ + 200}, IM_COL32(255, 255, 0, 255),2.0f);
    draw->AddLine({é›·è¾¾Xè½´ + 200,é›·è¾¾Yè½´}, {é›·è¾¾Xè½´ + 200,é›·è¾¾Yè½´ + 200}, IM_COL32(177, 134, 0, 255),2.0f);
    draw->AddLine({é›·è¾¾Xè½´,é›·è¾¾Yè½´ + 200},{é›·è¾¾Xè½´ + 200,é›·è¾¾Yè½´ + 200}, IM_COL32(177, 134, 0, 255),2.0f);
    draw->AddLine({é›·è¾¾Xè½´ + 100,é›·è¾¾Yè½´},{é›·è¾¾Xè½´+100,é›·è¾¾Yè½´ + 200}, IM_COL32(255, 255, 255, 255),2.0f);
    draw->AddLine({é›·è¾¾Xè½´,é›·è¾¾Yè½´ + 100},{é›·è¾¾Xè½´+200,é›·è¾¾Yè½´ + 100}, IM_COL32(255, 255, 255, 255),2.0f);
    draw->AddLine({é›·è¾¾Xè½´ + 50,é›·è¾¾Yè½´ + 50},{é›·è¾¾Xè½´+150,é›·è¾¾Yè½´ + 50},ç»¿è‰²,2.0f);
    draw->AddLine({é›·è¾¾Xè½´ + 50,é›·è¾¾Yè½´ + 50},{é›·è¾¾Xè½´+50,é›·è¾¾Yè½´ + 100},ç»¿è‰²,2.0f);
    draw->AddLine({é›·è¾¾Xè½´ + 150,é›·è¾¾Yè½´ + 50},{é›·è¾¾Xè½´+150,é›·è¾¾Yè½´ + 100},ç»¿è‰²,2.0f);


                 }
                 if (Config.PlayerESP.RadarZX == RADAR::QZ) {
                 
                 bool out = false;                              
                     struct Vector3 Pos;
                     Pos.X = 200;
                     Pos.Y = 210;
                     struct Vector3 Size;
                     Size.X = Config.RadarX*10;
                     Size.Y = Config.RadarY*10;
                     float RadarCenterX = Pos.X + (Size.X / 2);
                     float RadarCenterY = Pos.Y + (Size.Y / 2);
                     ImColor CircleColor = ImColor(000, 000, 000, 15);
                     ImColor PointColor = ImColor(255, 255, 255, 255);
                    draw->AddCircleFilled(ImVec2(RadarCenterX, RadarCenterY), 100.f, CircleColor, 100); 
                    draw->AddCircleFilled(ImVec2(RadarCenterX, RadarCenterY), 20.f, CircleColor, 20); 
                     draw->AddCircle(ImVec2(RadarCenterX, RadarCenterY), 100.f, PointColor, 1000); 
                     draw->AddCircle(ImVec2(RadarCenterX, RadarCenterY), 20.f, PointColor, 1000); 
                     draw->AddCircleFilled(ImVec2(RadarCenterX + 0.5f, RadarCenterY + 0.5f), 3.f, PointColor, 1000);
                 }
                 if (Config.PlayerESP.RadarZX == RADAR::DNA) {                                 
                     bool out = true;                              
                     struct Vector3 Pos;
                     Pos.X = 200;
                     Pos.Y = 210;
                     struct Vector3 Size;
                     Size.X = Config.RadarX*10; //Width of Radar Box.
                     Size.Y = Config.RadarY*10; //Height of Radar Box.
                     float RadarCenterX = Pos.X + (Size.X / 2);
                     float RadarCenterY = Pos.Y + (Size.Y / 2);
                     ImColor CircleColor = ImColor(0, 0, 0, 20);
                     ImColor PointC = IM_COL32(234,209,220,250);
                     ImColor Point = IM_COL32(0,250,154,125);
                     ImColor Color = IM_COL32(0,255,255,125);
                     ImColor PointColor = IM_COL32(255,192,203,125);                    
                                          
                     draw->AddCircle(ImVec2(RadarCenterX, RadarCenterY), 50.f, PointC, 1000);    
                     draw->AddCircle(ImVec2(RadarCenterX, RadarCenterY), 88.f, Point, 1000);  
                     draw->AddCircle(ImVec2(RadarCenterX, RadarCenterY), 120.f, Color, 1000);  
                     draw->AddCircle(ImVec2(RadarCenterX, RadarCenterY), 150.f, PointColor, 1000);    
                     draw->AddCircleFilled(ImVec2(RadarCenterX + 0.5f, RadarCenterY + 0.5f), 3.f, PointColor, 1000); 
			

                 }
                 }
                               
                         
              
				//=============ESP=================//
				for (int i = 0; i < Actors.size(); i++)
				{
					auto Actor = Actors[i];
					if (isObjectInvalid(Actor))
						continue;
					if (Actor->IsA(ASTExtraPlayerCharacter::StaticClass()))
					{
						auto Player = (ASTExtraPlayerCharacter *)Actor;
                        long PBox, PLine, PSkeleton;
                        ImColor é¢œè‰² = ImColor(é˜Ÿä¼é¢œè‰²(Player->TeamID));
                        long PlayerBoxClrCf = IM_COL32(223,0,41, 255);
                        long PlayerBoxClrCf2 = IM_COL32(223,0,41, 25);
						float Distance = localPlayer->GetDistanceTo(Player) / 100.0f;
						if (!localController->LineOfSightTo(Player, {0, 0, 0}, true)) {
                            PlayerBoxClrCf = IM_COL32(0,255,0, 255);
                            PlayerBoxClrCf2 = IM_COL32(0,255,0, 25);
                        }
						
							
	          			if (Distance > 500.0f)//é»˜è®¤ç»˜åˆ¶è·ç¦»
							continue;
							
					    
						if (Player->PlayerKey == localController->PlayerKey)
							continue;
					    if (!Config.PlayerESP.Team)
						if (Player->TeamID == localController->TeamID)
							continue;
						if (Config.PlayerESP.WALL)
					    if (!localController->LineOfSightTo(Player, {0, 0, 0}, true))
                        continue;
						if (Player->bDead)
							continue;
						if (!Player->Mesh)
							continue;
						if (localController->LineOfSightTo(Player, {0, 0, 0}, true))
						oozing++;
						if (Player->bIsAI)
						{
					 		totalBots++;
	  	     				PBox = ToColor(Config.ColorsESP.BVBox);
                            PLine = ToColor(Config.ColorsESP.BVLine);
                            PSkeleton = ToColor(Config.ColorsESP.BVSkeleton);
                            if (!localController->LineOfSightTo(Player, {0, 0, 0}, true))
                            {
                                PBox = ToColor(Config.ColorsESP.BVIBox);
                                PLine = ToColor(Config.ColorsESP.BVILine);
                                PSkeleton = ToColor(Config.ColorsESP.BVISkeleton);
                            }
						} else {
							totalEnemies++;
	  	     				PBox = ToColor(Config.ColorsESP.PVBox);
                            PLine = ToColor(Config.ColorsESP.PVLine);
                            PSkeleton = ToColor(Config.ColorsESP.PVSkeleton);
                            if (!localController->LineOfSightTo(Player, {0, 0, 0}, true))
                            {
                                PBox = ToColor(Config.ColorsESP.PVIBox);
                                PLine = ToColor(Config.ColorsESP.PVILine);
                                PSkeleton = ToColor(Config.ColorsESP.PVISkeleton);
                            }
						}

						
						if (Config.é›·è¾¾) 
					 {
					 if (Config.PlayerESP.RadarZX == RADAR::KR) {
                     std::string s;

                                    s += std::to_string((int) Distance);
                                    s += "ç±³";
                      FVector MyPosition;
                      ASTExtraVehicleBase *CurrentVehiclea = Player->CurrentVehicle;
                 if (CurrentVehiclea) {
                      MyPosition = CurrentVehiclea->RootComponent->RelativeLocation;
                       } else {
                      MyPosition = Player->RootComponent->RelativeLocation;
                       }                                     
                      FVector EnemyPosition;
                      ASTExtraVehicleBase *CurrentVehicle = localPlayer->CurrentVehicle;
                 if (CurrentVehicle) {
                      EnemyPosition = CurrentVehicle->RootComponent->RelativeLocation;
                       }  else {
                      EnemyPosition = localPlayer->RootComponent->RelativeLocation;
                }
               bool out = false;                              
               struct Vector3 åæ ‡;
               åæ ‡.X = Config.RadarX*10;
               åæ ‡.Y = Config.RadarY*10;
               struct Vector3 Size;
               Size.X = 200; //Width of Radar Box. é›·è¾¾ç®±çš„å®½åº¦
               Size.Y = 210; //Height of Radar Box. é›·è¾¾ç®±çš„é«˜åº¦
               float é›·è¾¾Xè½´ = åæ ‡.X + (Size.X / 2);
               float é›·è¾¾Yè½´ = åæ ‡.Y + (Size.Y / 2);                                
                                                   
               
               FVector EntityPos = WorldToRadar(localController->PlayerCameraManager->CameraCache.POV.Rotation.Yaw, MyPosition, EnemyPosition, NULL, NULL, Vector3(glWidth, glHeight, 0), out);
               FVector RadarSketch = WorldToRadar(localController->PlayerCameraManager->CameraCache.POV.Rotation.Yaw, MyPosition, EnemyPosition, é›·è¾¾Xè½´,é›·è¾¾Yè½´, Vector3(Size.X, Size.Y, 0), out);
              if (Distance >= 0.f) {

               draw->AddCircleFilled(ImVec2(RadarSketch.X, RadarSketch.Y), 5, PlayerBoxClrCf, 0.0f);    
                ç»˜åˆ¶åŠ ç²—æ–‡æœ¬2(14,RadarSketch.X + 1, RadarSketch.Y+1,é»„è‰²,ç™½è‰²,s.c_str());
                FVector angle = FVector();
                            Vector3 forward = Vector3((float)(glWidth / 2) - EntityPos.X, (float)(glHeight / 2) - EntityPos.Y, 0.0f);
                            VectorAnglesRadar(forward, angle);
                            const auto angle_yaw_rad = DEG2RAD(angle.Y + 180.f);
                            const auto new_point_x = (glWidth / 2) + (55) / 2 * 8 * cosf(angle_yaw_rad);
                            const auto new_point_y = (glHeight / 2) + (55) / 2 * 8 * sinf(angle_yaw_rad);
                            std::array<Vector3, 3> points { Vector3(new_point_x - ((90) / 4 + 3.5f) / 2, new_point_y - ((55) / 4 + 3.5f) / 2, 0.f), Vector3(new_point_x + ((90) / 4 + 3.5f) / 4, new_point_y, 0.f), Vector3(new_point_x - ((90) / 4 + 3.5f) / 2, new_point_y + ((55) / 4 + 3.5f) / 2, 0.f)};
                            RotateTriangle(points, angle.Y + 180.f);
                            draw->AddTriangle(ImVec2(points.at(0).X, points.at(0).Y), ImVec2(points.at(1).X, points.at(1).Y), ImVec2(points.at(2).X, points.at(2).Y),é¢œè‰², 1.5f);
                           
            }
		}
		
		if (Config.PlayerESP.RadarZX == RADAR::QZ) {
                     std::string s;

                                    s += std::to_string((int) Distance);
                                    s += "ç±³";
                      FVector MyPosition;
                      ASTExtraVehicleBase *CurrentVehiclea = Player->CurrentVehicle;
                 if (CurrentVehiclea) {
                      MyPosition = CurrentVehiclea->RootComponent->RelativeLocation;
                       } else {
                      MyPosition = Player->RootComponent->RelativeLocation;
                       }                                     
                      FVector EnemyPosition;
                      ASTExtraVehicleBase *CurrentVehicle = localPlayer->CurrentVehicle;
                 if (CurrentVehicle) {
                      EnemyPosition = CurrentVehicle->RootComponent->RelativeLocation;
                       }  else {
                      EnemyPosition = localPlayer->RootComponent->RelativeLocation;
                }
               bool out = false;                              
               struct Vector3 åæ ‡;
               åæ ‡.X = Config.RadarX*10;
               åæ ‡.Y = Config.RadarY*10;
               struct Vector3 Size;
               Size.X = 200; //Width of Radar Box.
               Size.Y = 210; //Height of Radar Box.
               float é›·è¾¾Xè½´ = åæ ‡.X + (Size.X / 2);
               float é›·è¾¾Yè½´ = åæ ‡.Y + (Size.Y / 2);                                
                                                   
               
               FVector EntityPos = WorldToRadar(localController->PlayerCameraManager->CameraCache.POV.Rotation.Yaw, MyPosition, EnemyPosition, NULL, NULL, Vector3(glWidth, glHeight, 0), out);
               FVector RadarSketch = WorldToRadar(localController->PlayerCameraManager->CameraCache.POV.Rotation.Yaw, MyPosition, EnemyPosition, é›·è¾¾Xè½´,é›·è¾¾Yè½´, Vector3(Size.X, Size.Y, 0), out);
              if (Distance >= 0.f) {

               draw->AddCircleFilled(ImVec2(RadarSketch.X, RadarSketch.Y), 5, PlayerBoxClrCf, 0.0f);    
                ç»˜åˆ¶åŠ ç²—æ–‡æœ¬2(14,RadarSketch.X + 1, RadarSketch.Y+1,é»„è‰²,ç™½è‰²,s.c_str());
                FVector angle = FVector();
                            Vector3 forward = Vector3((float)(glWidth / 2) - EntityPos.X, (float)(glHeight / 2) - EntityPos.Y, 0.0f);
                            VectorAnglesRadar(forward, angle);
                            const auto angle_yaw_rad = DEG2RAD(angle.Y + 180.f);
                            const auto new_point_x = (glWidth / 2) + (55) / 2 * 8 * cosf(angle_yaw_rad);
                            const auto new_point_y = (glHeight / 2) + (55) / 2 * 8 * sinf(angle_yaw_rad);
                            std::array<Vector3, 3> points { Vector3(new_point_x - ((90) / 4 + 3.5f) / 2, new_point_y - ((55) / 4 + 3.5f) / 2, 0.f), Vector3(new_point_x + ((90) / 4 + 3.5f) / 4, new_point_y, 0.f), Vector3(new_point_x - ((90) / 4 + 3.5f) / 2, new_point_y + ((55) / 4 + 3.5f) / 2, 0.f)};
                            RotateTriangle(points, angle.Y + 180.f);
                            draw->AddTriangle(ImVec2(points.at(0).X, points.at(0).Y), ImVec2(points.at(1).X, points.at(1).Y), ImVec2(points.at(2).X, points.at(2).Y),é¢œè‰², 1.5f);
                           
            }
		}
		if (Config.PlayerESP.RadarZX == RADAR::DNA) 
					 {
                     std::string s;

                                    s += std::to_string((int) Distance);
                                    s += "ç±³";
                      FVector MyPosition;
                      ASTExtraVehicleBase *CurrentVehiclea = Player->CurrentVehicle;
                 if (CurrentVehiclea) {
                      MyPosition = CurrentVehiclea->RootComponent->RelativeLocation;
                       } else {
                      MyPosition = Player->RootComponent->RelativeLocation;
                       }                                     
                      FVector EnemyPosition;
                      ASTExtraVehicleBase *CurrentVehicle = localPlayer->CurrentVehicle;
                 if (CurrentVehicle) {
                      EnemyPosition = CurrentVehicle->RootComponent->RelativeLocation;
                       }  else {
                      EnemyPosition = localPlayer->RootComponent->RelativeLocation;
                }
               bool out = false;                              
               struct Vector3 åæ ‡;
               åæ ‡.X = Config.RadarX*10;
               åæ ‡.Y = Config.RadarY*10;
               struct Vector3 Size;
               Size.X = 200; //Width of Radar Box.
               Size.Y = 210; //Height of Radar Box.
               float é›·è¾¾Xè½´ = åæ ‡.X + (Size.X / 2);
               float é›·è¾¾Yè½´ = åæ ‡.Y + (Size.Y / 2);                                
                                                   
               
               FVector EntityPos = WorldToRadar(localController->PlayerCameraManager->CameraCache.POV.Rotation.Yaw, MyPosition, EnemyPosition, NULL, NULL, Vector3(glWidth, glHeight, 0), out);
               FVector RadarSketch = WorldToRadar(localController->PlayerCameraManager->CameraCache.POV.Rotation.Yaw, MyPosition, EnemyPosition, é›·è¾¾Xè½´,é›·è¾¾Yè½´, Vector3(Size.X, Size.Y, 0), out);
              if (Distance >= 0.f) {

               draw->AddCircleFilled(ImVec2(RadarSketch.X, RadarSketch.Y), 5, PlayerBoxClrCf, 0.0f);    
                ç»˜åˆ¶åŠ ç²—æ–‡æœ¬2(14,RadarSketch.X + 1, RadarSketch.Y+1,é»„è‰²,ç™½è‰²,s.c_str());
                FVector angle = FVector();
                            Vector3 forward = Vector3((float)(glWidth / 2) - EntityPos.X, (float)(glHeight / 2) - EntityPos.Y, 0.0f);
                            VectorAnglesRadar(forward, angle);
                            const auto angle_yaw_rad = DEG2RAD(angle.Y + 180.f);
                            const auto new_point_x = (glWidth / 2) + (55) / 2 * 8 * cosf(angle_yaw_rad);
                            const auto new_point_y = (glHeight / 2) + (55) / 2 * 8 * sinf(angle_yaw_rad);
                            std::array<Vector3, 3> points { Vector3(new_point_x - ((90) / 4 + 3.5f) / 2, new_point_y - ((55) / 4 + 3.5f) / 2, 0.f), Vector3(new_point_x + ((90) / 4 + 3.5f) / 4, new_point_y, 0.f), Vector3(new_point_x - ((90) / 4 + 3.5f) / 2, new_point_y + ((55) / 4 + 3.5f) / 2, 0.f)};
                            RotateTriangle(points, angle.Y + 180.f);
                            draw->AddTriangle(ImVec2(points.at(0).X, points.at(0).Y), ImVec2(points.at(1).X, points.at(1).Y), ImVec2(points.at(2).X, points.at(2).Y),é¢œè‰², 1.5f);
                           
            }
		}}
						
						if (Config.PlayerESP.NoBot)
							if (Player->bIsAI)
								continue;
					
								//totalEnemies++;
						auto HeadPos = Player->GetBonePos("Head", {});
						ImVec2 HeadPosSC;
						auto RootPos = Player->GetBonePos("Root", {});
						ImVec2 RootPosSC;
						auto upper_r = Player->GetBonePos("upperarm_r", {});
						ImVec2 upper_rPoSC;
						auto lowerarm_r = Player->GetBonePos("lowerarm_r", {});
						ImVec2 lowerarm_rPoSC;
						auto hand_r = Player->GetBonePos("hand_r", {});
						ImVec2 hand_rPoSC;
						auto upper_l = Player->GetBonePos("upperarm_l", {});
						ImVec2 upper_lPoSC;
						auto lowerarm_l = Player->GetBonePos("lowerarm_l", {});
						ImVec2 lowerarm_lSC;
						auto hand_l = Player->GetBonePos("hand_l", {});
						ImVec2 hand_lPoSC;
						auto thigh_l = Player->GetBonePos("thigh_l", {});
						ImVec2 thigh_lPoSC;
						auto calf_l = Player->GetBonePos("calf_l", {});
						ImVec2 calf_lPoSC;
						auto foot_l = Player->GetBonePos("foot_l", {});
						ImVec2 foot_lPoSC;
						auto thigh_r = Player->GetBonePos("thigh_r", {});
						ImVec2 thigh_rPoSC;
						auto calf_r = Player->GetBonePos("calf_r", {});
						ImVec2 calf_rPoSC;
						auto foot_r = Player->GetBonePos("foot_r", {});
						ImVec2 foot_rPoSC;
						auto neck_01 = Player->GetBonePos("neck_01", {});
						ImVec2 neck_01PoSC;
						auto pelvis = Player->GetBonePos("pelvis", {});
						ImVec2 pelvisPoSC;
						if (W2S(HeadPos, (FVector2D *)&HeadPosSC) && W2S(upper_r, (FVector2D *)&upper_rPoSC) && W2S(upper_l, (FVector2D *)&upper_lPoSC) && W2S(lowerarm_r, (FVector2D *)&lowerarm_rPoSC) && W2S(hand_r, (FVector2D *)&hand_rPoSC) && W2S(lowerarm_l, (FVector2D *)&lowerarm_lSC) && W2S(hand_l, (FVector2D *)&hand_lPoSC) && W2S(thigh_l, (FVector2D *)&thigh_lPoSC) && W2S(calf_l, (FVector2D *)&calf_lPoSC) && W2S(foot_l, (FVector2D *)&foot_lPoSC) && W2S(thigh_r, (FVector2D *)&thigh_rPoSC) && W2S(calf_r, (FVector2D *)&calf_rPoSC) && W2S(foot_r, (FVector2D *)&foot_rPoSC) && W2S(neck_01, (FVector2D *)&neck_01PoSC) && W2S(pelvis, (FVector2D *)&pelvisPoSC) && W2S(RootPos, (FVector2D *)&RootPosSC))
						{
                            FVector2D location(RootPosSC.x, HeadPosSC.y);
					
				
						if (Config.PlayerESP.å¼€å¯çº¿æ¡) {
							if (Config.PlayerESP.ä¸Š) {
	draw->AddLine({(float)glWidth / 2, 0}, HeadPosSC, PLine, 1.0f);
                        }
				
							if (Config.PlayerESP.ä¸­) {
                            draw->AddLine({(float)glWidth / 2, 358}, HeadPosSC, PLine, 1.0f);
                            }
                            
                          if (Config.PlayerESP.ä¸‹) {			
                     draw->AddLine({(float)glWidth / 2, 716}, HeadPosSC, PLine, 1.0f);
											  }			}
						
						

						
						                        if (Config.åŠ¨ä½œ) {
                                float boxWidth = density / 1.8f;
                                boxWidth -= std::min(((boxWidth / 2) / 00.0f) * Distance,
                                                     boxWidth / 2);
                                float boxHeight = boxWidth * 0.19f;
                                            auto PlayerStat = playerstatus(Player->CurrentStates);
                                            std::string s = "å½“å‰çŠ¶æ€:[";
                                             s += PlayerStat;
                                             s += "]";
                                            if (PlayerStat != "") {
                                            ç»˜åˆ¶åŠ ç²—æ–‡æœ¬2(19,HeadPosSC.x - (boxWidth / 3)  - 60,
                                               HeadPosSC.y - 105,
                                              ç™½è‰²,é»„è‰²,s.c_str());
                                            }
                                            }
                                            
                                         if (Config.æ‰‹æŒ) {
                        auto rrrr = Player->GetBonePos("pelvis", {});
                                
                                FVector2D we;
                                
                                std::string wep;
                                
                                if (W2S(rrrr, &we)) {
                                    auto WeaponManagerComponent = Player->WeaponManagerComponent;
                                    if (WeaponManagerComponent) {
                                        auto CurrentWeaponReplicated = (ASTExtraShootWeapon *) WeaponManagerComponent->CurrentWeaponReplicated;
                                        if (CurrentWeaponReplicated) {
                                            auto wppp = CurrentWeaponReplicated->GetWeaponID();
                                           // auto æ‰‹æŒæ­¦å™¨ = CurrentWeaponReplicated->GetWeaponID();
                                            
                                                 auto å½“å‰å­å¼¹= CurrentWeaponReplicated->CurBulletNumInClip;
                                           
                                                  auto  æœ€å¤§å­å¼¹ = CurrentWeaponReplicated->CurMaxBulletNumInOneClip;
                                            if(wppp == 108004 || wppp == 108003 || wppp == 108002  ||wppp == 108001 || wppp == 108000 || wppp == 108005 || wppp == 108006 || wppp == 108007)
                                                continue;
                                         //   bool hqtt(int wppp,ImTextureID * textureId){
                                         
                                         
                        if (wppp == NULL) {
                        wep +="ç©ºæ‰‹";
                        } else {
                        for (auto & category : itemsss_datakl) {
						for (auto & item : category["Items"]) {
						if (item["itemId"] == wppp) {
					  //tc = strtoul(item["itemTextColor"].get<std::string>().c_str(), 0, 16);
						wep += item["itemName"].get<std::string>();
						break;
						}}}}
                                         
                                         
                                         
                                         
                                          /*  switch (wppp) {
                                                case NULL:
                                                    wep +="ç©ºæ‰‹";
                                                   
                                                    break;
                                                    
                                                case 101001:
                                                    wep += "æ­¦å™¨:[AKM]";
                                                    break;
                                                case 101002:
                                                    wep +=  "æ­¦å™¨:[M16A4]";
                                                    break;
                                                case 101003:
                                                    wep +=  "æ­¦å™¨:[SCAR-L]";
                                                    break;
                                                case 101004:
                                                    wep +=  "æ­¦å™¨:[M416]";
                                                    break;
                                                case 101005:
                                                    wep +=  "æ­¦å™¨:[ç‹—ç ¸]";
                                                    break;
                                                case 101006:
                                                    wep +=  "æ­¦å™¨:[AUG]";
                                                    break;
                                                case 101007:
                                                    wep +=  "æ­¦å™¨:[QBZ]";
                                                    break;
                                                case 101008:
                                                    wep +=  "æ­¦å™¨:[M762]";
                                                    break;
                                                case 101009:
                                                    wep +=  "æ­¦å™¨:[Mk47]";
                                                    break;
                                                case 101010:
                                                    wep +=  "æ­¦å™¨:[G36C]";
                                                    break;
                                                case 101100:
                                                    wep +=  "æ­¦å™¨:[FAMAS]";
                                                    break;
                                                    //LIGHT MACHINEGUN
                                                case 105001:
                                                    wep +=  "æ­¦å™¨:[M249]";
                                                    break;
                                                case 105002:
                                                    wep +=  "æ­¦å™¨:[DP-28]";
                                                    break;
                                                    //SMG
                                                case 102001:
                                                    wep +=  "æ­¦å™¨:[UZI]";
                                                    break;
                                                case 102002:
                                                    wep +=  "æ­¦å™¨:[UMP45]";
                                                    break;
                                                case 102003:
                                                    wep +=  "æ­¦å™¨:[Vector]";
                                                    break;
                                                case 102004:
                                                    wep +=  "æ­¦å™¨:[TommyGun]";
                                                    break;
                                                    
                                                case 102005:
                                                    wep +=  "æ­¦å™¨:[PP-19 Bizon]";
                                                    break;
                                                case 102007:
                                                    wep +=  "æ­¦å™¨:[Skorpion]";
                                                    break;
                                                    //SNIPER
                                                case 103001:
                                                    wep +=  "æ­¦å™¨:[Kar98K]";
                                                    break;
                                                case 103002:
                                                    wep +=  "æ­¦å™¨:[M24]";
                                                    break;
                                                case 103003:
                                                    wep +=  "æ­¦å™¨:[AWM]";
                                                    break;
                                                case 103004:
                                                    wep +=  "æ­¦å™¨:[SKS]";
                                                    break;
                                                case 103005:
                                                    wep +=  "æ­¦å™¨:[VSS]";
                                                    break;
                                                case 103006:
                                                    wep +=  "æ­¦å™¨:[Mini14]";
                                                    break;
                                                case 103007:
                                                    wep +=  "æ­¦å™¨:[Mk14]";
                                                    break;
                                                case 103008:
                                                    wep +=  "æ­¦å™¨:[Win94]";
                                                    break;
                                                case 103009:
                                                    wep +=  "æ­¦å™¨:[SLR]";
                                                    break;
                                                case 103010:
                                                    wep +=  "æ­¦å™¨:[QBU]";
                                                    break;
                                                case 103011:
                                                    wep +=  "æ­¦å™¨:[Mosin]";
                                                    break;
                                                    //SHOTGUN
                                                case 103100:
                                                    wep +=  "æ­¦å™¨:[Mk12]";
                                                    break;
                                                case 104001:
                                                    wep +=  "æ­¦å™¨:[S686]";
                                                    break;

                                                case 104002:
                                                    wep +=  "æ­¦å™¨:[S1897]";
                                                    break;
                                                case 104003:
                                                    wep +=  "æ­¦å™¨:[S12K]";
                                                    break;
                                                case 104004:
                                                    wep +=  "æ­¦å™¨:[M1014]";
                                                    break;
                                                case 106006:
                                                    wep +=  "æ­¦å™¨:[Sawed-off]";
                                                    break;
                                                    //POSTIL
                                                case 106001:
                                                    wep +=  "æ­¦å™¨:[P1911]";
                                                    break;
                                                case 106003:
                                                    wep +=  "æ­¦å™¨:[R1895]";
                                                    break;
                                                case 106004:
                                                    wep +=  "æ­¦å™¨:[P18C]";
                                                    break;
                                                case 106005:
                                                    wep +=  "æ­¦å™¨:[R45]";
                                                    break;
                                                case 106008:
                                                    wep +=  "æ­¦å™¨:[Vz61]";
                                                    break;
                                                case 106010:
                                                    wep +=  "æ­¦å™¨:[Desert Eagle]";
                                                    break;
                                                    //OTHER
                                                case 107001:
                                                    wep +=  "æ­¦å™¨:[Crossbow]";
                                                    break;
                                                case 108001:
                                                    wep +=  "æ­¦å™¨:[vcMachete]";
                                                    break;
                                                case 108002:
                                                    wep +=  "æ­¦å™¨:[Crowbar]";
                                                    break;
                                                case 108003:
                                                    wep +=  "æ­¦å™¨:[Sickle]";
                                                    break;
                                                case 108004:
                                                    wep +=  "æ­¦å™¨:[Pan]";
                                                    break;
                                                case 201001:
                                                    wep +=  "æ­¦å™¨:[Choke]";
                                                    break;
                                                case 103012:
                                                    wep += "æ­¦å™¨[AMRå¤§ç‹™]";
                                                    case 1030071:
                                                        wep +="å¦¹æ§-[ç ´æŸ]";
                                                        
                                                    break;
                                                    case 1030072:
                                                        wep +="å¦¹æ§-[ä¿®å¤]";
                                                    break;
                                                    case 1030073:
                                                        wep +="å¦¹æ§-[å®Œå¥½]";
                                                    break;
                                                    case 1030074:
                                                        wep +="å¦¹æ§-[æ”¹è¿›]";
                                                    break;
                                                    case 1030075:
                                                        wep +="å¦¹æ§-[ç²¾è‡´]";
                                                    break;
                                                    case 1030076:
                                                        wep +="å¦¹æ§-[ç‹¬çœ¼è›‡]";
                                                    break;
                                                    case 1030077:
                                                        wep +="å¦¹æ§-[é’¢é“é˜µçº¿]";
                                                    break;
                                                    
                                                    
                                                    case 1010041:
                                                        wep +="M416-[ç ´æŸ]";
                                                    break;
                                                    case 1010042:
                                                        wep +="M416-[ä¿®å¤]";
                                                    break;
                                                    case 1010043:
                                                        wep +="M416-[å®Œå¥½]";
                                                    break;
                                                    case 1010044:
                                                        wep +="M416-[æ”¹è¿›]";
                                                    break;
                                                    case 1010045:
                                                        wep +="M416-[ç²¾è‡´]";
                                                    break;
                                                    case 1010046:
                                                        wep +="M416-[ç‹¬çœ¼è›‡]";
                                                    break;
                                                    case 1010047:
                                                        wep +="M416-[é’¢é“é˜µçº¿]";
                                                    break;
                                                    
                                                    case 1050011:
                                                        wep +="M249-[ç ´æŸ]";
                                                    break;
                                                    case 1050012:
                                                        wep +="M249-[ä¿®å¤]";
                                                    break;
                                                    case 1050013:
                                                        wep +="M249-[å®Œå¥½]";
                                                    break;
                                                    case 1050014:
                                                        wep +="M249-[æ”¹è¿›]";
                                                    break;
                                                    case 1050015:
                                                        wep +="M249-[ç²¾è‡´]";
                                                    break;
                                                    case 1050016:
                                                        wep +="M249-[ç‹¬çœ¼è›‡]";
                                                    break;
                                                    case 1050017:
                                                        wep +="M249-[é’¢é“é˜µçº¿]";
                                                    break;
                                                    
                                                    case 1010051:
                                                        wep +="ç‹—ç ¸-[ç ´æŸ]";
                                                    break;
                                                    case 1010052:
                                                        wep +="ç‹—ç ¸-[ä¿®å¤]";
                                                    break;
                                                    case 1010053:
                                                        wep +="ç‹—ç ¸-[å®Œå¥½]";
                                                    break;
                                                    case 1010054:
                                                        wep +="ç‹—ç ¸-[æ”¹è¿›]";
                                                    break;
                                                    case 1010055:
                                                        wep +="ç‹—ç ¸-[ç²¾è‡´]";
                                                    break;
                                                    case 1010056:
                                                        wep +="ç‹—ç ¸-[ç‹¬çœ¼è›‡]";
                                                    break;
                                                    case 1010057:
                                                        wep +="ç‹—ç ¸-[é’¢é“é˜µçº¿]";
                                                        
                                                    case 1010061:
                                                        wep +="AUG-[ç ´æŸ]";
                                                        
                                                    break;
                                                    case 1010062:
                                                        wep +="AUG-[ä¿®å¤]";
                                                    break;
                                                    case 1010063:
                                                        wep +="AUG-[å®Œå¥½]";
                                                    break;
                                                    case 1010064:
                                                        wep +="AUG-[æ”¹è¿›]";
                                                    break;
                                                    case 1010065:
                                                        wep +="AUG-[ç²¾è‡´]";
                                                    break;
                                                    case 1010066:
                                                        wep +="AUG-[ç‹¬çœ¼è›‡]";
                                                    break;
                                                    case 1010067:
                                                        wep +="AUG-[é’¢é“é˜µçº¿]";
                                                    break;
                                                    
                                                    case 1010071:
                                                        wep +="QBZ-[ç ´æŸ]";
                                                    break;
                                                    case 1010072:
                                                        wep +="QBZ-[ä¿®å¤]";
                                                    break;
                                                    case 1010073:
                                                        wep +="QBZ-[å®Œå¥½]";
                                                    break;
                                                    case 1010074:
                                                        wep +="QBZ-[æ”¹è¿›]";
                                                    break;
                                                    case 1010075:
                                                        wep +="QBZ-[ç²¾è‡´]";
                                                    break;
                                                    case 1010076:
                                                        wep +="QBZ-[ç‹¬çœ¼è›‡]";
                                                    break;
                                                    case 1010077:
                                                        wep +="QBZ-[é’¢é“é˜µçº¿]";
                                                    break;
                                                    
                                                    
                                                    case 1010081:
                                                        wep +="çŒ›ç”·762-[ç ´æŸ]";
                                                    break;
                                                    case 1010082:
                                                        wep +="çŒ›ç”·762-[ä¿®å¤]";
                                                    break;
                                                    case 1010083:
                                                        wep +="çŒ›ç”·762-[å®Œå¥½]";
                                                    break;
                                                    case 1010084:
                                                        wep +="çŒ›ç”·762-[æ”¹è¿›]";
                                                    break;
                                                    case 1010085:
                                                        wep +="çŒ›ç”·762-[ç²¾è‡´]";
                                                    break;
                                                    case 1010086:
                                                        wep +="çŒ›ç”·762-[ç‹¬çœ¼è›‡]";
                                                    break;
                                                    case 1010087:
                                                        wep +="çŒ›ç”·762-[é’¢é“é˜µçº¿]";
                                                    break;
                                                    
                                                    
                                                    
                                                    case 1010091:
                                                        wep +="æ¦´å¼¹åº•åº§-[ç ´æŸ]";
                                                    break;
                                                    case 1010092:
                                                        wep +="æ¦´å¼¹åº•åº§-[ä¿®å¤]";
                                                    break;
                                                    case 1010093:
                                                        wep +="æ¦´å¼¹åº•åº§-[å®Œå¥½]";
                                                    break;
                                                    case 1010094:
                                                        wep +="æ¦´å¼¹åº•åº§-[æ”¹è¿›]";
                                                    break;
                                                    
                                                    
                                                    case 1010101:
                                                        wep +="G36C-[ç ´æŸ]";
                                                    break;
                                                    case 1010102:
                                                        wep +="G36C-[ä¿®å¤]";
                                                    break;
                                                    case 1010103:
                                                        wep +="G36C-[å®Œå¥½]";
                                                    break;
                                                    case 1010104:
                                                        wep +="G36C-[æ”¹è¿›]";
                                                    break;
                                                    case 1010105:
                                                        wep +="G36C-[ç²¾è‡´]";
                                                    break;
                                                    case 1010106:
                                                        wep +="G36C-[ç‹¬çœ¼è›‡]";
                                                    break;
                                                    case 1010107:
                                                        wep +="G36C-[é’¢é“é˜µçº¿]";
                                                    break;
                                                    
                                                    
                                                    
                                                    case 1030021:
                                                        wep +="M24-[ç ´æŸ]";
                                                    break;
                                                    case 1030022:
                                                        wep +="M24-[ä¿®å¤]";
                                                    break;
                                                    case 1030023:
                                                        wep +="M24-[å®Œå¥½]";
                                                    break;
                                                    case 1030024:
                                                        wep +="M24-[æ”¹è¿›]";
                                                    break;
                                                    case 1030025:
                                                        wep +="M24-[ç²¾è‡´]";
                                                    break;
                                                    case 1030026:
                                                        wep +="M24-[ç‹¬çœ¼è›‡]";
                                                    break;
                                                    case 1030027:
                                                        wep +="M24-[é’¢é“é˜µçº¿]";
                                                    break;
                                                    
                                                    case 1030031:
                                                        wep +="AWM-[ç ´æŸ]";
                                                    break;
                                                    case 1030032:
                                                        wep +="AWM-[ä¿®å¤]";
                                                    break;
                                                    case 1030033:
                                                        wep +="AWM-[å®Œå¥½]";
                                                    break;
                                                    case 1030034:
                                                        wep +="AWM-[æ”¹è¿›]";
                                                    break;
                                                    case 1030035:
                                                        wep +="AWM-[ç²¾è‡´]";
                                                    break;
                                                    case 1030036:
                                                        wep +="AWM-[ç‹¬çœ¼è›‡]";
                                                    break;
                                                    case 1030037:
                                                        wep +="AWM-[é’¢é“é˜µçº¿]";
                                                    break;
                                                    
                                                    
                                                    case 1030041:
                                                        wep +="SKS-[ç ´æŸ]";
                                                    break;
                                                    case 1030042:
                                                        wep +="SKS-[ä¿®å¤]";
                                                    break;
                                                    case 1030043:
                                                        wep +="SKS-[å®Œå¥½]";
                                                    break;
                                                    case 1030044:
                                                        wep +="SKS-[æ”¹è¿›]";
                                                    break;
                                                    case 1030045:
                                                        wep +="SKS-[ç²¾è‡´]";
                                                    break;
                                                    case 1030046:
                                                        wep +="SKS-[ç‹¬çœ¼è›‡]";
                                                    break;
                                                    case 1030047:
                                                        wep +="SKS-[é’¢é“é˜µçº¿]";
                                                    break;

                                                    
                                                    case 1010011:
                                                        wep +="AKM-[ç ´æŸ]";
                                                    break;
                                                    case 1010012:
                                                        wep +="AKM-[ä¿®å¤]";
                                                    break;
                                                    case 1010013:
                                                        wep +="AKM-[å®Œå¥½]";
                                                    break;
                                                    case 1010014:
                                                        wep +="AKM-[æ”¹è¿›]";
                                                    break;
                                                    case 1010015:
                                                        wep +="AKM-[ç²¾è‡´]";
                                                    break;
                                                    case 1010016:
                                                        wep +="AKM-[ç‹¬çœ¼è›‡]";
                                                    break;
                                                    case 1010017:
                                                        wep +="AKM-[é’¢é“é˜µçº¿]";
                                                    break;
                                                    
                                                    
                                                    case 1030121:
                                                        wep +="AMR-[ç ´æŸ]";
                                                    break;
                                                    case 1030122:
                                                        wep +="AMR-[ä¿®å¤]";
                                                    break;
                                                    case 1030123:
                                                        wep +="AMR-[å®Œå¥½]";
                                                    break;
                                                    case 1030124:
                                                        wep +="AMR-[æ”¹è¿›]";
                                                    break;
                                                    case 1030125:
                                                        wep +="AMR-[ç²¾è‡´]";
                                                    break;
                                                    case 1030126:
                                                        wep +="AMR-[ç‹¬çœ¼è›‡]";
                                                    break;
                                                    case 1030127:
                                                        wep +="AMR-[é’¢é“é˜µçº¿]";
                                                    break;
                                                    
                                                    
                                                    case 1010121:
                                                        wep +="èœœç¾çªå‡»æ­¥æª-[ç ´æŸ]";
                                                    break;
                                                    case 1010122:
                                                        wep +="èœœç¾çªå‡»æ­¥æª-[ä¿®å¤]";
                                                    break;
                                                    case 1010123:
                                                        wep +="èœœç¾çªå‡»æ­¥æª-[å®Œå¥½]";
                                                    break;
                                                    case 1010124:
                                                        wep +="èœœç¾çªå‡»æ­¥æª-[æ”¹è¿›]";
                                                    break;
                                                    case 1010125:
                                                        wep +="èœœç¾çªå‡»æ­¥æª-[ç²¾è‡´]";
                                                    break;
                                                    case 1010126:
                                                        wep +="èœœç¾çªå‡»æ­¥æª-[ç‹¬çœ¼è›‡]";
                                                    break;
                                                    case 1010127:
                                                        wep +="èœœç¾çªå‡»æ­¥æª-[é’¢é“é˜µçº¿]";
                                                    break;
                                                    
                                                    
                                                    


                                                    
                                                    
                                                default:
                                                wep +="æœªæ”¶å½• ID: [";
                                                wep += wppp;
                                                wep +="]";
                                                
                                                
                                                    break;
                                            }*/
                                            
                                        
                                   wep += "[";
                                   
                                   wep += std::to_string((int)å½“å‰å­å¼¹);
                                   wep += "/";
                                   wep += std::to_string((int)æœ€å¤§å­å¼¹);
                                   wep += "]";


                               
                                
                                 float boxWidth = density / 1.8f;
                                boxWidth -= std::min(((boxWidth / 2) / 00.0f) * Distance,
                                                     boxWidth / 2);
                                float boxHeight = boxWidth * 0.19f;
                
                            auto textSize = ImGui::CalcTextSize2(wep.c_str(), 0, ((float) density / 28.0f));
                            ç»˜åˆ¶åŠ ç²—æ–‡æœ¬2(19,HeadPosSC.x - (boxWidth / 3)  -60,HeadPosSC.y - 120,ç™½è‰²,é»„è‰²,wep.c_str());
                 
                             }
                           }
                           
                          
                         }
                         
                         }
						

						
						
                        int PSkeleton =  IM_COL32( 255, 255, 255, 255 );
                        int PSkeleton2 =  IM_COL32( 255, 255, 000, 255 );
						int	SCOLOR2 =  IM_COL32( 000, 255, 000, 255 );
				        int SCOLOR = IM_COL32( 255, 000, 000, 255 );
						if (Config.PlayerESP.Skeleton) {
                                float boxWidth = 7.f - Distance * 0.05;
                        
                        
                        if (Player->bIsAI) {
                        
                        if(!localController->LineOfSightTo(localController->PlayerCameraManager, neck_01, false))
						{
						

						draw->AddLine( { upper_rPoSC.x, upper_rPoSC.y }, neck_01PoSC, PSkeleton2,1.0f );
						}else
						draw->AddLine( { upper_rPoSC.x, upper_rPoSC.y }, neck_01PoSC, PSkeleton,1.0f );
						
						if(!localController->LineOfSightTo(localController->PlayerCameraManager, neck_01, false))
						{
						

						draw->AddLine( { upper_lPoSC.x, upper_lPoSC.y }, neck_01PoSC, PSkeleton2,1.0f );
						}else
						draw->AddLine( { upper_lPoSC.x, upper_lPoSC.y }, neck_01PoSC, PSkeleton,1.0f );
						
						if(!localController->LineOfSightTo(localController->PlayerCameraManager, lowerarm_r, false))
						{
						

						draw->AddLine( { upper_rPoSC.x, upper_rPoSC.y }, lowerarm_rPoSC,PSkeleton2, 1.0f );
						}else
						draw->AddLine( { upper_rPoSC.x, upper_rPoSC.y }, lowerarm_rPoSC,PSkeleton, 1.0f );
						
						if(!localController->LineOfSightTo(localController->PlayerCameraManager, hand_r, false))
						{
						

						draw->AddLine( { lowerarm_rPoSC.x, lowerarm_rPoSC.y }, hand_rPoSC,PSkeleton2, 1.0f );
						}else
						draw->AddLine( { lowerarm_rPoSC.x, lowerarm_rPoSC.y }, hand_rPoSC,PSkeleton, 1.0f );
						
						if(!localController->LineOfSightTo(localController->PlayerCameraManager, lowerarm_r, false))
						{
						

						draw->AddLine( { upper_lPoSC.x, upper_lPoSC.y }, lowerarm_lSC, PSkeleton2,1.0f );
						}else
						draw->AddLine( { upper_lPoSC.x, upper_lPoSC.y }, lowerarm_lSC, PSkeleton,1.0f );
						
						if(!localController->LineOfSightTo(localController->PlayerCameraManager, hand_l, false))
						{
						
						
						draw->AddLine( { lowerarm_lSC.x, lowerarm_lSC.y }, hand_lPoSC, PSkeleton2,1.0f );
						}else
						draw->AddLine( { lowerarm_lSC.x, lowerarm_lSC.y }, hand_lPoSC, PSkeleton,1.0f );
						
						if(!localController->LineOfSightTo(localController->PlayerCameraManager, thigh_l, false))
						{
						
						
						draw->AddLine( { thigh_rPoSC.x, thigh_rPoSC.y }, thigh_lPoSC, PSkeleton2,1.0f );
						}else
						draw->AddLine( { thigh_rPoSC.x, thigh_rPoSC.y }, thigh_lPoSC, PSkeleton,1.0f );
						
						if(!localController->LineOfSightTo(localController->PlayerCameraManager, calf_l, false))
						{
						
						
						draw->AddLine( { thigh_lPoSC.x, thigh_lPoSC.y }, calf_lPoSC, PSkeleton2,1.0f );
						}else
						draw->AddLine( { thigh_lPoSC.x, thigh_lPoSC.y }, calf_lPoSC, PSkeleton,1.0f );
						
						if(!localController->LineOfSightTo(localController->PlayerCameraManager, foot_l, false))
						{
						
						
						draw->AddLine( { calf_lPoSC.x, calf_lPoSC.y }, foot_lPoSC, PSkeleton2,1.0f );
						}else
						draw->AddLine( { calf_lPoSC.x, calf_lPoSC.y }, foot_lPoSC, PSkeleton,1.0f );
					    
						if(!localController->LineOfSightTo(localController->PlayerCameraManager, calf_r, false))
						{
						
						
						draw->AddLine( { thigh_rPoSC.x, thigh_rPoSC.y }, calf_rPoSC, PSkeleton2,1.0f );
						}else
						draw->AddLine( { thigh_rPoSC.x, thigh_rPoSC.y }, calf_rPoSC, PSkeleton,1.0f );
						
						if(!localController->LineOfSightTo(localController->PlayerCameraManager, foot_r, false))
						{
						
						
						draw->AddLine( { calf_rPoSC.x, calf_rPoSC.y }, foot_rPoSC, PSkeleton2,1.0f );
						}else
						draw->AddLine( { calf_rPoSC.x, calf_rPoSC.y }, foot_rPoSC, PSkeleton,1.0f );
						
						
						if(!localController->LineOfSightTo(localController->PlayerCameraManager, pelvis, false))
						{
						
						
						draw->AddLine( { neck_01PoSC.x, neck_01PoSC.y }, pelvisPoSC, PSkeleton2,1.0f );
						}else
						draw->AddLine( { neck_01PoSC.x, neck_01PoSC.y }, pelvisPoSC, PSkeleton,1.0f );
						
						
						if(!localController->LineOfSightTo(localController->PlayerCameraManager, HeadPos, false))
						{
						
						
						draw->AddLine( { neck_01PoSC.x, neck_01PoSC.y }, HeadPosSC, PSkeleton2,1.0f );
						}else
						
						draw->AddLine( { neck_01PoSC.x, neck_01PoSC.y }, HeadPosSC, PSkeleton,1.0f );
                        
                        
                        } else {
				        if(!localController->LineOfSightTo(localController->PlayerCameraManager, neck_01, false))
						{
						

						draw->AddLine( { upper_rPoSC.x, upper_rPoSC.y }, neck_01PoSC, SCOLOR2,1.0f );
						}else
						draw->AddLine( { upper_rPoSC.x, upper_rPoSC.y }, neck_01PoSC, SCOLOR,1.0f );
						
						if(!localController->LineOfSightTo(localController->PlayerCameraManager, neck_01, false))
						{
						

						draw->AddLine( { upper_lPoSC.x, upper_lPoSC.y }, neck_01PoSC, SCOLOR2,1.0f );
						}else
						draw->AddLine( { upper_lPoSC.x, upper_lPoSC.y }, neck_01PoSC, SCOLOR,1.0f );
						
						if(!localController->LineOfSightTo(localController->PlayerCameraManager, lowerarm_r, false))
						{
						

						draw->AddLine( { upper_rPoSC.x, upper_rPoSC.y }, lowerarm_rPoSC,SCOLOR2, 1.0f );
						}else
						draw->AddLine( { upper_rPoSC.x, upper_rPoSC.y }, lowerarm_rPoSC,SCOLOR, 1.0f );
						
						
						if(!localController->LineOfSightTo(localController->PlayerCameraManager, hand_r, false))
						{
						

						draw->AddLine( { lowerarm_rPoSC.x, lowerarm_rPoSC.y }, hand_rPoSC,SCOLOR2, 1.0f );
						}else
						draw->AddLine( { lowerarm_rPoSC.x, lowerarm_rPoSC.y }, hand_rPoSC,SCOLOR, 1.0f );
						
						if(!localController->LineOfSightTo(localController->PlayerCameraManager, lowerarm_r, false))
						{
						

						draw->AddLine( { upper_lPoSC.x, upper_lPoSC.y }, lowerarm_lSC, SCOLOR2,1.0f );
						}else
						draw->AddLine( { upper_lPoSC.x, upper_lPoSC.y }, lowerarm_lSC, SCOLOR,1.0f );
						
						if(!localController->LineOfSightTo(localController->PlayerCameraManager, hand_l, false))
						{
						
						
						draw->AddLine( { lowerarm_lSC.x, lowerarm_lSC.y }, hand_lPoSC, SCOLOR2,1.0f );
						}else
						draw->AddLine( { lowerarm_lSC.x, lowerarm_lSC.y }, hand_lPoSC, SCOLOR,1.0f );
						
						if(!localController->LineOfSightTo(localController->PlayerCameraManager, thigh_l, false))
						{
						
						
						draw->AddLine( { thigh_rPoSC.x, thigh_rPoSC.y }, thigh_lPoSC, SCOLOR2,1.0f );
						}else
						draw->AddLine( { thigh_rPoSC.x, thigh_rPoSC.y }, thigh_lPoSC, SCOLOR,1.0f );
						
						if(!localController->LineOfSightTo(localController->PlayerCameraManager, calf_l, false))
						{
						
						
						draw->AddLine( { thigh_lPoSC.x, thigh_lPoSC.y }, calf_lPoSC, SCOLOR2,1.0f );
						}else
						draw->AddLine( { thigh_lPoSC.x, thigh_lPoSC.y }, calf_lPoSC, SCOLOR,1.0f );
						
						if(!localController->LineOfSightTo(localController->PlayerCameraManager, foot_l, false))
						{
						
						
						draw->AddLine( { calf_lPoSC.x, calf_lPoSC.y }, foot_lPoSC, SCOLOR2,1.0f );
						}else
						draw->AddLine( { calf_lPoSC.x, calf_lPoSC.y }, foot_lPoSC, SCOLOR,1.0f );
					    
						if(!localController->LineOfSightTo(localController->PlayerCameraManager, calf_r, false))
						{
						
						
						draw->AddLine( { thigh_rPoSC.x, thigh_rPoSC.y }, calf_rPoSC, SCOLOR2,1.0f );
						}else
						draw->AddLine( { thigh_rPoSC.x, thigh_rPoSC.y }, calf_rPoSC, SCOLOR,1.0f );
						
						if(!localController->LineOfSightTo(localController->PlayerCameraManager, foot_r, false))
						{
						
						
						draw->AddLine( { calf_rPoSC.x, calf_rPoSC.y }, foot_rPoSC, SCOLOR2,1.0f );
						}else
						draw->AddLine( { calf_rPoSC.x, calf_rPoSC.y }, foot_rPoSC, SCOLOR,1.0f );
						
						
						if(!localController->LineOfSightTo(localController->PlayerCameraManager, pelvis, false))
						{
						
						
						draw->AddLine( { neck_01PoSC.x, neck_01PoSC.y }, pelvisPoSC, SCOLOR2,1.0f );
						}else
						draw->AddLine( { neck_01PoSC.x, neck_01PoSC.y }, pelvisPoSC, SCOLOR,1.0f );
						
						
						if(!localController->LineOfSightTo(localController->PlayerCameraManager, HeadPos, false))
						{
						
						
						draw->AddLine( { neck_01PoSC.x, neck_01PoSC.y }, HeadPosSC, SCOLOR2,1.0f );
						}else
						
						draw->AddLine( { neck_01PoSC.x, neck_01PoSC.y }, HeadPosSC, SCOLOR,1.0f );
					}}
					    
					    
					    
					    if (Config.PlayerESP.Box) {
					    
					    if (è§¦æ‘¸å¯¹è±¡é˜Ÿä¼ == Player->TeamID) {
				
		
								float boxHeight = abs(HeadPosSC.y - RootPosSC.y);
								float boxWidth = boxHeight * 0.65f;
								ImVec2 vStart = {HeadPosSC.x - (boxWidth / 2), HeadPosSC.y};
								ImVec2 vEnd = {vStart.x + boxWidth, vStart.y + boxHeight};
								draw->AddRect(vStart, vEnd, IM_COL32(255,255,0,255), 1.0f);
							} else {
							float boxHeight = abs(HeadPosSC.y - RootPosSC.y);
								float boxWidth = boxHeight * 0.65f;
								ImVec2 vStart = {HeadPosSC.x - (boxWidth / 2), HeadPosSC.y};
								ImVec2 vEnd = {vStart.x + boxWidth, vStart.y + boxHeight};
								draw->AddRect(vStart, vEnd, PBox, 0.8f);
							}}
							



							
							
							        if (Config.PlayerESP.Health) {
                                int CurHP = (int) std::max(0, std::min((int) Player->Health,
                                                                       (int) Player->HealthMax));
                                int MaxHP = (int) Player->HealthMax;

                                long HPColor = IM_COL32(
                                        std::min(((510 * (MaxHP - CurHP)) / MaxHP), 255),
                                        std::min((510 * CurHP) / MaxHP, 255), 0, 155);

                                if (Player->Health == 0.0f && !Player->bDead) {
                                    HPColor = IM_COL32(255, 0, 0, 155);

                                    CurHP = Player->NearDeathBreath;
                                    if (Player->NearDeatchComponent) {
                                        MaxHP = Player->NearDeatchComponent->BreathMax;
                                    }
                                }

                                float boxWidth = density / 1.6f;
                                boxWidth -= std::min(((boxWidth / 2) / 00.0f) * Distance,
                                                     boxWidth / 2);
                                float boxHeight = boxWidth * 0.07f;


                                ImVec2 vStart = {HeadPosSC.x - (boxWidth / 2),
                                                 HeadPosSC.y - (boxHeight * 1.9f)};

                                ImVec2 vEndFilled = {vStart.x + (CurHP * boxWidth / MaxHP),
                                                     vStart.y + boxHeight};
                                ImVec2 vEndRect = {vStart.x + boxWidth, vStart.y + boxHeight};

                                draw->AddRectFilled(vStart, vEndFilled, HPColor);
                                draw->AddRect(vStart, vEndRect, IM_COL32(0, 0, 0, 155));
                            }
                            

                                               if (Config.PlayerESP.Health) {
                            int CurHP = (int) std::max(0, std::min((int) Player->Health, (int) Player->HealthMax));
                            int MaxHP = (int) Player->HealthMax;
                            long HPColor = IM_COL32(
                            std::min(((510 * (MaxHP - CurHP)) / MaxHP), 255), std::min((510 * CurHP) / MaxHP, 255), 0, 155);
                            if (Player->Health == 0.0f && !Player->bDead) {
                                HPColor = IM_COL32(255, 0, 0, 155);
                                CurHP = Player->NearDeathBreath;
                                if (Player->NearDeatchComponent) {
                                    MaxHP = Player->NearDeatchComponent->BreathMax;
                                }
                            }
                           // float boxWidth = density / 1.9f;
                            float boxWidth = density / 1.6f; //Panjang
                            boxWidth -= std::min(((boxWidth / 2) / 00.0f) * Distance, boxWidth / 2);
                            float boxHeight = boxWidth * 0.05f; //ori 0.02 //0.05
                            ImVec2 vStart = {HeadPosSC.x - (boxWidth / 2), HeadPosSC.y - (boxHeight * 2.1f)}; //ori 7,9 //2.1
                            ImVec2 vEndFilled = {vStart.x + (CurHP * boxWidth / MaxHP),  vStart.y + boxHeight};
                            ImVec2 vEndRect = {vStart.x + boxWidth, vStart.y + boxHeight};
                            draw->AddRectFilled(vStart, vEndFilled, HPColor);
							draw->AddRect(vStart, vEndRect,HPColor);
                          //  draw->AddRect(vStart, vEndRect, IM_COL32(0, 0, 0, 155));
                        }///è¡€é‡æ˜¾ç¤º
                        
                        

                        

                         if (Config.PlayerESP.Name) {
                            float boxWidth = density / 1.6f;
                            boxWidth -= std::min(((boxWidth / 2) / 00.0f) * Distance, boxWidth / 2);
                            float boxHeight = boxWidth * 0.11f;
                            ImVec2 vStart = {HeadPosSC.x - (boxWidth / 2), HeadPosSC.y - (boxHeight * 2.1f)}; //1.60
                            ImVec2 vEndRect = {vStart.x + boxWidth, vStart.y + boxHeight};
                            draw->AddRectFilled(vStart, vEndRect, GetRandomColorByIndex(Player->TeamID));				
                        }
                        
                       
                         if (Config.PlayerESP.TeamID) {
                         
                         
                                float boxWidth = density / 1.9f;
                            boxWidth -= std::min(((boxWidth / 2) / 00.0f) * Distance, boxWidth / 2);
                            float boxHeight = boxWidth * 0.15f;
                            std::string s;
                            
                            if (Player->bIsAI)
                                s +="NO";//äººæœºé˜Ÿä¼ID
                                else
                            /*
                            if(Player->TeamID == 996)
                                s +="";//äººæœºé˜Ÿä¼ID
                                else*/
                            s += std::to_string(Player->TeamID);
                            if (Player->bIsAI) {    
                            draw->AddText(NULL, ((float) density / 28.0f), {HeadPosSC.x - (boxWidth / 2), HeadPosSC.y - (boxHeight * 1.80f)}, IM_COL32(255, 255, 255, 255), s.c_str());
                            } else {
                            draw->AddText(NULL, ((float) density / 28.0f), {HeadPosSC.x - (boxWidth / 2), HeadPosSC.y - (boxHeight * 1.80f)}, IM_COL32(255, 255, 0, 255), s.c_str());
                            }
                        }
                         if (Config.PlayerESP.Name) {
                            float boxWidth = density / 1.8f;
                                boxWidth -= std::min(((boxWidth / 2) / 00.0f) * Distance,
                                                     boxWidth / 2);
                                float boxHeight = boxWidth * 0.19f;


                                std::string s;
                                if (Player->bIsAI) {
                                    s += "  BOT ";
                                    s += Player->PlayerName.ToString();
                                } else {
                                    s += Player->PlayerName.ToString();
                                }
                                if (Player->bIsAI) {
                                draw->AddText(NULL, ((float) density / 30.0f),
                                              {HeadPosSC.x - (boxWidth / 3),
                                               HeadPosSC.y - (boxHeight * 1.33f)},
                                              IM_COL32(255, 255, 255, 255), s.c_str());
} else {
draw->AddText(NULL, ((float) density / 30.0f),
                                              {HeadPosSC.x - (boxWidth / 3),
                                               HeadPosSC.y - (boxHeight * 1.33f)},
                                              IM_COL32(255, 255, 0, 255), s.c_str());
}
                            }

                        if (Config.PlayerESP.Distance) {
                            float boxWidth = density / 1.9f;
                            boxWidth -= std::min(((boxWidth / 2) / 00.0f) * Distance, boxWidth / 2);
                            float boxHeight = boxWidth * 0.15f;
                            std::string s;
                            s += std::to_string((int) Distance);
                            s += "ç±³";
                            if (Player->bIsAI) {
                            draw->AddText(NULL, ((float) density / 28.0f), {HeadPosSC.x + (boxWidth / 3), HeadPosSC.y - (boxHeight * 1.85f)}, IM_COL32(255, 255, 255, 255), s.c_str());
                            } else {
                            draw->AddText(NULL, ((float) density / 28.0f), {HeadPosSC.x + (boxWidth / 3), HeadPosSC.y - (boxHeight * 1.85f)}, IM_COL32(255, 255, 0, 255), s.c_str());
                            }
                        }
 
						  FVector2D screen (glWidth, glHeight);
                            int borders = isOutsideSafezone(location, screen);
							if (Config.PlayerESP.Alert360 && borders != 0) {
								float Distance = localPlayer->GetDistanceTo(Player) / 100.0f;
								std::string s;
								s += std::to_string((int)Distance);
								s += "M";
								float mScale = glHeight / (float) 1080;
								auto hintDotRenderPos = pushToScreenBorder(location, screen, borders, (int)((mScale * 100) / 3));
								auto hintTextRenderPos = pushToScreenBorder(location, screen, borders, -(int)((mScale * 36)));
								draw->AddCircleFilled(ImVec2(hintDotRenderPos.X, hintDotRenderPos.Y), mScale * 100, IM_COL32(255, 0, 0, 128), 0);
								draw->AddText(NULL, ((float)density / 20.0f), ImVec2(hintTextRenderPos.X, hintTextRenderPos.Y), IM_COL32(255, 255, 255, 255), s.c_str());
							}
                            
					     }
					}					
        
        
        
        if (Config.PlayerESP.LootBox) {
                            if (Actors[i]->IsA(APickUpListWrapperActor::StaticClass())) {
                            auto DeadBox = (APickUpListWrapperActor *) Actors[i];
                            auto RootComponent = DeadBox->RootComponent;
                            if (!RootComponent)
                            continue;
                            float Distance = DeadBox->GetDistanceTo(localPlayer) / 100.0f;
                            FVector2D DeadBoxPos;
                            if (W2S(DeadBox->K2_GetActorLocation(), &DeadBoxPos)) {
                            std::string s = "";
                            s += "";
                            s += std::to_string((int) Distance);
                            s += "";
                            draw->AddText(NULL, ((float) density / 30.0f), {DeadBoxPos.X, DeadBoxPos.Y}, IM_COL32(255, 000, 000, 255), s.c_str());
                            FVector BoxSize;
                            BoxSize.X = 80.f; // Height
                            BoxSize.Y = 95.f; // Front
                            BoxSize.Z = 50.f; // Height
                            Box3D(draw, DeadBox->K2_GetActorLocation(), BoxSize, IM_COL32(255, 000, 000, 255));
                        
                                                
                                            }

                            }
                            }
																	
		if (Config.PlayerESP.LootBox) {
                    if (Actors[i]->IsA(APickUpListWrapperActor::StaticClass())) {
						auto Pick = (APickUpListWrapperActor *) Actors[i];
					    if (!Pick->RootComponent)
						continue;
						auto PickUpDataList = (TArray<FPickUpItemData>)Pick->GetDataList();
						float Distance = Pick->GetDistanceTo(localPlayer) / 100.f;
						FVector2D PickUpListsPos;
						FVector origin, extends;
						if (W2S(Pick->K2_GetActorLocation(), & PickUpListsPos)) {
						std::string s = "ç›’å­";//ICON_FA_DROPBOX
						s += "[";
						s += std::to_string((int) Distance);
						s += "M]";
						draw->AddText(NULL, ((float) density / 30.0f), {PickUpListsPos.X, PickUpListsPos.Y}, IM_COL32(255, 255, 255, 255), s.c_str());
						if (Distance < 100.0f) {
			
						if (Config.ç‰©èµ„ || Config.ç‰©èµ„1) {
						
						auto mWidthScale = std::min(0.1f * Distance, 35.f);
						auto boxWidth = 75.f - mWidthScale;
						auto boxHeight = boxWidth * 0.120f;
						Rect PlayerRect(PickUpListsPos.X - (boxWidth / 2), PickUpListsPos.Y, boxWidth, boxHeight);
						float posY = PickUpListsPos.Y - (PlayerRect.height * 1.00f);
						for (int j = 0; j < PickUpDataList.Num(); j++) {
						std::vector<std::string> s2;
						std::string itm;
						uint32_t tc = 0xFF000000;
						if (Config.ç‰©èµ„) {
						for (auto & category : items_datakl) {
						for (auto & item : category["Items"]) {
						if (item["itemId"] == PickUpDataList[j].ID.TypeSpecificID) {
						tc = strtoul(item["itemTextColor"].get<std::string>().c_str(), 0, 16);
						itm += item["itemName"].get<std::string>();
						s2.push_back(itm);
						break;
						}
					    }
					    }}
					    if (Config.ç‰©èµ„1) {
						for (auto & category : itemss_datakl) {
						for (auto & item : category["Items"]) {
						if (item["itemId"] == PickUpDataList[j].ID.TypeSpecificID) {
						tc = strtoul(item["itemTextColor"].get<std::string>().c_str(), 0, 16);
						itm += item["itemName"].get<std::string>();
						s2.push_back(itm);
						break;
						}
					    }
					    }}
						if (!s2.empty())  {
						if (PickUpDataList[j].Count > 1) {
					    s2.push_back(" * ");
						s2.push_back(std::to_string(PickUpDataList[j].Count));
					    }
						std::string s3;
						for (auto & s4 : s2)   {
						s3 += s4;
						}
						draw->AddText(NULL, ((float) density / 30.0f), {PickUpListsPos.X, posY}, tc, s3.c_str());
						posY -= PlayerRect.height * 1.00f;
						}
					}
				
			}}
		}
	}
}
                        if (Config.PlayerESP.Grenade) {
                   if (Actors[i]->IsA(ASTExtraGrenadeBase::StaticClass())) {
                      auto Grenade = (ASTExtraGrenadeBase *) Actors[i];
                      
                         auto RootComponent = Grenade->RootComponent;
                            if (!RootComponent)
                                continue;
                                
                            float Distance =
                                    Grenade->GetDistanceTo(localPlayer) / 100.f;
                            if (Distance > 50.0f) {
							
								draw->AddText(nullptr, ((float) density / 10.5f),
                                  ImVec2(glWidth / 2 - 225, 120), IM_COL32(255, 0, 0, 255),
                                  "!!å°å¿ƒé™„è¿‘æŠ•æ·ç‰©!!");
                                  }
                          FVector2D GrenadePos;
                        if (W2S(Grenade->K2_GetActorLocation(), &GrenadePos)) {
                            std::string s = "æŠ•æ·ç‰©";
                            s += "[";
                            s += std::to_string((int) Distance);
                            s += "ç±³]";
                                       
                            draw->AddText(NULL, ((float) density / 25.0f), {GrenadePos.X, GrenadePos.Y}, IM_COL32(255, 0, 0, 255), s.c_str());

                                   }
                                
                            }
                       }
                       
                       
                       
                       if (ç©ºæŠ•) {
                    if (Actors[i]->IsA(AAirDropBoxActor::StaticClass())) {
                        auto DropBox = (AAirDropBoxActor *) Actors[i];

                        auto RootComponent = DropBox->RootComponent;
                        if (!RootComponent)
                            continue;
                        float Distance = DropBox->GetDistanceTo(localPlayer) / 100.f;
                        FVector2D DropBoxPos;
                        if (W2S(DropBox->K2_GetActorLocation(), &DropBoxPos)) {
                            std::string s = "ç©ºæŠ•";
                            s += " [";
                            s += std::to_string((int) Distance);
                            s += "ç±³]";
                            draw->AddText(NULL, ((float) density / 25.0f), {DropBoxPos.X, DropBoxPos.Y}, IM_COL32(255, 255, 255, 255), s.c_str());

                        }
                    }
                }
                       
if (åŠ é€Ÿå¼€) {
g_LocalPlayer->STPlayerController->AcknowledgedPawn->CustomTimeDilation = 4.0f;
}

                       
                       if (é£æœº) {
                    if (Actors[i]->IsA(AAirDropPlane::StaticClass())) {
                        auto AirDropPlane = (AAirDropPlane *) Actors[i];

                        auto RootComponent = AirDropPlane->RootComponent;
                        if (!RootComponent)
                            continue;
                        float Distance = AirDropPlane->GetDistanceTo(localPlayer) / 100.f;
                        FVector2D AirDropPlanePos;
                        if (W2S(AirDropPlane->K2_GetActorLocation(), &AirDropPlanePos)) {
                            std::string s = "é£æœº";
                            s += " [";
                            s += std::to_string((int) Distance);
                            s += "ç±³]";
                            draw->AddText(NULL, ((float) density / 25.0f), {AirDropPlanePos.X, AirDropPlanePos.Y}, IM_COL32(255, 255, 255, 255), s.c_str());

                        }
                    }
                }
             /*          //è‡ªåŠ¨å¼€ç«

if (Config.è‡ªåŠ¨å¼€ç«ON) {
                   if (!localController->LineOfSightTo(Actor, {0, 0, 0}, true)) {
                    g_LocalController->bIsPressingFireBtn = false;
                         }else{
                    g_LocalController->bIsPressingFireBtn = true;
                   }
                   }*/
                       

                     
                       
             
                       
					if (Config.PlayerESP.Vehicle)
					{
						if (Actors[i]->IsA(ASTExtraVehicleBase::StaticClass()))
						{
							auto Vehicle = (ASTExtraVehicleBase *)Actors[i];
							if (!Vehicle->Mesh)
								continue;
							int CurHP = (int) std::max(0, std::min((int) Vehicle->VehicleCommon->HP, (int) Vehicle->VehicleCommon->HPMax));
                            int MaxHP = (int) Vehicle->VehicleCommon->HPMax;
                            long curHP_Color = IM_COL32(std::min(((510 * (MaxHP - CurHP)) / MaxHP), 255), std::min(((510 * CurHP) / MaxHP), 255), 0, 155);
							float Distance = Vehicle->GetDistanceTo(localPlayer) / 100.f;
							FVector2D vehiclePos;
							if (W2S(Vehicle->K2_GetActorLocation(), &vehiclePos))
							{
								auto mWidthScale = std::min(0.10f * Distance, 50.f);
								auto mWidth = 70.f - mWidthScale;
								auto mHeight = mWidth * 0.15f;
									std::string s = GetVehicleName(Vehicle);
				     				s += " ";
						    		s += std::to_string((int)Distance);
					    			s += "ç±³";
				     	    		draw->AddText(NULL, ((float)density / 30.0f), {vehiclePos.X - (mWidth / 2), vehiclePos.Y}, ToColor(Config.ColorsESP.Vehicle), s.c_str());
									std::string sf;
						    		sf += "æ²¹é‡:";
			                        sf += std::to_string((int)(100 * Vehicle->VehicleCommon->Fuel / Vehicle->VehicleCommon->FuelMax));
                                    sf += "";
		    	    		    	draw->AddText(NULL, ((float)density / 30.0f), {vehiclePos.X - (mWidth / 2), vehiclePos.Y + 15.f}, IM_COL32(255, 255, 255, 255), sf.c_str());
                                    ImVec2 vStart = {vehiclePos.X - (mWidth / 2), vehiclePos.Y - (mHeight * 1.5f)};
                                    ImVec2 vEndFilled = {vStart.x + (CurHP * mWidth / MaxHP), vStart.y + mHeight};
                                    ImVec2 vEndRect = {vStart.x + mWidth, vStart.y + mHeight};
                                    draw->AddRectFilled(vStart, vEndFilled, curHP_Color, 3.2f, 240);
                                    draw->AddRect(vStart, vEndRect, IM_COL32(255, 255, 255, 255), 3.2f, 240);
							}
						}
					}
					
					
/*					if (Actors[i]->IsA(APickUpWrapperActor::StaticClass()))
					{
						auto PickUp = (APickUpWrapperActor *)Actors[i];
						if (Items[PickUp->DefineID.TypeSpecificID])
						{
							auto RootComponent = PickUp->RootComponent;
							if (!RootComponent)
								continue;
							float Distance = PickUp->GetDistanceTo(localPlayer) / 100.f;
							FVector2D itemPos;
							if (W2S(PickUp->K2_GetActorLocation(), &itemPos))
							{
								std::string s;
								uint32_t tc = 0xFF000000;
								for (auto &category : items_datakl)
								{
									for (auto &item : category["Items"])
									{
										if (item["itemId"] == PickUp->DefineID.TypeSpecificID)
										{
											s = item["itemName"].get<std::string>();
											break;
										}
									}
								}
								for (auto &category : itemss_datakl)
								{
									for (auto &item : category["Items"])
									{
										if (item["itemId"] == PickUp->DefineID.TypeSpecificID)
										{
											s = item["itemName"].get<std::string>();
											break;
										}
									}
								}
								s += " è·ç¦»ä½ :";
								s += std::to_string((int)Distance);
								s += "ç±³";
								draw->AddText(NULL, ((float)density / 25.0f), {itemPos.X, itemPos.Y}, ToColor(Config.ColorsESP.Items), s.c_str());
							}
						}
					}*/
				}
			}
		}

    
                 
/*
     ImGui::GetForegroundDrawList()->AddRectFilled({glWidth /2-50,40},{glWidth /2,80},ImColor(255, 0, 0,100));
       ImGui::GetForegroundDrawList()->AddRectFilled({glWidth /2+50,40},{glWidth /2,80},ImColor(3, 255, 40,100)); 
       sprintf(extra, "%d", totalEnemies);
       ImGui::GetForegroundDrawList()->AddText({glWidth /2-35,45}, ImColor(255,255,255), extra);
       sprintf(extra, "%d", totalBots);
      ImGui::GetForegroundDrawList()->AddText({glWidth /2+15,45}, ImColor(255,255,255), extra);*/
      
      
      
      //äººæ•°æ˜¾ç¤º  NIKE PLUS
      g_LocalController = localController;
       g_LocalPlayer = localPlayer;
     
         if (totalEnemies == 0 && totalBots == 0) {
         Drive = false;
         } else {
         Drive = true;
         }
				
    int TotalCount = totalEnemies;
       ImGui::GetForegroundDrawList()->AddRectFilled({glWidth /2-100,40},{glWidth /2-50,80},ImColor(0, 0, 0, 255));
       ImGui::GetForegroundDrawList()->AddRectFilled({glWidth /2-50,40},{glWidth /2,80},ImColor(255, 0, 0, 255));
       ImGui::GetForegroundDrawList()->AddRectFilled({glWidth /2+50,40},{glWidth /2,80},ImColor(0, 255, 0, 255)); 
       ImGui::GetForegroundDrawList()->AddRectFilled({glWidth /2+100,40},{glWidth /2+50,80},ImColor(255, 255, 0, 255));
       
       sprintf(extra, "%d", oozing);
       ImGui::GetForegroundDrawList()->AddText({glWidth /2-85,45}, ImColor(255,255,255), extra);
       sprintf(extra, "%d", totalEnemies);
       ImGui::GetForegroundDrawList()->AddText({glWidth /2-35,45}, ImColor(255,255,255), extra);
       sprintf(extra, "%d", totalBots);
      ImGui::GetForegroundDrawList()->AddText({glWidth /2+15,45}, ImColor(255,255,255), extra);
      sprintf(extra, "%d", totalBots + totalEnemies);
      ImGui::GetForegroundDrawList()->AddText({glWidth /2+65,45}, ImColor(0,0,0), extra);
      
      
		fps.update();
	}
	}
	
	










// ======================================================================== //
/*
style->ScrollbarRounding = 0.2f;
//æ»‘åŠ¨æ¡å¤§å°
style->ScrollbarSize *= 0.5f;
//çª—ä½“è¾¹æ¡†åœ†è§’
style->WindowRounding = 2.0f;
//æ¡†æ¶åœ†è§’
style->FrameRounding = 1.0f;
//æ¡†æ¶è¾¹ç•Œå¤§å°
style->FrameBorderSize = 0.0f;
//ä¸»é¢˜è¾¹ç•Œå¤§å°
style->WindowBorderSize = 0.0f;
//æœªçŸ¥ è¾¹ç•Œå¤§å°
style->ChildBorderSize = 0.0f;
//é€‰é¡¹å¡åœ†è§’
style->TabRounding = 1.0f;
*/

///>/>NIKE UI AIDE Cï¼‹ï¼‹ imgui
#define IM_CLAMP(V, MN, MX)     ((V) < (MN) ? (MN) : (V) > (MX) ? (MX) : (V))
namespace Settings
{
static int Tab = 1;
}
EGLBoolean (*orig_eglSwapBuffers)(EGLDisplay dpy, EGLSurface surface);
EGLBoolean _eglSwapBuffers(EGLDisplay dpy, EGLSurface surface)
{
	eglQuerySurface(dpy, surface, EGL_WIDTH, &glWidth);
	eglQuerySurface(dpy, surface, EGL_HEIGHT, &glHeight);
	if (glWidth <= 0 || glHeight <= 0)
		return orig_eglSwapBuffers(dpy, surface);

	if (!g_App)
		return orig_eglSwapBuffers(dpy, surface);

	screenWidth = ANativeWindow_getWidth(g_App->window);
	screenHeight = ANativeWindow_getHeight(g_App->window);
	density = AConfiguration_getDensity(g_App->config);
  if (!initImGui) {
        ImGui::CreateContext();
        

        ImGuiStyle& style = ImGui::GetStyle();
				  
				//  style.FrameBorderSize = 1.5f;
		
        

             ImGui::StyleColorsLight();
         style.ScaleAllSizes(std::max(2.5f, density / 400.0f));
          style.ScrollbarSize *= 1.0f;

        
            ImGui_ImplAndroid_Init();
            ImGui_ImplOpenGL3_Init("#version 300 es");

            ImGuiIO &io = ImGui::GetIO();

            io.ConfigWindowsMoveFromTitleBarOnly = true;
            io.IniFilename = NULL;

            static const ImWchar icons_ranges[] = { 0xf000, 0xf3ff, 0 };
            ImFontConfig icons_config;

            ImFontConfig CustomFont;
            CustomFont.FontDataOwnedByAtlas = false;

            icons_config.MergeMode = true;
            icons_config.PixelSnapH = true;
            icons_config.OversampleH = 2.5;
            icons_config.OversampleV = 2.5;
           
ImFontConfig cfg;//å†…å­˜å­—ä½“//
cfg.SizePixels = ((float) density / 20.0f);
io.Fonts->AddFontFromMemoryTTF((void *)NIKE_data, NIKE_size, 20.0f, NULL, io.Fonts->GetGlyphRangesChineseFull());
io.Fonts->AddFontFromMemoryCompressedTTF(font_awesome_data, font_awesome_size, 20.0f, &icons_config, icons_ranges);

memset(&Config, 0, sizeof(sConfig));
        Config.ColorsESP.PVLine = CREATE_COLOR(0, 255, 0, 255);
        Config.ColorsESP.PVILine = CREATE_COLOR(255, 0, 0, 255);
        Config.ColorsESP.BVLine = CREATE_COLOR(255, 255, 255, 255);
        Config.ColorsESP.BVILine = CREATE_COLOR(255, 255, 255, 255);
   //     Config.ColorsESP.Linebot = CREATE_COLOR(333, 62, 0, 255);
        Config.ColorsESP.PVBox = CREATE_COLOR(0, 255, 0, 255);
        Config.ColorsESP.PVIBox = CREATE_COLOR(255, 0, 0, 255);
        Config.ColorsESP.BVBox = CREATE_COLOR(255, 255, 255, 255);
        Config.ColorsESP.BVIBox = CREATE_COLOR(255, 255, 255, 255);
        Config.ColorsESP.PVSkeleton = CREATE_COLOR(0, 255, 0, 255);
        Config.ColorsESP.PVISkeleton = CREATE_COLOR(255, 0, 0, 255);
        Config.ColorsESP.BVSkeleton = CREATE_COLOR(255, 255, 255, 255);
        Config.ColorsESP.BVISkeleton = CREATE_COLOR(255, 255, 255, 255);
        Config.ColorsESP.Name = CREATE_COLOR(255, 255, 255, 255);
        Config.ColorsESP.TeamID = CREATE_COLOR(255, 254, 0, 255);
        Config.ColorsESP.Distance = CREATE_COLOR(255, 255, 255, 255);
        Config.ColorsESP.Vehicle = CREATE_COLOR(255, 255, 255, 255); 
        Config.ColorsESP.Items = CREATE_COLOR(255, 0, 0, 255);    
        Config.ColorsESP.Itemss = CREATE_COLOR(255, 0, 0, 255);
        Config.ColorsESP.Itemsss = CREATE_COLOR(255, 0, 0, 255);
		Config.ColorsESP.Fov = CREATE_COLOR(255, 255, 255, 255);
        Config.SilentAim.Cross  = 0.0f;
        Aim10 = 13.000f;
        Aim50 = 46.561f;
        Aim100 = 135.450f;
        Aim150 = 198.942f;
        Aim200 = 304.762f;
        Aim250 = 387.302f;
        Aim300 = 399.999f;
        Config.å‹æªç³»æ•°  = 0.0f;
         Config.Xè½´  = 0.0f;
          Config.Yè½´  = 0.0f;
          Config.åååŠ›  = 0.0f;
          Config.å­å¼¹å°„é€Ÿ  = 0.0f;
          Config.Less =0.0f;
          é¢œè‰²åˆå§‹åŒ–();
initImGui = true;
}
//NIKE IMGUI Hack4.0
        ImGuiIO &io = ImGui::GetIO();
        
 
        
        ImGui_ImplOpenGL3_NewFrame();
        ImGui_ImplAndroid_NewFrame(glWidth, glHeight);
        ImGui::NewFrame();
        
        


	DrawESP(ImGui::GetBackgroundDrawList());
	

            
             if (!éšè—çª—å£) {
           
             
             			if (å˜è‰²) {
static double s0 = 0.0;
ImGui::PushStyleColor(ImGuiCol_Border, ImXmas::Rainbow(s0));
}






				
				if (Slowæç¤º) {
             if (Slowæç¤º1) {
             if (ImGui::Begin(OBFUSCATE("ä½œè€…æç¤º"), 0, ImGuiWindowFlags_NoBringToFrontOnFocus )) {
             ImGui::Text("æç¤º: \n  æœ¬ç›´è£…ä¸º64ä½ç›´è£….\n  ç‚¹å‡»ç¡®å®šå³å¯å¼€å§‹.");
             if (ImGui::Button("ç¡®å®š", ImVec2(100, 40))) {
             Slowæç¤º1 = false;
             }}}}
             
             
             if (tyyuyUI) {
             if (ImGui::Begin(OBFUSCATE("UI"), 0, ImGuiWindowFlags_NoBringToFrontOnFocus )) {
             ImGui::Text("è¯·ç­‰å¾…æ›´æ–°ä¿®å¤");
             
          ImGui::Checkbox("æ»‘åŠ¨æ¡å¤§å°", &Config.Crash1);
             
             ImGui::Checkbox("æ»‘åŠ¨æ¡å¤§å°", &Config.Crash1);
             
             ImGui::Checkbox("çª—ä½“è¾¹æ¡†åœ†è§’", &Config.Crash1);
             
             ImGui::Checkbox("æ¡†æ¶åœ†è§’", &Config.Crash1);
             
             ImGui::Checkbox("æ¡†æ¶è¾¹ç•Œå¤§å°", &Config.Crash1);
             
             ImGui::Checkbox("ä¸»é¢˜è¾¹ç•Œå¤§å°", &Config.Crash1);
             
             ImGui::Checkbox("é€‰é¡¹å¡åœ†è§’", &Config.Crash1);
             
             }}
             
             
             
             
             
             
             if (åŠ é€Ÿ) {
if (ImGui::Begin(OBFUSCATE("åŠ é€Ÿ"), 0, ImGuiWindowFlags_NoBringToFrontOnFocus )) {
if (ImGui::Button("åŠ é€Ÿå¼€", ImVec2(230 - 15, 50)))
                  åŠ é€Ÿå¼€ = true;
ImGui::SameLine();
if (ImGui::Button("åŠ é€Ÿå…³", ImVec2(230 - 15, 50)))
                  åŠ é€Ÿå¼€ = false;
                  
if (ImGui::Button("å…³é—­é¢æ¿", ImVec2(230 - 15, 50)))
                  åŠ é€Ÿ = false;
}}

if (é£å¤©å¼€) {
if (ImGui::Begin(OBFUSCATE("é£å¤©"), 0, ImGuiWindowFlags_NoBringToFrontOnFocus )) {
if (ImGui::Button("é£å¤©å¼€", ImVec2(230 - 15, 50)))
                  é£å¤© = true;
ImGui::SameLine();
if (ImGui::Button("é£å¤©å…³", ImVec2(230 - 15, 50)))
                  é£å¤© = false;
                  
if (ImGui::Button("å…³é—­é¢æ¿", ImVec2(230 - 15, 50)))
                  é£å¤©å¼€ = false;
}}
				
				if (show_è°ƒè¯•) {		          
                     ImGui::Begin("è‡ªç„[ä¿®å¤]",&show_è°ƒè¯•);     
            
   //     ImGui::Text(" -| å‹ æª æ•° å€¼ |- ");
   
ImGui::Text("1-28ç±³å†…å‹æªæ•°å€¼");
ImGui::SliderFloat("A", &Aim10, 0.0f, 400.0f); 
ImGui::TableNextColumn();
//ImGui::Text("28-50ç±³ä»¥å†…çš„æ•Œäººå°†ä¼šä½¿ç”¨è¿™ä¸ªå‹æªæ•°å€¼ï¼");
ImGui::Text("28-50ç±³å†…å‹æªæ•°å€¼");
ImGui::SliderFloat("B", &Aim50, 0.0f, 400.0f); 
ImGui::TableNextColumn();
//ImGui::Text("50ç±³åˆ°100ç±³ä»¥å†…çš„æ•Œäººå°†ä¼šä½¿ç”¨è¿™ä¸ªå‹æªæ•°å€¼ï¼");
ImGui::Text("50-100ç±³å†…å‹æªæ•°å€¼");
ImGui::SliderFloat("C", &Aim100, 0.0f, 400.0f); 
ImGui::TableNextColumn();
//ImGui::Text("100ç±³åˆ°150ç±³ä»¥å†…çš„æ•Œäººå°†ä¼šä½¿ç”¨è¿™ä¸ªå‹æªæ•°å€¼ï¼");
ImGui::TableNextColumn();
ImGui::Text("100-150ç±³å†…å‹æªæ•°å€¼");
ImGui::SliderFloat("D", &Aim150, 0.0f, 400.0f);
ImGui::TableNextColumn();
//ImGui::Text("150ç±³åˆ°200ç±³ä»¥å†…çš„æ•Œäººå°†ä¼šä½¿ç”¨è¿™ä¸ªå‹æªæ•°å€¼ï¼");
ImGui::TableNextColumn();
ImGui::Text("150-200ç±³å†…å‹æªæ•°å€¼");
ImGui::SliderFloat("E", &Aim200, 0.0f, 400.0f);
ImGui::TableNextColumn();
//ImGui::Text("200ç±³åˆ°250ç±³ä»¥å†…çš„æ•Œäººå°†ä¼šä½¿ç”¨è¿™ä¸ªå‹æªæ•°å€¼ï¼");
ImGui::Text("200-250ç±³å†…å‹æªæ•°å€¼");
ImGui::SliderFloat("F", &Aim250, 0.0f, 400.0f);
ImGui::TableNextColumn();
//ImGui::Text("250ç±³åˆ°300ç±³ä»¥å†…çš„æ•Œäººå°†ä¼šä½¿ç”¨è¿™ä¸ªå‹æªæ•°å€¼ï¼");
ImGui::Text("250-300ç±³å†…å‹æªæ•°å€¼");
ImGui::SliderFloat("G", &Aim300, 0.0f, 400.0f);
//ImGui::Text("Fov");
             }
	
 
//width=å®½
//height=é•¿




             

             
             if (!Loginèµ¢è—) {
             
        if (ImGui::Begin(OBFUSCATE("[PUSSY CHEAT] å¡å¯†éªŒè¯"), 0, ImGuiWindowFlags_NoBringToFrontOnFocus )) {
        
   /*     static std::string err;
        if (!showTipAlert()) {
        ImGui::Text("Login [Duplicate KEY]");
    ImGui::PushItemWidth(-1);
    ImGui::InputText("##key", s, sizeof(s));


    if (ImGui::Button("PASRE KEY", ImVec2(ImGui::GetContentRegionAvailWidth(), 30))) {
        auto key = getClipboardText();
        strncpy(s, key.c_str(), sizeof(s));
    }
    

  
         
     if (ImGui::Button("LOGIN KEY", ImVec2(ImGui::GetContentRegionAvailWidth(), 30))) {
        err = Login(getHEX(åŠ 64(s)));
        if (strstr(err.c_str(),"OK")!=0)
 
   {
            code_sock = 200;
   
        } else {
            code_sock = 401;
        }
    }

    if (ImGui::Button("UNLOCK KEY", ImVec2(ImGui::GetContentRegionAvailWidth(), 0))) { 
    Unbind(s);
     }
    
    ImGui::Text("LOGIN : %s\n", err.c_str());
    if (é”™è¯¯æç¤º) {
    ImGui::Text("UNLOCK : %s\n", æç¤º);
    }
    ImGui::PopItemWidth();

   }else{*/
 static bool isLogin = false;	
            static std::string err;
			
           if (!isLogin) {
           if (!err.empty() && err != "OK") {
                ImGui::Text("NO: %s", err.c_str());
                Loginæ–‡å­— = true;
                æç¤ºå†…å®¹ = err.c_str();
                if (!å¥½å¿ƒæç¤º)
                å¥½å¿ƒæç¤º = true;
            } 
            if (!Loginæ–‡å­—) {
            ImGui::Text(" Please Login [Paste Key]");
           }
            ImGui::PushItemWidth(-1);
            static char s[64];
            ImGui::InputText("##key", s, sizeof s);
            ImGui::PopItemWidth();

            ImGui::PushItemWidth(-1);
            if (ImGui::Button(" PASTE KEY  ", ImVec2(ImGui::GetContentRegionAvailWidth(), 0))) {
                auto key = getClipboardText();
                strncpy(s, key.c_str(), sizeof s);
            }
            ImGui::PopItemWidth();

            ImGui::PushItemWidth(-1);


            if (ImGui::Button(" LOGIN KEY ", ImVec2(ImGui::GetContentRegionAvailWidth(), 0))) {
                err = Login(s);
                if (err == "OK") {
                    isLogin = bValid && g_Auth == g_Token;
                }
            }
            ImGui::PopItemWidth();

          /*  if (!err.empty() && err != "OK") {
                ImGui::Text("Error: %s", err.c_str());
            }*/

                ImGui::PopItemWidth();


            } else {
            
Slowæç¤º = true;
Loginèµ¢è— = true;
}}}

	if (å¥½å¿ƒæç¤º) {
             if (ImGui::Begin(OBFUSCATE("ä½œè€…æç¤º"), 0, ImGuiWindowFlags_NoBringToFrontOnFocus )) {
             ImGui::Text("æç¤º:%s", æç¤ºå†…å®¹.c_str());
             if (ImGui::Button("ç¡®å®š", ImVec2(100, 40))) {
             å¥½å¿ƒæç¤º = false;
             }}}

//ImGui::SetNextWindowSize(ImVec2((float) glWidth * 0.85f, (float) glHeight * 0.925f), ImGuiCond_Once);
//ImGui::TableNextColumn();ä»£è¡¨ä¸ºç«–ç€
//ImGui::SameLine();ä»£è¡¨ä¸ºæ¨ªç€

ImGui::SetNextWindowSize(ImVec2((float) glWidth * 0.90f, (float) glHeight * 0.80f), ImGuiCond_Once);

if (!Slowæç¤º1) {
if (ImGui::Begin(OBFUSCATE("[PUSSY] è¿”å›"), 0, ImGuiWindowFlags_NoBringToFrontOnFocus )) {
{
ImGui::Columns(2);
ImGui::SetColumnOffset(1, 180);
static int tab = 1;
{
if (tab == 1) {
if (ImGui::Button(">[å…¬å‘Š]<", ImVec2(150 ,50)))
tab = 0;
} else {
if (ImGui::Button("å…¬å‘Š", ImVec2(150 ,50)))
tab = 1;
}
if (tab == 2) {
if (ImGui::Button(">[ç»˜åˆ¶]<", ImVec2(150 ,50)))
tab = 0;
} else {
if (ImGui::Button("ç»˜åˆ¶", ImVec2(150 ,50))) 
tab = 2;
}
if (tab == 3) {
if (ImGui::Button(">[è‡ªç„/å­è¿½]<", ImVec2(150 ,50)))
tab = 0;
} else {
if (ImGui::Button("è‡ªç„/å­è¿½", ImVec2(150 ,50))) 
tab = 3;
}
/*if (tab == 6) {
if (ImGui::Button(">[MEMORY]<", ImVec2(150 ,50)))
tab = 0;
} else {
if (ImGui::Button("MEMORY", ImVec2(150 ,50))) 
tab = 6;
}*/
if (tab == 5) {
if (ImGui::Button(">[å†…å­˜]<", ImVec2(150 ,50)))
tab = 0;
} else {
if (ImGui::Button("å†…å­˜", ImVec2(150 ,50))) 
tab = 5;
}
if (tab == 4) {
if (ImGui::Button(">[å…¶ä»–]<", ImVec2(150 ,50)))
tab = 0;
} else {
if (ImGui::Button("å…¶ä»–", ImVec2(150 ,50))) 
tab = 4;
}
if (è¯­è¨€ == 0) {
if (ImGui::Button("[è‹±æ–‡/ENGLISH]", ImVec2(150 ,50)))
è¯­è¨€ = 1;
} else {
if (ImGui::Button("[ä¸­æ–‡/CHINESE]", ImVec2(150 ,50)))
è¯­è¨€ = 0;
}
if (tyyuyUI) {
if (ImGui::Button(">[UI]<", ImVec2(150 ,50)))
tyyuyUI = false;
} else {
if (ImGui::Button("UI", ImVec2(150 ,50))) 
tyyuyUI = true;
}
ImGui::SameLine();
ImGui::Spacing();
ImGui::Spacing();
ImGui::Spacing();
}
//ImGui::SameLine();
ImGui::NextColumn();
//ImGui::SameLine();

if (tab == 0) {

if (!æ˜¾ç¤ºæç¤ºå¼€å…³) {
æ˜¾ç¤ºå°æç¤º = æ˜¾ç¤ºå°æç¤º + 1;
if (æ˜¾ç¤ºå°æç¤º == 17) {
æ˜¾ç¤ºå°æç¤º = 0;
}}
æ˜¾ç¤ºæç¤ºå¼€å…³ = true;
if (è¯­è¨€ == 0) {
ImGui::Text("æç¤º:");
if (æ˜¾ç¤ºå°æç¤º == 0)
ImGui::Text("  ä½ çŸ¥é“å—? è‡ªç„å’Œå­è¿½ä¸å¯ä»¥åŒæ—¶å¼€å¯\n  å¦åˆ™ä¼šå¯¼è‡´é—ªé€€.");
if (æ˜¾ç¤ºå°æç¤º == 1)
ImGui::Text("  æ¸¸æˆè™½å¼€å¿ƒ. ä½†æ˜¯ä¹Ÿè¦ç…§é¡¾èº«ä½“.\n  å¤šå‡ºå»èµ°èµ° é”»ç‚¼é”»ç‚¼èº«ä½“.");
if (æ˜¾ç¤ºå°æç¤º == 2)
ImGui::Text("  PUBG MOBILEçš„åœ°é“é€ƒç”Ÿæ¨¡å¼\n  ä¹Ÿæœ‰å¾ˆå¤šäººåœ¨ä½¿ç”¨å¤–æŒ‚å“¦.");
if (æ˜¾ç¤ºå°æç¤º == 3)
ImGui::Text("  è¿™ä¸ªå†…éƒ¨æœ‰å¾ˆå¤šå°è®¾è®¡ç­‰ä½ æ¢ç´¢å“¦.\n  æ¥è‡ª[ä½œè€…]çš„æç¤º.");
if (æ˜¾ç¤ºå°æç¤º == 4)
ImGui::Text("  ç›´è£…å°å·åœ¨æ‰€éš¾å… ä¸è¦ä¼¤å¿ƒ.\n  è¦é€‚å½“çš„æ¼”æˆ æˆ–è€…æ˜¯ä½¿ç”¨å•ç»˜åˆ¶.");
if (æ˜¾ç¤ºå°æç¤º == 5)
ImGui::Text("  ä½ çŸ¥é“å—? 2.2èµ›å­£çš„PUBGæ˜¯æ£€æµ‹\n  æœ€é«˜çš„ä¸€ä¸ªèµ›å­£ å½“æ—¶æˆ‘éƒ½è¦å°æ­»äº†.");
if (æ˜¾ç¤ºå°æç¤º == 6)
ImGui::Text("  ä½ å¯ä»¥å°è¯•ä¸€ä¸‹æ½®æµä¸»é¢˜.\n  å¾ˆç¬¦åˆä»¥å‰M4åŠå¤§å¤šæ•°ç›´è£…UI.");
if (æ˜¾ç¤ºå°æç¤º == 7)
ImGui::Text("  ä½ å¯ä»¥æ”¯æŒç›´è£…ä½œè€… [çƒˆå·] å—.\n  ä»–åˆ¶ä½œè¿™ä¸ªæºç æœ‰6ä¸ªæ˜ŸæœŸäº†");
if (æ˜¾ç¤ºå°æç¤º == 8)
ImGui::Text("  ä½ çŸ¥é“å—? ç›´è£…é—ªé€€çš„åŸå› æ˜¯MD5æ ¡éªŒ.\n  å½“æ—¶2.3è¿˜å¥½ 2.4å¤ªä¸¥é‡äº†.");
if (æ˜¾ç¤ºå°æç¤º == 9)
ImGui::Text("  è¿™äº›åŠŸèƒ½è¦ä¹ˆæ˜¯æˆ‘æŠ å‡ºæ¥çš„.\n  è¦ä¹ˆæ˜¯æˆ‘æ”¶åˆ°å¯å‘ç ”ç©¶çš„.");
if (æ˜¾ç¤ºå°æç¤º == 10)
ImGui::Text("  ä½ çŸ¥é“å—? å…¶å®è¿™ä¸ªé¡µé¢æ˜¯ä½œè€…çš„ä¸€ä¸ªå°å½©è›‹.");
if (æ˜¾ç¤ºå°æç¤º == 11)
ImGui::Text("  ä½ çŸ¥é“å—? æœ‰ä¸€äº›å¾ˆè´±çš„äºº\n  ä½œè€…ä¼šç›´æ¥è¸¢å‡ºå†…éƒ¨ç¾¤.");
if (æ˜¾ç¤ºå°æç¤º == 12)
ImGui::Text("  ä½ çŸ¥é“å—? æˆ‘çš„æœ‹å‹æ˜¯PUBGå†…éƒ¨äººå‘˜.\n  æœ‰ä¸€äº›åŠŸèƒ½æ˜¯ä»–æ³„éœ²ç»™æˆ‘çš„.");
if (æ˜¾ç¤ºå°æç¤º == 13)
ImGui::Text("  ä½ è§‰å¾—3åˆ1ç›´è£…æ€ä¹ˆæ ·\n  åæ­£ä½œè€…æ˜¯è§‰å¾—äºå¤§äº†.");
if (æ˜¾ç¤ºå°æç¤º == 14)
ImGui::Text("  ä½ çŸ¥é“å—? æˆ‘ä»¬åŸæœ¬çš„å®šä»·æ˜¯4å…ƒ\n  åªä¸è¿‡æ²¡äººä¹°å°±é™ä»·äº†.");
if (æ˜¾ç¤ºå°æç¤º == 15)
ImGui::Text("  ä½ çŸ¥é“å—? æ™®é€šé˜²é—ªæ˜¯å¦‚æœé—ªé€€äº†ä¹‹åæ‰ä½¿ç”¨\n  å¦‚æœæ²¡æœ‰é—ªé€€ä½¿ç”¨å¯èƒ½ä¼šå¯¼è‡´è¿½å°å¡é¡¿.");
if (æ˜¾ç¤ºå°æç¤º == 16) {
ImGui::Text("  8484848");
if (ImGui::Button("8484848", ImVec2(160, 40))) {
æç¤ºå†…å®¹ = "\nOC8KCKL \n84848 å˜¿å˜¿ \n8484848 \n84848 å˜¿å˜¿";
å¥½å¿ƒæç¤º = true;
}}

/*ImGui::Text("\n\n\n");
//ImGui::Text("å½“å‰æ—¶é—´:%s", dqsjs.c_str());
static std::string err;
ImGui::Text("æŸ¥è¯¢å¡å¯†:");
   
if (isLogin123) {
            ImGui::Text("çŠ¶æ€: æ­£å¸¸");
            ImGui::Text("è®¾å¤‡: %s", device.c_str());
            ImGui::Text("åå­—: %s", name.c_str());
            ImGui::Text("å…¶ä»–: %s", floating.c_str());
            ImGui::Text("çŠ¶æ€: %s", status.c_str());
            ImGui::Text("åˆ°æœŸ: %s", EXP.c_str());
            } else {
            if (!err.empty() && err != "OK") {
            ImGui::Text("é”™è¯¯: %s", err.c_str());
            
            
            
            
            
            }}
static char sss[64];
            ImGui::InputText("##keyn", sss, sizeof sss);
            ImGui::SameLine();
            if (ImGui::Button("ç²˜è´´", ImVec2(ImGui::GetContentRegionAvailWidth(), 0))) {
                auto keynn = getClipboardText();
                strncpy(sss, keynn.c_str(), sizeof sss);
            }
            if (ImGui::Button(" ç¡®å®š ", ImVec2(ImGui::GetContentRegionAvailWidth(), 0))) {
            isLogin123 = false;
                err = Login(sss);
            
                if (err == "OK") {
                     isLogin123 = bValid && g_Auth == g_Token;
                }
            }*/
            

            
            

} else if (è¯­è¨€ == 1) {
ImGui::Text("Point out:");
if (æ˜¾ç¤ºå°æç¤º == 0)
ImGui::Text("  Do you know that?/You know what? Self-aiming and sub-chasing cannot be turned on at the same time \n  Otherwise it will lead to titles.");
if (æ˜¾ç¤ºå°æç¤º == 1)
ImGui::Text("  Although the game is fun, you should also take care of your health. \n  Go out and exercise more.");
if (æ˜¾ç¤ºå°æç¤º == 2)
ImGui::Text("  PUBG MOBILE's subway escape mode \n  Many people are also using plug-ins.");
if (æ˜¾ç¤ºå°æç¤º == 3)
ImGui::Text("  There are many small designs waiting for you to explore. \n  Tips from [the author].");
if (æ˜¾ç¤ºå°æç¤º == 4)
ImGui::Text("  Direct loading of titles is inevitable. Don't be sad. \n  Act properly or use single drawing.");
if (æ˜¾ç¤ºå°æç¤º == 5)
ImGui::Text("  Do you know that? PUBG in 2.2 season was the highest test season \n  and I was blocked at that time.");
if (æ˜¾ç¤ºå°æç¤º == 6)
ImGui::Text("  You can try the trend theme. \n  It fits the previous M4 and most direct-installed UIs.");
if (æ˜¾ç¤ºå°æç¤º == 7)
ImGui::Text("  Can you support the direct author [Cory]? \n  He has been making this source code for 6 months.");
if (æ˜¾ç¤ºå°æç¤º == 8)
ImGui::Text("  Do you know that? The reason for the flashback of direct loading is MD5 verification. \n  At that time, 2.3 was fine and 2.4 was too serious.");
if (æ˜¾ç¤ºå°æç¤º == 9)
ImGui::Text("  I either dug up these functions. \n  Or I was inspired to study them.");
if (æ˜¾ç¤ºå°æç¤º == 10)
ImGui::Text("  Do you know that? In fact, this page is a small egg of the author.");
if (æ˜¾ç¤ºå°æç¤º == 11)
ImGui::Text("  Do you know that?/You know what? There are some very cheap people \n  The author will just kick out of the inner group.");
if (æ˜¾ç¤ºå°æç¤º == 12)
ImGui::Text("  Do you know that? My friend is an insider of PUBG. \n  He leaked some functions to me.");
if (æ˜¾ç¤ºå°æç¤º == 13)
ImGui::Text("  What do you think of the 3-in-1 interior \n  Anyway, the author thinks it's a big loss.");
if (æ˜¾ç¤ºå°æç¤º == 14)
ImGui::Text("  Do you know that? Our original price was 50 yuan \n  Only the price was reduced when no one bought it.");
if (æ˜¾ç¤ºå°æç¤º == 15)
ImGui::Text("  Do you know that? Ordinary anti-flash is only used if it is flashed back \n  If it is not flashed back, it may lead to blocking.");
if (æ˜¾ç¤ºå°æç¤º == 16) {
ImGui::Text("  The author died.!!!");
/*if (ImGui::Button("8484848", ImVec2(160, 40))) {
æç¤ºå†…å®¹ = "\nOC8KCKL \n84848 å˜¿å˜¿ \n8484848 \n84848 å˜¿å˜¿";
å¥½å¿ƒæç¤º = true;
}*/}

/*ImGui::Text("\n\n\n");
//ImGui::Text("å½“å‰æ—¶é—´:%s", dqsjs.c_str());
static std::string err;
ImGui::Text("Consulting key:");
   
if (isLogin123) {
            ImGui::Text("Normal");
            ImGui::Text("Equipment: %s", device.c_str());
            ImGui::Text("Name: %s", name.c_str());
            ImGui::Text("Other: %s", floating.c_str());
            ImGui::Text("Condition: %s", status.c_str());
            ImGui::Text("Expiration time: %s", EXP.c_str());
            } else {
            if (!err.empty() && err != "OK") {
            ImGui::Text("Herro: %s", err.c_str());
            
            
            
            
            
            }}
static char sss[64];
            ImGui::InputText("##keyn", sss, sizeof sss);
            ImGui::SameLine();
            if (ImGui::Button(" Paste ", ImVec2(ImGui::GetContentRegionAvailWidth(), 0))) {
                auto keynn = getClipboardText();
                strncpy(sss, keynn.c_str(), sizeof sss);
            }
            if (ImGui::Button(" Sure ", ImVec2(ImGui::GetContentRegionAvailWidth(), 0))) {
            isLogin123 = false;
                err = Login(sss);
            
                if (err == "OK") {
                     isLogin123 = bValid && g_Auth == g_Token;
                }
            }*/

}
} else {
æ˜¾ç¤ºæç¤ºå¼€å…³ = false;
}

if (tab == 1) {
if (è¯­è¨€ == 0) {
if (ImGui::Button("ä¿å­˜é…ç½®", ImVec2(160, 40))) {
saveCFG();
}
ImGui::SameLine();
if (ImGui::Button("åŠ è½½é…ç½®", ImVec2(160, 40))) {
loadCFG();
}
ImGui::SameLine();
  //   --------------------------------   \\
ImGui::Text(" --------------------------------\n |ä¸Šå¸‚ç‰ˆæœ¬ ç¨³å®šæ—è·¯|\n |æ— æƒ§æ£€æµ‹ ç¨³å®šå¥”æ”¾|\n --------------------------------\n");


/*if (!å…¨å±€ç¦»çº¿) {
if (ImGui::Button("å…¨å±€ç¦»çº¿[ON]", ImVec2(160, 40))) {
å…¨å±€ç¦»çº¿ = true;
}} else {
if (ImGui::Button("å…¨å±€ç¦»çº¿[OFF]", ImVec2(160, 40))) {
å…¨å±€ç¦»çº¿ = false;
}}

ImGui::Text("è“åœˆå¼€ æ’¤ç¦»æ­»äº¡å…³ ä¸è¦å¿˜è®°å¼€");*/
ImGui::Text("ç‰ˆæœ¬:2.5.0 : 9.9.2");
ImGui::Spacing(); 
ImGui::Checkbox("å¤§å…å¼€å¯æ—è·¯", &å¤§å…æ—è·¯);
ImGui::Text("ä¸€å®šè¦å¼€ ä¸ç„¶å°å·ä¸ç®¡");
//ImGui::SameLine();
//ImGui::Checkbox("å¤§å…å…¨é˜²æ—è·¯", &DobyBypass);

ImGui::Checkbox("è§¦å±éšè—", &çª—å£éšè—);
ImGui::Text("ç‚¹å‡»å±å¹•å·¦ä¸Šè§’x3 æ˜¾ç¤º/éšè—");
ImGui::Checkbox("çª—å£å˜è‰²", &å˜è‰²);
if (ImGui::Button("æ½®æµä¸»é¢˜", ImVec2(160, 40))) {
ImGuiStyle& style = ImGui::GetStyle();
            style.WindowPadding = ImVec2(8, 6);
            style.WindowRounding = 8.0f;
            style.FramePadding = ImVec2(4, 5);
            style.FrameRounding = 15.0f;
            style.WindowTitleAlign = ImVec2(0.5, 0.5);
            style.FrameBorderSize = 3.0f;
            style.WindowBorderSize = 3.0f;
            style.TabBorderSize = 3.0f;
            style.WindowMinSize = ImVec2(250, 150);
    style.WindowTitleAlign = ImVec2(0.5, 0.5);
    style.ButtonTextAlign = ImVec2(0.5,0.5); 
    style.Colors[ImGuiCol_Text]                   = ImColor(255, 0, 0, 255);
    style.Colors[ImGuiCol_TextDisabled]           = ImColor(255, 215, 0, 255);
    style.Colors[ImGuiCol_WindowBg]               = ImColor(255, 215, 0, 155);
    style.Colors[ImGuiCol_ChildBg]                = ImColor(255, 215, 0, 255);
    style.Colors[ImGuiCol_PopupBg]                = ImColor(255, 215, 0, 255);
    style.Colors[ImGuiCol_Border]                 = ImColor(255, 0, 0, 255);
    style.Colors[ImGuiCol_BorderShadow]           = ImColor(255, 215, 0, 255);
    style.Colors[ImGuiCol_FrameBg]                = ImColor(255, 215, 0, 255);
    style.Colors[ImGuiCol_FrameBgHovered]         = ImColor(255, 215, 0, 255);
    style.Colors[ImGuiCol_FrameBgActive]          = ImColor(255, 215, 0, 255);
    style.Colors[ImGuiCol_TitleBg]                = ImColor(255, 215, 0, 255);
    style.Colors[ImGuiCol_TitleBgActive]          = ImColor(255, 215, 0, 255);
    style.Colors[ImGuiCol_TitleBgCollapsed]       = ImColor(255, 215, 0, 255);
    style.Colors[ImGuiCol_MenuBarBg]              = ImColor(255, 215, 0, 255);
    style.Colors[ImGuiCol_ScrollbarBg]            = ImColor(255, 215, 0, 255);
    style.Colors[ImGuiCol_ScrollbarGrab]          = ImColor(255, 0, 0, 255);
    style.Colors[ImGuiCol_ScrollbarGrabHovered]   = ImColor(255, 215, 0, 255);
    style.Colors[ImGuiCol_ScrollbarGrabActive]    = ImColor(255, 0, 0, 255);
    style.Colors[ImGuiCol_CheckMark]              = ImColor(255, 0, 0, 255);
    style.Colors[ImGuiCol_Button]                 = ImColor(255, 215, 0, 255);
    style.Colors[ImGuiCol_ButtonHovered]          = ImColor(255, 215, 0, 255);
    style.Colors[ImGuiCol_ButtonActive]           = ImColor(255, 215, 0, 255);
    style.Colors[ImGuiCol_Header]                 = ImColor(255, 215, 0, 255);
    style.Colors[ImGuiCol_HeaderHovered]          = ImColor(255, 215, 0, 255);
    style.Colors[ImGuiCol_HeaderActive]           = ImColor(255, 215, 0, 255);
    style.Colors[ImGuiCol_Tab]                    = ImColor(255, 215, 0, 255);
    ImGui::StyleColorsDark();
    å˜è‰² = true;



}
ImGui::SameLine();
if (ImGui::Button("ä»¿ç¥ç›¾å±€", ImVec2(160, 40))) {
        ImGuiStyle& style = ImGui::GetStyle();
        style.WindowRounding = 8.3f;
        style.FrameRounding = 5.0f;
        style.ScrollbarRounding = 5;

        style.WindowTitleAlign = ImVec2(0.8, 0.8);
        style.WindowMinSize = ImVec2(300, 200);
        style.FramePadding = ImVec2(8, 4);
		style.WindowBorderSize = 3.3f;
		style.FrameBorderSize = 3.3f;

        style.Colors[ImGuiCol_Text]                  = ImVec4(0, 0, 0, 255);
        style.Colors[ImGuiCol_TextDisabled]          = ImColor(242, 51, 51, 255);
        style.Colors[ImGuiCol_WindowBg]              = ImColor(194, 0, 113, 255);
        style.Colors[ImGuiCol_ChildBg]               = ImColor(194, 0, 113, 255);
        style.Colors[ImGuiCol_PopupBg]               = ImColor(255, 215, 0, 255);
	
        style.Colors[ImGuiCol_Border]                = ImColor(194, 94, 0, 255);
        style.Colors[ImGuiCol_BorderShadow]          = ImColor(194, 94, 0, 255);

        style.Colors[ImGuiCol_FrameBg]               = ImColor(247, 164, 87, 255);
        style.Colors[ImGuiCol_FrameBgActive]         = ImColor(247, 164, 87, 255);
        style.Colors[ImGuiCol_FrameBgHovered]        = ImColor(247, 164, 87, 255);

        style.Colors[ImGuiCol_TitleBg]               = ImColor(222, 75, 22, 255);
        style.Colors[ImGuiCol_TitleBgActive]         = ImColor(222, 75, 22, 255);
        style.Colors[ImGuiCol_TitleBgCollapsed]      = ImColor(222, 75, 22, 130);

        style.Colors[ImGuiCol_MenuBarBg]             = ImVec4(255, 215, 0, 255);
        style.Colors[ImGuiCol_ScrollbarBg]           = ImColor(222, 75, 22, 255);
        style.Colors[ImGuiCol_ScrollbarGrab]         = ImVec4(255, 215, 0, 255);
        style.Colors[ImGuiCol_ScrollbarGrabHovered]  = ImVec4(255, 215, 0, 255);
        style.Colors[ImGuiCol_ScrollbarGrabActive]   = ImVec4(255, 215, 0, 255);
        style.Colors[ImGuiCol_CheckMark]             = ImVec4(255, 215, 0, 255);
        style.Colors[ImGuiCol_SliderGrab]            = ImVec4(255, 215, 0, 255);
        style.Colors[ImGuiCol_SliderGrabActive]      = ImVec4(184, 180, 70, 255);

        style.Colors[ImGuiCol_Separator]             = ImColor(235, 133, 23, 255);
        style.Colors[ImGuiCol_SeparatorActive]       = ImColor(235, 133, 23, 255);
        style.Colors[ImGuiCol_SeparatorHovered]      = ImColor(235, 133, 23, 255);

        style.Colors[ImGuiCol_Button]                = ImColor(235, 23, 23, 255);
        style.Colors[ImGuiCol_ButtonActive]          = ImColor(235, 23, 23, 255);
        style.Colors[ImGuiCol_ButtonHovered]         = ImColor(235, 23, 23, 255);

        style.Colors[ImGuiCol_Header]                = ImColor(235, 23, 150, 255);
        style.Colors[ImGuiCol_HeaderActive]          = ImColor(235, 23, 150, 255);
        style.Colors[ImGuiCol_HeaderHovered]         = ImColor(235, 23, 150, 255);

        style.Colors[ImGuiCol_ResizeGrip]            = ImVec4(255, 215, 0, 255);
        style.Colors[ImGuiCol_ResizeGripHovered]     = ImVec4(255, 215, 0, 255);
        style.Colors[ImGuiCol_ResizeGripActive]      = ImVec4(255, 215, 0, 255);
        style.Colors[ImGuiCol_PlotLines]             = ImVec4(255, 215, 0, 255);
        style.Colors[ImGuiCol_PlotLinesHovered]      = ImVec4(255, 215, 0, 255);
        style.Colors[ImGuiCol_PlotHistogram]         = ImVec4(255, 215, 0, 255);
        style.Colors[ImGuiCol_PlotHistogramHovered]  = ImVec4(255, 215, 0, 255);
        style.Colors[ImGuiCol_TextSelectedBg]        = ImVec4(255, 215, 0, 255);


//           style.ScaleAllSizes(std::max(2.5f, density / 400.0f));
}
if (ImGui::Button("åœ°é“æ¨¡å¼", ImVec2(160, 40))) {
Config.é¢„åˆ¤ = true;
Config.AimBot.IgnoreKnocked = true;
Config.AimBot.IgnoreBot = true;
Config.è‡ªåŠ¨Z = true;
Config.AimBot.å¼€å¯è‡ªç„ = true;
æ˜¾ç¤ºæ–‡å­— = true;
Config.PlayerESP.ä¸Š = true;
Config.é›·è¾¾ = true;
Config.PlayerESP.Alert360 = true;
Config.PlayerESP.Grenade = true;
Config.æ‰‹æŒ = true;
Config.ç‰©èµ„ = true;
Config.PlayerESP.LootBox = true;
Config.PlayerESP.å¼€å¯çº¿æ¡ = true;
Config.PlayerESP.Vehicle = true;
Config.PlayerESP.TeamID = true;
Config.PlayerESP.Distance = true;
Config.PlayerESP.Name = true;
Config.PlayerESP.Skeleton = true;
Config.PlayerESP.Health = true;
Config.PlayerESP.Box = true;
Config.PlayerESP.ActiveEsp = true;
Config.AimBot.AINBOT = AIMBOT::NC;
Config.AimBot.Trigger = EAimTrigger::Any;
Config.åœˆ = true;
Config.SilentAim.Cross = 300.0f;
}
ImGui::SameLine();
if (ImGui::Button("ç»å…¸æ¨¡å¼", ImVec2(160, 40))) {
Config.é¢„åˆ¤ = true;
Config.AimBot.IgnoreKnocked = true;
Config.AimBot.IgnoreBot = true;
Config.è‡ªåŠ¨Z = true;
Config.AimBot.å¼€å¯è‡ªç„ = true;
æ˜¾ç¤ºæ–‡å­— = true;
Config.PlayerESP.ä¸Š = true;
Config.é›·è¾¾ = true;
Config.PlayerESP.Alert360 = true;
Config.PlayerESP.Grenade = true;
Config.æ‰‹æŒ = true;
Config.ç‰©èµ„ = true;
Config.PlayerESP.LootBox = true;
Config.PlayerESP.å¼€å¯çº¿æ¡ = true;
Config.PlayerESP.Vehicle = true;
Config.PlayerESP.TeamID = true;
Config.PlayerESP.Distance = true;
Config.PlayerESP.Name = true;
Config.PlayerESP.Skeleton = true;
Config.PlayerESP.Health = true;
Config.PlayerESP.Box = true;
Config.PlayerESP.ActiveEsp = true;
Config.HighRisk.Shake = true;
Config.AimBot.AINBOT = AIMBOT::NC;
Config.AimBot.Trigger = EAimTrigger::Any;
Config.åœˆ = true;
Config.SilentAim.Cross = 300.0f;
}
ImGui::Text("è¿™äº›ä¸€é”®åŠŸèƒ½æ˜¯ä½œè€…è‡ªå·±çš„å£å‘³è®¾ç½®çš„\nä¸å–œå‹¿å–· å»ºè®®è‡ªå·±å¼€å¯åŠŸèƒ½");
if (ImGui::Combo("èœå•é£æ ¼", &style_idx, "ç´«è‰²ä¸»é¢˜\0è“è‰²ä¸»é¢˜\0ç™½è‰²ä¸»é¢˜\0é»„è‰²ä¸»é¢˜\0")) {
                switch (style_idx) {
                        case 0:ImGui::StyleColorsClassic();
                         break;                 
            	        case 1:ImGui::StyleColorsDark();
                         break;         
   		                case 2:ImGui::StyleColorsLight();
                         break;
                        case 3:
                         ImGuiStyle& style = ImGui::GetStyle();
    style.Colors[ImGuiCol_Text]                   = ImColor(255, 0, 0, 255);
    style.Colors[ImGuiCol_TextDisabled]           = ImColor(255, 215, 0, 255);
    style.Colors[ImGuiCol_WindowBg]               = ImColor(255, 215, 0, 155);
    style.Colors[ImGuiCol_ChildBg]                = ImColor(255, 215, 0, 255);
    style.Colors[ImGuiCol_PopupBg]                = ImColor(255, 215, 0, 255);
    style.Colors[ImGuiCol_Border]                 = ImColor(255, 0, 0, 255);
    style.Colors[ImGuiCol_BorderShadow]           = ImColor(255, 215, 0, 255);
    style.Colors[ImGuiCol_FrameBg]                = ImColor(255, 215, 0, 255);
    style.Colors[ImGuiCol_FrameBgHovered]         = ImColor(255, 215, 0, 255);
    style.Colors[ImGuiCol_FrameBgActive]          = ImColor(255, 215, 0, 255);
    style.Colors[ImGuiCol_TitleBg]                = ImColor(255, 215, 0, 255);
    style.Colors[ImGuiCol_TitleBgActive]          = ImColor(255, 215, 0, 255);
    style.Colors[ImGuiCol_TitleBgCollapsed]       = ImColor(255, 215, 0, 255);
    style.Colors[ImGuiCol_MenuBarBg]              = ImColor(255, 215, 0, 255);
    style.Colors[ImGuiCol_ScrollbarBg]            = ImColor(255, 215, 0, 255);
    style.Colors[ImGuiCol_ScrollbarGrab]          = ImColor(255, 0, 0, 255);
    style.Colors[ImGuiCol_ScrollbarGrabHovered]   = ImColor(255, 215, 0, 255);
    style.Colors[ImGuiCol_ScrollbarGrabActive]    = ImColor(255, 0, 0, 255);
    style.Colors[ImGuiCol_CheckMark]              = ImColor(255, 0, 0, 255);
    style.Colors[ImGuiCol_Button]                 = ImColor(255, 215, 0, 255);
    style.Colors[ImGuiCol_ButtonHovered]          = ImColor(255, 215, 0, 255);
    style.Colors[ImGuiCol_ButtonActive]           = ImColor(255, 215, 0, 255);
    style.Colors[ImGuiCol_Header]                 = ImColor(255, 215, 0, 255);
    style.Colors[ImGuiCol_HeaderHovered]          = ImColor(255, 215, 0, 255);
    style.Colors[ImGuiCol_HeaderActive]           = ImColor(255, 215, 0, 255);
    style.Colors[ImGuiCol_Tab]                    = ImColor(255, 215, 0, 255);
    

                         break;
                         
                      
            

  
     			   }
     			   }      				
      		
      				                	
} else if (è¯­è¨€ == 1) {
if (ImGui::Button("Save configuration", ImVec2(160, 40))) {
saveCFG();
}
ImGui::SameLine();
if (ImGui::Button("Load configuration", ImVec2(160, 40))) {
loadCFG();
}
ImGui::SameLine();
  //   --------------------------------   \\
ImGui::Text(" --------------------------------\n |Stable bypass|\n |Delete detection|\n --------------------------------\n");


/*if (!å…¨å±€ç¦»çº¿) {
if (ImGui::Button("Global offline[ON]", ImVec2(160, 40))) {
å…¨å±€ç¦»çº¿ = true;
}} else {
if (ImGui::Button("Global offline[OFF]", ImVec2(160, 40))) {
å…¨å±€ç¦»çº¿ = false;
}}

ImGui::Text("Don't forget to open the birth island and evacuate the death gate.");*/
ImGui::Text("Version:2.5.0 : 9.9.2");
ImGui::Spacing(); 
ImGui::Checkbox("Lobby test bypass", &å¤§å…æ—è·¯);
ImGui::Text("You have to open it    Otherwise the ban");
//ImGui::SameLine();
//ImGui::Checkbox("Lobby bypass", &DobyBypass);

ImGui::Checkbox("Click hide", &çª—å£éšè—);
ImGui::Text("Click x3 in the upper left corner of the screen to show/hide.");
ImGui::Checkbox("Window discoloration", &å˜è‰²);
if (ImGui::Button("Chaoliu theme", ImVec2(160, 40))) {
ImGuiStyle& style = ImGui::GetStyle();
            style.WindowPadding = ImVec2(8, 6);
            style.WindowRounding = 8.0f;
            style.FramePadding = ImVec2(4, 5);
            style.FrameRounding = 15.0f;
            style.WindowTitleAlign = ImVec2(0.5, 0.5);
            style.FrameBorderSize = 3.0f;
            style.WindowBorderSize = 3.0f;
            style.TabBorderSize = 3.0f;
            style.WindowMinSize = ImVec2(250, 150);
    style.WindowTitleAlign = ImVec2(0.5, 0.5);
    style.ButtonTextAlign = ImVec2(0.5,0.5); 
    style.Colors[ImGuiCol_Text]                   = ImColor(255, 0, 0, 255);
    style.Colors[ImGuiCol_TextDisabled]           = ImColor(255, 215, 0, 255);
    style.Colors[ImGuiCol_WindowBg]               = ImColor(255, 215, 0, 155);
    style.Colors[ImGuiCol_ChildBg]                = ImColor(255, 215, 0, 255);
    style.Colors[ImGuiCol_PopupBg]                = ImColor(255, 215, 0, 255);
    style.Colors[ImGuiCol_Border]                 = ImColor(255, 0, 0, 255);
    style.Colors[ImGuiCol_BorderShadow]           = ImColor(255, 215, 0, 255);
    style.Colors[ImGuiCol_FrameBg]                = ImColor(255, 215, 0, 255);
    style.Colors[ImGuiCol_FrameBgHovered]         = ImColor(255, 215, 0, 255);
    style.Colors[ImGuiCol_FrameBgActive]          = ImColor(255, 215, 0, 255);
    style.Colors[ImGuiCol_TitleBg]                = ImColor(255, 215, 0, 255);
    style.Colors[ImGuiCol_TitleBgActive]          = ImColor(255, 215, 0, 255);
    style.Colors[ImGuiCol_TitleBgCollapsed]       = ImColor(255, 215, 0, 255);
    style.Colors[ImGuiCol_MenuBarBg]              = ImColor(255, 215, 0, 255);
    style.Colors[ImGuiCol_ScrollbarBg]            = ImColor(255, 215, 0, 255);
    style.Colors[ImGuiCol_ScrollbarGrab]          = ImColor(255, 0, 0, 255);
    style.Colors[ImGuiCol_ScrollbarGrabHovered]   = ImColor(255, 215, 0, 255);
    style.Colors[ImGuiCol_ScrollbarGrabActive]    = ImColor(255, 0, 0, 255);
    style.Colors[ImGuiCol_CheckMark]              = ImColor(255, 0, 0, 255);
    style.Colors[ImGuiCol_Button]                 = ImColor(255, 215, 0, 255);
    style.Colors[ImGuiCol_ButtonHovered]          = ImColor(255, 215, 0, 255);
    style.Colors[ImGuiCol_ButtonActive]           = ImColor(255, 215, 0, 255);
    style.Colors[ImGuiCol_Header]                 = ImColor(255, 215, 0, 255);
    style.Colors[ImGuiCol_HeaderHovered]          = ImColor(255, 215, 0, 255);
    style.Colors[ImGuiCol_HeaderActive]           = ImColor(255, 215, 0, 255);
    style.Colors[ImGuiCol_Tab]                    = ImColor(255, 215, 0, 255);
    ImGui::StyleColorsDark();
    å˜è‰² = true;



}
ImGui::SameLine();
if (ImGui::Button("SHIELD", ImVec2(160, 40))) {
        ImGuiStyle& style = ImGui::GetStyle();
        style.WindowRounding = 8.3f;
        style.FrameRounding = 5.0f;
        style.ScrollbarRounding = 5;

        style.WindowTitleAlign = ImVec2(0.8, 0.8);
        style.WindowMinSize = ImVec2(300, 200);
        style.FramePadding = ImVec2(8, 4);
		style.WindowBorderSize = 3.3f;
		style.FrameBorderSize = 3.3f;

        style.Colors[ImGuiCol_Text]                  = ImVec4(0, 0, 0, 255);
        style.Colors[ImGuiCol_TextDisabled]          = ImColor(242, 51, 51, 255);
        style.Colors[ImGuiCol_WindowBg]              = ImColor(194, 0, 113, 255);
        style.Colors[ImGuiCol_ChildBg]               = ImColor(194, 0, 113, 255);
        style.Colors[ImGuiCol_PopupBg]               = ImColor(255, 215, 0, 255);
	
        style.Colors[ImGuiCol_Border]                = ImColor(194, 94, 0, 255);
        style.Colors[ImGuiCol_BorderShadow]          = ImColor(194, 94, 0, 255);

        style.Colors[ImGuiCol_FrameBg]               = ImColor(247, 164, 87, 255);
        style.Colors[ImGuiCol_FrameBgActive]         = ImColor(247, 164, 87, 255);
        style.Colors[ImGuiCol_FrameBgHovered]        = ImColor(247, 164, 87, 255);

        style.Colors[ImGuiCol_TitleBg]               = ImColor(222, 75, 22, 255);
        style.Colors[ImGuiCol_TitleBgActive]         = ImColor(222, 75, 22, 255);
        style.Colors[ImGuiCol_TitleBgCollapsed]      = ImColor(222, 75, 22, 130);

        style.Colors[ImGuiCol_MenuBarBg]             = ImVec4(255, 215, 0, 255);
        style.Colors[ImGuiCol_ScrollbarBg]           = ImColor(222, 75, 22, 255);
        style.Colors[ImGuiCol_ScrollbarGrab]         = ImVec4(255, 215, 0, 255);
        style.Colors[ImGuiCol_ScrollbarGrabHovered]  = ImVec4(255, 215, 0, 255);
        style.Colors[ImGuiCol_ScrollbarGrabActive]   = ImVec4(255, 215, 0, 255);
        style.Colors[ImGuiCol_CheckMark]             = ImVec4(255, 215, 0, 255);
        style.Colors[ImGuiCol_SliderGrab]            = ImVec4(255, 215, 0, 255);
        style.Colors[ImGuiCol_SliderGrabActive]      = ImVec4(184, 180, 70, 255);

        style.Colors[ImGuiCol_Separator]             = ImColor(235, 133, 23, 255);
        style.Colors[ImGuiCol_SeparatorActive]       = ImColor(235, 133, 23, 255);
        style.Colors[ImGuiCol_SeparatorHovered]      = ImColor(235, 133, 23, 255);

        style.Colors[ImGuiCol_Button]                = ImColor(235, 23, 23, 255);
        style.Colors[ImGuiCol_ButtonActive]          = ImColor(235, 23, 23, 255);
        style.Colors[ImGuiCol_ButtonHovered]         = ImColor(235, 23, 23, 255);

        style.Colors[ImGuiCol_Header]                = ImColor(235, 23, 150, 255);
        style.Colors[ImGuiCol_HeaderActive]          = ImColor(235, 23, 150, 255);
        style.Colors[ImGuiCol_HeaderHovered]         = ImColor(235, 23, 150, 255);

        style.Colors[ImGuiCol_ResizeGrip]            = ImVec4(255, 215, 0, 255);
        style.Colors[ImGuiCol_ResizeGripHovered]     = ImVec4(255, 215, 0, 255);
        style.Colors[ImGuiCol_ResizeGripActive]      = ImVec4(255, 215, 0, 255);
        style.Colors[ImGuiCol_PlotLines]             = ImVec4(255, 215, 0, 255);
        style.Colors[ImGuiCol_PlotLinesHovered]      = ImVec4(255, 215, 0, 255);
        style.Colors[ImGuiCol_PlotHistogram]         = ImVec4(255, 215, 0, 255);
        style.Colors[ImGuiCol_PlotHistogramHovered]  = ImVec4(255, 215, 0, 255);
        style.Colors[ImGuiCol_TextSelectedBg]        = ImVec4(255, 215, 0, 255);


//           style.ScaleAllSizes(std::max(2.5f, density / 400.0f));
}
if (ImGui::Button("Subway escape mode", ImVec2(160, 40))) {
Config.é¢„åˆ¤ = true;
Config.AimBot.IgnoreKnocked = true;
Config.AimBot.IgnoreBot = true;
Config.è‡ªåŠ¨Z = true;
Config.AimBot.å¼€å¯è‡ªç„ = true;
æ˜¾ç¤ºæ–‡å­— = true;
Config.PlayerESP.ä¸Š = true;
Config.é›·è¾¾ = true;
Config.PlayerESP.Alert360 = true;
Config.PlayerESP.Grenade = true;
Config.æ‰‹æŒ = true;
Config.ç‰©èµ„ = true;
Config.PlayerESP.LootBox = true;
Config.PlayerESP.å¼€å¯çº¿æ¡ = true;
Config.PlayerESP.Vehicle = true;
Config.PlayerESP.TeamID = true;
Config.PlayerESP.Distance = true;
Config.PlayerESP.Name = true;
Config.PlayerESP.Skeleton = true;
Config.PlayerESP.Health = true;
Config.PlayerESP.Box = true;
Config.PlayerESP.ActiveEsp = true;
Config.AimBot.AINBOT = AIMBOT::NC;
Config.AimBot.Trigger = EAimTrigger::Any;
Config.åœˆ = true;
Config.SilentAim.Cross = 300.0f;
}
ImGui::SameLine();
if (ImGui::Button("Classic mode", ImVec2(160, 40))) {
Config.é¢„åˆ¤ = true;
Config.AimBot.IgnoreKnocked = true;
Config.AimBot.IgnoreBot = true;
Config.è‡ªåŠ¨Z = true;
Config.AimBot.å¼€å¯è‡ªç„ = true;
æ˜¾ç¤ºæ–‡å­— = true;
Config.PlayerESP.ä¸Š = true;
Config.é›·è¾¾ = true;
Config.PlayerESP.Alert360 = true;
Config.PlayerESP.Grenade = true;
Config.æ‰‹æŒ = true;
Config.ç‰©èµ„ = true;
Config.PlayerESP.LootBox = true;
Config.PlayerESP.å¼€å¯çº¿æ¡ = true;
Config.PlayerESP.Vehicle = true;
Config.PlayerESP.TeamID = true;
Config.PlayerESP.Distance = true;
Config.PlayerESP.Name = true;
Config.PlayerESP.Skeleton = true;
Config.PlayerESP.Health = true;
Config.PlayerESP.Box = true;
Config.PlayerESP.ActiveEsp = true;
Config.HighRisk.Shake = true;
Config.AimBot.AINBOT = AIMBOT::NC;
Config.AimBot.Trigger = EAimTrigger::Any;
Config.åœˆ = true;
Config.SilentAim.Cross = 300.0f;
}
ImGui::Text("These one-button functions are set by the author's own taste \n  If you don't like it, don't spray it. It is recommended to turn on the functions yourself.");
if (ImGui::Combo("UI", &style_idx, "Purple\0Blue\0White\0Yellow\0")) {
                switch (style_idx) {
                        case 0:ImGui::StyleColorsClassic();
                         break;                 
            	        case 1:ImGui::StyleColorsDark();
                         break;         
   		                case 2:ImGui::StyleColorsLight();
                         break;
                        case 3:
                         ImGuiStyle& style = ImGui::GetStyle();
    style.Colors[ImGuiCol_Text]                   = ImColor(255, 0, 0, 255);
    style.Colors[ImGuiCol_TextDisabled]           = ImColor(255, 215, 0, 255);
    style.Colors[ImGuiCol_WindowBg]               = ImColor(255, 215, 0, 155);
    style.Colors[ImGuiCol_ChildBg]                = ImColor(255, 215, 0, 255);
    style.Colors[ImGuiCol_PopupBg]                = ImColor(255, 215, 0, 255);
    style.Colors[ImGuiCol_Border]                 = ImColor(255, 0, 0, 255);
    style.Colors[ImGuiCol_BorderShadow]           = ImColor(255, 215, 0, 255);
    style.Colors[ImGuiCol_FrameBg]                = ImColor(255, 215, 0, 255);
    style.Colors[ImGuiCol_FrameBgHovered]         = ImColor(255, 215, 0, 255);
    style.Colors[ImGuiCol_FrameBgActive]          = ImColor(255, 215, 0, 255);
    style.Colors[ImGuiCol_TitleBg]                = ImColor(255, 215, 0, 255);
    style.Colors[ImGuiCol_TitleBgActive]          = ImColor(255, 215, 0, 255);
    style.Colors[ImGuiCol_TitleBgCollapsed]       = ImColor(255, 215, 0, 255);
    style.Colors[ImGuiCol_MenuBarBg]              = ImColor(255, 215, 0, 255);
    style.Colors[ImGuiCol_ScrollbarBg]            = ImColor(255, 215, 0, 255);
    style.Colors[ImGuiCol_ScrollbarGrab]          = ImColor(255, 0, 0, 255);
    style.Colors[ImGuiCol_ScrollbarGrabHovered]   = ImColor(255, 215, 0, 255);
    style.Colors[ImGuiCol_ScrollbarGrabActive]    = ImColor(255, 0, 0, 255);
    style.Colors[ImGuiCol_CheckMark]              = ImColor(255, 0, 0, 255);
    style.Colors[ImGuiCol_Button]                 = ImColor(255, 215, 0, 255);
    style.Colors[ImGuiCol_ButtonHovered]          = ImColor(255, 215, 0, 255);
    style.Colors[ImGuiCol_ButtonActive]           = ImColor(255, 215, 0, 255);
    style.Colors[ImGuiCol_Header]                 = ImColor(255, 215, 0, 255);
    style.Colors[ImGuiCol_HeaderHovered]          = ImColor(255, 215, 0, 255);
    style.Colors[ImGuiCol_HeaderActive]           = ImColor(255, 215, 0, 255);
    style.Colors[ImGuiCol_Tab]                    = ImColor(255, 215, 0, 255);
    

                         break;
                         
                      
            

  
     			   }
     			   }      				
}
ImGui::TableNextColumn();
                                           }

                            
                            
                            if (tab == 2) {
                            if (è¯­è¨€ == 0) {
if (!Config.PlayerESP.ActiveEsp) {
if (ImGui::Button("æ³¨å…¥è¿›ç¨‹", ImVec2(160, 40))) {
Config.PlayerESP.ActiveEsp = true;
}
ImGui::SameLine();
} else {
if (ImGui::Button("å…³é—­è¿›ç¨‹", ImVec2(160, 40))) {
Config.PlayerESP.ActiveEsp = false;
}
ImGui::SameLine();
}
if (!Feu) {
if (ImGui::Button("ESP ON", ImVec2(160, 40))) {
Feu = true;
Config.PlayerESP.Box = true;
Config.PlayerESP.Skeleton = true;
Config.PlayerESP.Vehicle = true;
Config.PlayerESP.Health = true;
Config.PlayerESP.Name = true;
Config.PlayerESP.Distance = true;
Config.PlayerESP.TeamID = true;
Config.PlayerESP.Grenade = true;
Config.PlayerESP.LootBox = true;
Config.PlayerESP.ä¸Š =true;
Config.æ‰‹æŒ = true;
Config.åŠ¨ä½œ = true;
Config.é›·è¾¾ = true;
Config.PlayerESP.Alert360 = true;
Config.ç‰©èµ„ = true;
}} else {
if (ImGui::Button("ESP OFF", ImVec2(160, 40))) {
Feu = false;
Config.PlayerESP.Box = false;
Config.PlayerESP.Skeleton = false;
Config.PlayerESP.Vehicle = false;
Config.PlayerESP.Health = false;
Config.PlayerESP.Name = false;
Config.PlayerESP.Distance = false;
Config.PlayerESP.TeamID = false;
Config.PlayerESP.Grenade = false;
Config.PlayerESP.LootBox = false;
Config.PlayerESP.ä¸Š =false;
Config.æ‰‹æŒ = false;
Config.åŠ¨ä½œ = false;
Config.é›·è¾¾ = false;
Config.PlayerESP.Alert360 = false;
Config.ç‰©èµ„ = false;
}}
	
			        
if (Config.PlayerESP.ActiveEsp) {
ImGui::Text("! INJECTED PROCESS !");
ImGui::Text("åŒ…å: [com.tencent.ig]");
}
ImGui::Checkbox("æ–¹æ¡†      ", &Config.PlayerESP.Box);
ImGui::SameLine();
ImGui::Checkbox("éª¨éª¼      ", &Config.PlayerESP.Skeleton);
ImGui::SameLine();
ImGui::Checkbox("è¡€é‡      ", &Config.PlayerESP.Health);

ImGui::Checkbox("è·ç¦»      ", &Config.PlayerESP.Distance);
ImGui::SameLine();
ImGui::Checkbox("åç§°      ", &Config.PlayerESP.Name);
ImGui::SameLine();
ImGui::Checkbox("é˜Ÿä¼      ", &Config.PlayerESP.TeamID);

ImGui::Checkbox("è½½å…·      ", &Config.PlayerESP.Vehicle);
ImGui::SameLine();
ImGui::Checkbox("å°„çº¿      ", &Config.PlayerESP.å¼€å¯çº¿æ¡);
ImGui::SameLine();
ImGui::Checkbox("ç›’å­      ", &Config.PlayerESP.LootBox);

ImGui::Checkbox("ç‰©èµ„[åœ°é“] ", &Config.ç‰©èµ„);
ImGui::SameLine();
ImGui::Checkbox("ç‰©èµ„[ç»å…¸] ", &Config.ç‰©èµ„1);
ImGui::SameLine();
ImGui::Checkbox("ç©ºæŠ•      ", &ç©ºæŠ•);

ImGui::Checkbox("é£æœº      ", &é£æœº);
ImGui::SameLine();
ImGui::Checkbox("æ‰‹æŒ      ", &Config.æ‰‹æŒ);
ImGui::SameLine();
ImGui::Checkbox("æŠ•æ·ç‰©    ", &Config.PlayerESP.Grenade);

ImGui::Checkbox("éšè—äººæœº  ", &Config.PlayerESP.NoBot);
ImGui::SameLine();
ImGui::Checkbox("åŠ¨ä½œ      ", &Config.åŠ¨ä½œ);
ImGui::SameLine();
ImGui::Checkbox("é¢„è­¦      ", &Config.PlayerESP.Alert360);

ImGui::Checkbox("é›·è¾¾      ", &Config.é›·è¾¾);
ImGui::SameLine();
ImGui::Checkbox("ç»˜åˆ¶é˜Ÿå‹  ", &Config.PlayerESP.Team);
ImGui::SameLine();
ImGui::Checkbox("æ©ä½“ä¸ç»˜åˆ¶", &Config.PlayerESP.WALL);

static const char *RAD[] = {"çœ‹æ—¥ç‰ˆ", "æ¸…è€…ç‰ˆ", "DNAç‰ˆ"};
ImGui::Text("[é›·è¾¾ç±»å‹]: ");
ImGui::SameLine();
ImGui::Combo("##RADAR", (int *) &Config.PlayerESP.RadarZX, RAD, 3,-1);
ImGui::SliderFloat("é›·è¾¾Xè½´", &Config.RadarX, 0.0f, 100.0f);
ImGui::SliderFloat("é›·è¾¾Yè½´", &Config.RadarY, 0.0f, 40.0f);

ImGui::Text("å°„çº¿ / è®¾ç½®");
//ImGui::Checkbox("æµ‹è¯•åŠŸèƒ½", &UI1);
//ImGui::SameLine();
ImGui::Checkbox("æ˜¾ç¤ºæ–‡å­—", &æ˜¾ç¤ºæ–‡å­—);
/*ImGui::SameLine();
ImGui::Checkbox("åˆ°æœŸæ—¶é—´", &æ˜¾ç¤ºåˆ°æœŸæ—¶é—´);*/
ImGui::SameLine();
if (ImGui::Button("è¿™æœ‰å®ä½“", ImVec2(160, 40))) {
æç¤ºå†…å®¹ = "Level !\nåœä¸‹æ¥çœ‹çœ‹ä»–ä»¬: )\nä¸è¦åœï¼Œå¿«è·‘ï¼Œè¿™å±é™©ï¼: (";
å¥½å¿ƒæç¤º = true;
}
if (Config.PlayerESP.å¼€å¯çº¿æ¡) {
static int g = 2;
  ImGui::RadioButton("æ— ", &g, 1);
  ImGui::SameLine();
  ImGui::RadioButton("é¡¶éƒ¨", &g, 2);
  ImGui::SameLine();
  ImGui::RadioButton("å‡†å¿ƒ", &g, 3);
  ImGui::SameLine();
  ImGui::RadioButton("åº•éƒ¨", &g, 4);
  switch (g) {
  case 1:
  Config.PlayerESP.ä¸Š = false;
  Config.PlayerESP.ä¸­ = false;
  Config.PlayerESP.ä¸‹ = false;
  //Config.PlayerESP.å¼€å¯çº¿æ¡ = false;
  break;
  case 2:
  Config.PlayerESP.ä¸Š = true;
  Config.PlayerESP.ä¸­ = false;
  Config.PlayerESP.ä¸‹ = false;
  break;
  case 3:
  Config.PlayerESP.ä¸Š = false;
  Config.PlayerESP.ä¸­ = true;
  Config.PlayerESP.ä¸‹ = false;
  break;
  case 4:
  Config.PlayerESP.ä¸Š = false;
  Config.PlayerESP.ä¸­ = false;
  Config.PlayerESP.ä¸‹ = true;
  break;
  }}
  
  } if (è¯­è¨€ == 1) {
if (!Config.PlayerESP.ActiveEsp) {
if (ImGui::Button("Injection process", ImVec2(160, 40))) {
Config.PlayerESP.ActiveEsp = true;
}
ImGui::SameLine();
} else {
if (ImGui::Button("Close process", ImVec2(160, 40))) {
Config.PlayerESP.ActiveEsp = false;
}
ImGui::SameLine();
}
if (!Feu) {
if (ImGui::Button("ESP ON", ImVec2(160, 40))) {
Feu = true;
Config.PlayerESP.Box = true;
Config.PlayerESP.Skeleton = true;
Config.PlayerESP.Vehicle = true;
Config.PlayerESP.Health = true;
Config.PlayerESP.Name = true;
Config.PlayerESP.Distance = true;
Config.PlayerESP.TeamID = true;
Config.PlayerESP.Grenade = true;
Config.PlayerESP.LootBox = true;
Config.PlayerESP.ä¸Š =true;
Config.æ‰‹æŒ = true;
Config.åŠ¨ä½œ = true;
Config.é›·è¾¾ = true;
Config.PlayerESP.Alert360 = true;
Config.ç‰©èµ„ = true;
}} else {
if (ImGui::Button("ESP OFF", ImVec2(160, 40))) {
Feu = false;
Config.PlayerESP.Box = false;
Config.PlayerESP.Skeleton = false;
Config.PlayerESP.Vehicle = false;
Config.PlayerESP.Health = false;
Config.PlayerESP.Name = false;
Config.PlayerESP.Distance = false;
Config.PlayerESP.TeamID = false;
Config.PlayerESP.Grenade = false;
Config.PlayerESP.LootBox = false;
Config.PlayerESP.ä¸Š =false;
Config.æ‰‹æŒ = false;
Config.åŠ¨ä½œ = false;
Config.é›·è¾¾ = false;
Config.PlayerESP.Alert360 = false;
Config.ç‰©èµ„ = false;
}}
	
			        
if (Config.PlayerESP.ActiveEsp) {
ImGui::Text("! INJECTED PROCESS !");
ImGui::Text("åŒ…å: [com.tencent.ig]");
}
ImGui::Checkbox("Box      ", &Config.PlayerESP.Box);
ImGui::SameLine();
ImGui::Checkbox("Skeleton      ", &Config.PlayerESP.Skeleton);
ImGui::SameLine();
ImGui::Checkbox("Health      ", &Config.PlayerESP.Health);

ImGui::Checkbox("Distance      ", &Config.PlayerESP.Distance);
ImGui::SameLine();
ImGui::Checkbox("Name      ", &Config.PlayerESP.Name);
ImGui::SameLine();
ImGui::Checkbox("Team ID      ", &Config.PlayerESP.TeamID);

ImGui::Checkbox("Vehicles      ", &Config.PlayerESP.Vehicle);
ImGui::SameLine();
ImGui::Checkbox("Line      ", &Config.PlayerESP.å¼€å¯çº¿æ¡);
ImGui::SameLine();
ImGui::Checkbox("Trophy box      ", &Config.PlayerESP.LootBox);

ImGui::Checkbox("Equipment[Subway] ", &Config.ç‰©èµ„);
ImGui::SameLine();
ImGui::Checkbox("Equipment[Classic] ", &Config.ç‰©èµ„1);
ImGui::SameLine();
ImGui::Checkbox("Airdrop      ", &ç©ºæŠ•);

ImGui::Checkbox("Plane      ", &é£æœº);
ImGui::SameLine();
ImGui::Checkbox("Hand-hold      ", &Config.æ‰‹æŒ);
ImGui::SameLine();
ImGui::Checkbox("Throwing object    ", &Config.PlayerESP.Grenade);

ImGui::Checkbox("Hide robots  ", &Config.PlayerESP.NoBot);
ImGui::SameLine();
ImGui::Checkbox("Action      ", &Config.åŠ¨ä½œ);
ImGui::SameLine();
ImGui::Checkbox("Early warning      ", &Config.PlayerESP.Alert360);

ImGui::Checkbox("Radar      ", &Config.é›·è¾¾);
ImGui::SameLine();
ImGui::Checkbox("Draw teammates  ", &Config.PlayerESP.Team);
ImGui::SameLine();
ImGui::Checkbox("Bunkers are not drawn", &Config.PlayerESP.WALL);

static const char *RAD[] = {"1", "2", "3"};
ImGui::Text("[Radar type]: ");
ImGui::SameLine();
ImGui::Combo("##RADAR", (int *) &Config.PlayerESP.RadarZX, RAD, 3,-1);
ImGui::SliderFloat("Radar X", &Config.RadarX, 0.0f, 100.0f);
ImGui::SliderFloat("Radar Y", &Config.RadarY, 0.0f, 40.0f);

ImGui::Text("Line / Set up");
//ImGui::Checkbox("æµ‹è¯•åŠŸèƒ½", &UI1);
//ImGui::SameLine();
ImGui::Checkbox("Display text", &æ˜¾ç¤ºæ–‡å­—);
/*ImGui::SameLine();
ImGui::Checkbox("Expiration time", &æ˜¾ç¤ºåˆ°æœŸæ—¶é—´);
/*ImGui::SameLine();*/
/*if (ImGui::Button("è¿™æœ‰å®ä½“", ImVec2(160, 40))) {
æç¤ºå†…å®¹ = "Level !\nåœä¸‹æ¥çœ‹çœ‹ä»–ä»¬: )\nä¸è¦åœï¼Œå¿«è·‘ï¼Œè¿™å±é™©ï¼: (";
å¥½å¿ƒæç¤º = true;
}*/
if (Config.PlayerESP.å¼€å¯çº¿æ¡) {
static int g = 2;
  ImGui::RadioButton("Without", &g, 1);
  ImGui::SameLine();
  ImGui::RadioButton("Top", &g, 2);
  ImGui::SameLine();
  ImGui::RadioButton("Ventre", &g, 3);
  ImGui::SameLine();
  ImGui::RadioButton("Bottom", &g, 4);
  switch (g) {
  case 1:
  Config.PlayerESP.ä¸Š = false;
  Config.PlayerESP.ä¸­ = false;
  Config.PlayerESP.ä¸‹ = false;
  //Config.PlayerESP.å¼€å¯çº¿æ¡ = false;
  break;
  case 2:
  Config.PlayerESP.ä¸Š = true;
  Config.PlayerESP.ä¸­ = false;
  Config.PlayerESP.ä¸‹ = false;
  break;
  case 3:
  Config.PlayerESP.ä¸Š = false;
  Config.PlayerESP.ä¸­ = true;
  Config.PlayerESP.ä¸‹ = false;
  break;
  case 4:
  Config.PlayerESP.ä¸Š = false;
  Config.PlayerESP.ä¸­ = false;
  Config.PlayerESP.ä¸‹ = true;
  break;
  }}
  }
ImGui::EndTabItem();
ImGui::TableNextColumn();
}

                    
                           
                           if (tab == 3) {
if (è¯­è¨€ == 0) {


if (ImGui::Checkbox("å¼€å¯è‡ªç„", &Config.AimBot.å¼€å¯è‡ªç„)) {
Config.AimBot.å¼€å¯å­è¿½ = false;
}

if (ImGui::Checkbox("å¼€å¯å­è¿½", &Config.AimBot.å¼€å¯å­è¿½)) {
Config.AimBot.å¼€å¯è‡ªç„ = false;
}
ImGui::Text("!åªèƒ½å¼€ä¸€ä¸ªå¦åˆ™å°å·!\n!å­è¿½ä¸ç¨³ å»ºè®®è‡ªç„!");
if (!Config.AimBot.å¼€å¯è‡ªç„) {
Config.AimBot.AINBOT = AIMBOT::MY;
}
if (Config.AimBot.å¼€å¯è‡ªç„) {
if (è‡ªç„æ¥å£ == 0) {
if (ImGui::Button("è‡ªç„æ¥å£2", ImVec2(160, 40))) {
è‡ªç„æ¥å£ = 1;
}} else if (è‡ªç„æ¥å£ == 1) {
if (ImGui::Button("è‡ªç„æ¥å£1", ImVec2(160, 40))) {
è‡ªç„æ¥å£ = 0;
}}
static const char *AINBOT[] = {"360Â°è§†è§’", "ç¦»å‡†å¿ƒè¿‘", "æ¼å“ªæ‰“å“ª", "å¹³æ»‘ç§»åŠ¨", "å¼ºé”æ•Œäºº", "è‡ªåŠ¨å‹æª", "é€‰æ‹©æ•Œäºº", "éšæœºéƒ¨ä½", "æ²¡æœ‰/å…³é—­"};
ImGui::Text("[è‡ªç„ç±»å‹]: ");
ImGui::SameLine();
ImGui::Combo("##AINBOT", (int *) &Config.AimBot.AINBOT, AINBOT, 9,-1);
//ImGui::Checkbox("360Â°å­è¿½", &Config.AimBot.Enable1);
//ImGui::Checkbox("è‡ªåŠ¨ç„å‡†", &Config.AimBot.Enable);
//ImGui::Checkbox("æ–°è‡ªç„(æ¼æ‰“)", &Eaimbot);
if (Config.AimBot.AINBOT == AIMBOT::LD) {
ImGui::Checkbox("å¼€å¯è‡ªåŠ¨æ¼æ‰“", &æ¼æ‰“);
       if (!æ¼æ‰“) {
                          static const char *Prioritygroup[] = {"å¤´", "éª¨ç›†", "å·¦æ‰‹", "å³æ‰‹", "å·¦è„š", "å³è„š"};
                          static const char *Prioritygroup1[] = {"å¤´", "éª¨ç›†", "å·¦æ‰‹", "å³æ‰‹", "å·¦è„š", "å³è„š"};
                          static const char *Prioritygroup2[] = {"å¤´", "éª¨ç›†", "å·¦æ‰‹", "å³æ‰‹", "å·¦è„š", "å³è„š"};
                          static const char *Prioritygroup3[] = {"å¤´", "éª¨ç›†", "å·¦æ‰‹", "å³æ‰‹", "å·¦è„š", "å³è„š"};
                          static const char *Prioritygroup4[] = {"å¤´", "éª¨ç›†", "å·¦æ‰‹", "å³æ‰‹", "å·¦è„š", "å³è„š"};
                          static const char *Prioritygroup5[] = {"å¤´", "éª¨ç›†", "å·¦æ‰‹", "å³æ‰‹", "å·¦è„š", "å³è„š"};
                          static int temp = 0;
                          if(temp == 0)
                          {
                              Config.SilentAim.PelvisPriority = Aimfirst::Pelvis;
                              Config.SilentAim.LhandPriority = Aimfirst::Lhand;
                              Config.SilentAim.RhandPriority = Aimfirst::Rhand;
                              Config.SilentAim.LfootPriority = Aimfirst::Lfoot;
                              Config.SilentAim.RfootPriority = Aimfirst::Rfoot;
                         
                              temp = 1;
                          }
                          ImGui::Text("[ç¬¬ä¸€ä¼˜å…ˆéƒ¨ä½]: ");
                          ImGui::SameLine();                      
                          ImGui::PushItemWidth(250);
                          ImGui::Combo("##Trigger2", (int *) &Config.SilentAim.HeadPriority, Prioritygroup, 6, 300);
                          ImGui::PopItemWidth();
                          
                          ImGui::Text("[ç¬¬äºŒä¼˜å…ˆéƒ¨ä½]: ");
                          ImGui::SameLine();
                          ImGui::PushItemWidth(250);
                          ImGui::Combo("##Trigger3", (int *) &Config.SilentAim.PelvisPriority, Prioritygroup1, 6, 300);
                          ImGui::PopItemWidth();
                          
                          ImGui::Text("[ç¬¬ä¸‰ä¼˜å…ˆéƒ¨ä½]: ");
                          ImGui::SameLine();
                          ImGui::PushItemWidth(250);
                          ImGui::Combo("##Trigger4", (int *) &Config.SilentAim.LhandPriority, Prioritygroup2, 6, 300);
                          ImGui::PopItemWidth();
                          
                          ImGui::Text("[ç¬¬å››ä¼˜å…ˆéƒ¨ä½]: ");
                          ImGui::SameLine();
                          ImGui::PushItemWidth(250);
                          ImGui::Combo("##Trigger5", (int *) &Config.SilentAim.RhandPriority, Prioritygroup3, 6, 300);
                          ImGui::PopItemWidth();
                          
                          ImGui::Text("[ç¬¬äº”ä¼˜å…ˆéƒ¨ä½]: ");
                          ImGui::SameLine();
                          ImGui::PushItemWidth(250);
                          ImGui::Combo("##Trigger6", (int *) &Config.SilentAim.LfootPriority, Prioritygroup4, 6, 300);
                          ImGui::PopItemWidth();
                          
                          ImGui::Text("[ç¬¬å…­ä¼˜å…ˆéƒ¨ä½]: ");
                          ImGui::SameLine();
                          ImGui::PushItemWidth(250);
                          ImGui::Combo("##Trigger7", (int *) &Config.SilentAim.RfootPriority, Prioritygroup5, 6, 300);
                          ImGui::PopItemWidth();
       }}
ImGui::SliderFloat("Metre",&è‡ªç„è·ç¦», 0.0f, 900.0f);
if (!Config.AimBot.AINBOT == AIMBOT::SJ) {
ImGui::SliderFloat("FOV",&Config.SilentAim.Cross, 0.0f, 1500.0f);
}
ImGui::Text("[ç„å‡†ä½ç½®]: ");
static const char *targets[] = {"å¤´éƒ¨", "èº«ä½“", "é¸¡é¸¡"};
ImGui::Combo("##Target", (int *) &Config.AimBot.Target, targets, 3,-1);
ImGui::Text("[ç„å‡†çŠ¶æ€]: ");
static const char *triggers[] = {"æš‚æ— ", "å¼€ç«", "å¼€é•œ", "å¼€é•œ&å¼€ç«", "å¼€ç«/å¼€é•œ"};
ImGui::Combo("##Trigger", (int *) &Config.AimBot.Trigger, triggers, 5,-1);
if (!Config.AimBot.AINBOT == AIMBOT::SJ) {
ImGui::Checkbox("FOVæ–¹æ¡†", &Config.åœˆ);
ImGui::SameLine();
}  
ImGui::Checkbox("å¿½è§†å€’åœ°", &Config.AimBot.IgnoreKnocked);
ImGui::SameLine();
ImGui::Checkbox("å¿½è§†äººæœº", &Config.AimBot.IgnoreBot);
ImGui::SameLine();
ImGui::Checkbox("è‡ªåŠ¨å‹æª", &Config.è‡ªåŠ¨Z);
ImGui::SameLine();
ImGui::Checkbox("ç„å‡†é¢„åˆ¤", &Config.é¢„åˆ¤);

if (!show_è°ƒè¯•) {
if (ImGui::Button("DEBUG[ON]", ImVec2(230 - 15, 50)))
    show_è°ƒè¯• = true;
} else {
if (ImGui::Button("DEBUG[OFF]", ImVec2(230 - 15, 50)))
    show_è°ƒè¯• = false;
}}


if (!Config.AimBot.å¼€å¯å­è¿½) {
Config.SilentAim.AINBOTA = AIMBOTA::MYZZ;
}
if (Config.AimBot.å¼€å¯å­è¿½) {

if (ImGui::Button("[å­å¼¹è¿½è¸ª]", ImVec2(160, 40))) {
æç¤ºå†…å®¹ = "ä½ ä»–å¦ˆç‚¹ä½ å¦ˆ ä½ æ˜¯ä¸æ˜¯å‚»é€¼\nè¿™ä»–å¦ˆæ˜¯èƒ½ç‚¹çš„ä¸œè¥¿å—?\nä½ é£Ÿä¸é£Ÿæ²¹é¥¼\næœ‰æ²¡æœ‰æ ‘æ\næœ‰æ²¡æœ‰è”æ.";
å¥½å¿ƒæç¤º = true;
}
static const char *SilentAim[] = {"ç¦»å‡†æ˜Ÿè¿‘", "360Â°å­è¿½", "æ²¡æœ‰/å…³é—­"};
ImGui::Text("[å­è¿½ç±»å‹]: ");
ImGui::SameLine();
ImGui::Combo("##SilentAim", (int *) &Config.SilentAim.AINBOTA, SilentAim, 3,-1);
ImGui::Spacing();
ImGui::Text("[å­è¿½ä½ç½®]: ");
ImGui::Spacing();
static const char *targets[] = {"å¤´", "èƒ¸éƒ¨", "é¸¡é¸¡"};
ImGui::Combo("##Target", (int *) &Config.SilentAim.Target, targets, 3, -1);
ImGui::Text("[å­è¿½çŠ¶æ€]: ");
ImGui::Spacing();
static const char *triggers[] = {"æš‚æ— ", "å¼€ç«", "å¼€é•œ", "å¼€é•œ&å¼€ç«", "å¼€ç«/å¼€é•œ"};
ImGui::Combo("##Trigger", (int *) &Config.SilentAim.Trigger, triggers, 5, -1);
ImGui::SliderFloat("FOV",&Config.SilentAim.Cross, 0.0f, 1500.0f);
ImGui::Checkbox("FOVæ–¹æ¡†", &Config.åœˆ);
ImGui::SameLine();
ImGui::Checkbox("å¿½ç•¥å€’åœ°", &Config.SilentAim.IgnoreKnocked);
ImGui::SameLine();
ImGui::Checkbox("æ©ä½“æ£€æµ‹", &Config.SilentAim.VisCheck);
ImGui::SameLine();
ImGui::Checkbox("å¿½ç•¥äººæœº", &Config.SilentAim.IgnoreBot);
}
                  

} else if (è¯­è¨€ == 1) {
if (ImGui::Checkbox("Starting aimbot", &Config.AimBot.å¼€å¯è‡ªç„)) {
Config.AimBot.å¼€å¯å­è¿½ = false;
}

if (ImGui::Checkbox("Starting bullet", &Config.AimBot.å¼€å¯å­è¿½)) {
Config.AimBot.å¼€å¯è‡ªç„ = false;
}
ImGui::Text("!Bullet ban! Suggestion Aimbot");
if (!Config.AimBot.å¼€å¯è‡ªç„) {
Config.AimBot.AINBOT = AIMBOT::MY;
}
if (Config.AimBot.å¼€å¯è‡ªç„) {
if (è‡ªç„æ¥å£ == 0) {
if (ImGui::Button("Joggle 2", ImVec2(160, 40))) {
è‡ªç„æ¥å£ = 1;
}} else if (è‡ªç„æ¥å£ == 1) {
if (ImGui::Button("Joggle 1", ImVec2(160, 40))) {
è‡ªç„æ¥å£ = 0;
}}
static const char *AINBOT[] = {"360Â°Visual angle", "Close to the center of sight", "Hit where it leaks", "Smooth movement", "Lock the enemy by force", "Automatic gun pressing", "Choose the enemy", "Random site", "Not have/Close"};
ImGui::Text("[Type]: ");
ImGui::SameLine();
ImGui::Combo("##AINBOT", (int *) &Config.AimBot.AINBOT, AINBOT, 9,-1);
//ImGui::Checkbox("360Â°å­è¿½", &Config.AimBot.Enable1);
//ImGui::Checkbox("è‡ªåŠ¨ç„å‡†", &Config.AimBot.Enable);
//ImGui::Checkbox("æ–°è‡ªç„(æ¼æ‰“)", &Eaimbot);
if (Config.AimBot.AINBOT == AIMBOT::LD) {
ImGui::Checkbox("Automatic aiming position", &æ¼æ‰“);
       if (!æ¼æ‰“) {
                          static const char *Prioritygroup[] = {"Head", "Basin", "Left hand", "Right hand", "Left crus", "Right foot"};
                          static const char *Prioritygroup1[] = {"Head", "Basin", "Left hand", "Right hand", "Left crus", "Right foot"};
                          static const char *Prioritygroup2[] = {"Head", "Basin", "Left hand", "Right hand", "Left crus", "Right foot"};
                          static const char *Prioritygroup3[] = {"Head", "Basin", "Left hand", "Right hand", "Left crus", "Right foot"};
                          static const char *Prioritygroup4[] = {"Head", "Basin", "Left hand", "Right hand", "Left crus", "Right foot"};
                          static const char *Prioritygroup5[] = {"Head", "Basin", "Left hand", "Right hand", "Left crus", "Right foot"};
                          static int temp = 0;
                          if(temp == 0)
                          {
                              Config.SilentAim.PelvisPriority = Aimfirst::Pelvis;
                              Config.SilentAim.LhandPriority = Aimfirst::Lhand;
                              Config.SilentAim.RhandPriority = Aimfirst::Rhand;
                              Config.SilentAim.LfootPriority = Aimfirst::Lfoot;
                              Config.SilentAim.RfootPriority = Aimfirst::Rfoot;
                         
                              temp = 1;
                          }
                          ImGui::Text("[1]: ");
                          ImGui::SameLine();                      
                          ImGui::PushItemWidth(250);
                          ImGui::Combo("##Trigger2", (int *) &Config.SilentAim.HeadPriority, Prioritygroup, 6, 300);
                          ImGui::PopItemWidth();
                          
                          ImGui::Text("[2]: ");
                          ImGui::SameLine();
                          ImGui::PushItemWidth(250);
                          ImGui::Combo("##Trigger3", (int *) &Config.SilentAim.PelvisPriority, Prioritygroup1, 6, 300);
                          ImGui::PopItemWidth();
                          
                          ImGui::Text("[3]: ");
                          ImGui::SameLine();
                          ImGui::PushItemWidth(250);
                          ImGui::Combo("##Trigger4", (int *) &Config.SilentAim.LhandPriority, Prioritygroup2, 6, 300);
                          ImGui::PopItemWidth();
                          
                          ImGui::Text("[4]: ");
                          ImGui::SameLine();
                          ImGui::PushItemWidth(250);
                          ImGui::Combo("##Trigger5", (int *) &Config.SilentAim.RhandPriority, Prioritygroup3, 6, 300);
                          ImGui::PopItemWidth();
                          
                          ImGui::Text("[5]: ");
                          ImGui::SameLine();
                          ImGui::PushItemWidth(250);
                          ImGui::Combo("##Trigger6", (int *) &Config.SilentAim.LfootPriority, Prioritygroup4, 6, 300);
                          ImGui::PopItemWidth();
                          
                          ImGui::Text("[6]: ");
                          ImGui::SameLine();
                          ImGui::PushItemWidth(250);
                          ImGui::Combo("##Trigger7", (int *) &Config.SilentAim.RfootPriority, Prioritygroup5, 6, 300);
                          ImGui::PopItemWidth();
       }}
ImGui::SliderFloat("Metre",&è‡ªç„è·ç¦», 0.0f, 900.0f);
if (!Config.AimBot.AINBOT == AIMBOT::SJ) {
ImGui::SliderFloat("FOV",&Config.SilentAim.Cross, 0.0f, 1500.0f);
}
ImGui::Text("[Location]: ");
static const char *targets[] = {"Head", "Body", "Dick"};
ImGui::Combo("##Target", (int *) &Config.AimBot.Target, targets, 3,-1);
ImGui::Text("[Aimbot]: ");
static const char *triggers[] = {"Not have", "Fire", "Shooting", "Shooting&Fire", "Fire/Shooting"};
ImGui::Combo("##Trigger", (int *) &Config.AimBot.Trigger, triggers, 5,-1);
if (!Config.AimBot.AINBOT == AIMBOT::SJ) {
ImGui::Checkbox("FOV", &Config.åœˆ);
ImGui::SameLine();
}  
ImGui::Checkbox("Ignore Beingknocked", &Config.AimBot.IgnoreKnocked);
ImGui::SameLine();
ImGui::Checkbox("Ignore robots", &Config.AimBot.IgnoreBot);
ImGui::SameLine();
ImGui::Checkbox("Automatic gun pressing", &Config.è‡ªåŠ¨Z);
ImGui::SameLine();
ImGui::Checkbox("Aim and predict", &Config.é¢„åˆ¤);

if (!show_è°ƒè¯•) {
if (ImGui::Button("DEBUG[ON]", ImVec2(230 - 15, 50)))
    show_è°ƒè¯• = true;
} else {
if (ImGui::Button("DEBUG[OFF]", ImVec2(230 - 15, 50)))
    show_è°ƒè¯• = false;
}}


if (!Config.AimBot.å¼€å¯å­è¿½) {
Config.SilentAim.AINBOTA = AIMBOTA::MYZZ;
}
if (Config.AimBot.å¼€å¯å­è¿½) {

/*if (ImGui::Button("[å­è›‹è¿½è¸ª]", ImVec2(160, 40))) {
æç¤ºå†…å®¹ = "ä½ ä»–å¦ˆç‚¹ä½ å¦ˆ ä½ æ˜¯ä¸æ˜¯å‚»é€¼\nè¿™ä»–å¦ˆæ˜¯èƒ½ç‚¹çš„ä¸œè¥¿å—?\nä½ é£Ÿä¸é£Ÿæ²¹é¥¼\næœ‰æ²¡æœ‰æ ‘æ\næœ‰æ²¡æœ‰è”æ.";
å¥½å¿ƒæç¤º = true;
}*/
static const char *SilentAim[] = {"Close to the sight", "360Â°", "Not have/Close"};
ImGui::Text("[Type]: ");
ImGui::SameLine();
ImGui::Combo("##SilentAim", (int *) &Config.SilentAim.AINBOTA, SilentAim, 3,-1);
ImGui::Spacing();
ImGui::Text("[Location]: ");
ImGui::Spacing();
static const char *targets[] = {"Head", "Chest", "Dick"};
ImGui::Combo("##Target", (int *) &Config.SilentAim.Target, targets, 3, -1);
ImGui::Text("[Bullet]: ");
ImGui::Spacing();
static const char *triggers[] = {"Not have", "Fire", "Shooting", "Shooting&Fire", "Fire/Shooting"};
ImGui::Combo("##Trigger", (int *) &Config.SilentAim.Trigger, triggers, 5, -1);
ImGui::SliderFloat("FOV",&Config.SilentAim.Cross, 0.0f, 1500.0f);
ImGui::Checkbox("FOV", &Config.åœˆ);
ImGui::SameLine();
ImGui::Checkbox("Ignore Beingknocked", &Config.SilentAim.IgnoreKnocked);
ImGui::SameLine();
ImGui::Checkbox("Observe visibility", &Config.SilentAim.VisCheck);
ImGui::SameLine();
ImGui::Checkbox("Ignore robots", &Config.SilentAim.IgnoreBot);
}
}
ImGui::EndTabItem();
ImGui::TableNextColumn();
}

if (tab == 4) {
if (è¯­è¨€ == 0) {
ImGui::Text("å¿…è¯»æ•™å­¦: \n 1.ä¸ºä»€ä¹ˆæ¸¸æˆä¸Šé¢ä¼šæœ‰4ä¸ªå›¾æ ‡\n é‚£æ˜¯æ˜¾ç¤ºäººæ•°ç”¨çš„\n çº¢è‰²æ˜¯é™„è¿‘çœŸäººäººæ•°\n ç»¿è‰²æ˜¯é™„è¿‘å…¨éƒ¨äººæœºäººæ•°\n é»„è‰²æ˜¯é™„è¿‘æ‰€æœ‰äºº\n é»‘è‰²æ˜¯é™„è¿‘å¯ä»¥çœ‹è§ä½ çš„äºº.\n 2.ä¸ºä»€ä¹ˆå¼€å­è¿½æ‹¿æªé—ªé€€\n æ˜¯å› ä¸ºæ²¡æœ‰é€‚é…IDX.\n 3.ä¸ºä»€ä¹ˆä¼šé—ªé€€\n å› ä¸ºå›½é™…æœæœ‰MD5æ£€æµ‹è¿˜æ²¡è¿‡.\n 4.ä¸ºä»€ä¹ˆå¼€äº†åŠ é€Ÿç­‰ä¸å¯å…³é—­\n å› ä¸ºä½œè€…å¤ªæ‡’äº†.\n 5.ç©åœ°é“é€ƒç”Ÿå»ºè®®å¼€ä»€ä¹ˆåŠŸèƒ½\n å¯ä»¥ç‚¹å‡»ä¸€é”®åŠŸèƒ½.");
} if (è¯­è¨€ == 1) {
ImGui::Text("Don't want to translate");
}
ImGui::EndTabItem();
ImGui::TableNextColumn();
}

                           
                            if (tab == 5) {
                            if (è¯­è¨€ == 0) {
              ImGui::Text("! å±é™©SDK å¼€äº†å°å·åˆ«æ‰¾æˆ‘ !");
              ImGui::Checkbox("å¹³æ¿è§†è§’", &WideView);
              
              ImGui::Checkbox("é˜²æŠ–", &Config.HighRisk.Shake);
              
              ImGui::Checkbox("èšç‚¹", &Config.HighRisk.Cross);
              
              ImGui::Checkbox("æ— åååŠ›", &Config.HighRisk.Recoil);
                  
              ImGui::Checkbox("å‡»ä¸­ç‰¹æ•ˆ", &Config.HighRisk.HitEffect);
                  
              ImGui::Checkbox("å°„é€ŸåŠ å¿«", &Config.HighRisk.Instant);
              
              ImGui::Checkbox("90å¸§", &Unlock);
                  
              if (ImGui::Button("åŠ é€Ÿé¢æ¿", ImVec2(230 - 15, 50)))
                  åŠ é€Ÿ = true;
              
              if (ImGui::Button("é£å¤©é¢æ¿", ImVec2(230 - 15, 50)))
                  é£å¤©å¼€ = true;
                  } else if (è¯­è¨€ == 1) {
                  ImGui::Text("! danger !");
              ImGui::Checkbox("Flat viewing angle", &WideView);
              
              if (ImGui::Button("SDK Backless", ImVec2(230 - 15, 50)))
                  Config.HighRisk.Recoil = true;
              
              if (ImGui::Button("SDK Accumulation", ImVec2(230 - 15, 50)))
                  Config.HighRisk.Cross = true;
              
              if (ImGui::Button("SDK Do not Shake", ImVec2(230 - 15, 50)))
                  Config.HighRisk.Shake = true;
                  
              if (ImGui::Button("SDK Instantaneous hit", ImVec2(230 - 15, 50)))
                  Config.HighRisk.Instant = true;
                  
              if (ImGui::Button("SDK Killing special effect", ImVec2(230 - 15, 50)))
                  Config.HighRisk.HitEffect = true;
              
              if (ImGui::Button("90FPS", ImVec2(230 - 15, 50)))
                  Unlock = true;
                  
              if (ImGui::Button("Acceleration panel", ImVec2(230 - 15, 50)))
                  åŠ é€Ÿ = true;
              
              if (ImGui::Button("Feitian panel", ImVec2(230 - 15, 50)))
                  é£å¤©å¼€ = true;
                  }
/*              if (ImGui::Button("é¸¡ä½ å¤ªç¾", ImVec2(160, 40))) {
æç¤ºå†…å®¹ = "é¸¡ä½ å¤ªç¾";
å¥½å¿ƒæç¤º = true;
}*/
             
                                                        
                    ImGui::EndTabItem();
              ImGui::TableNextColumn();
                         }
                         if (tab == 6) {
                         if (è¯­è¨€ == 0) {
                  ImGui::Text("ç¨³å®šå†…å­˜ æœ€è¿‘æ£€æµ‹åˆ«å¼€");
                  
                  if (ImGui::Button("ç¨³å®šæ— å", ImVec2(230 - 15, 50)))
                  æ— å = true;
                  
                  if (ImGui::Button("ç¨³å®šé˜²æŠ–", ImVec2(230 - 15, 50)))
                  é˜²æŠ– = true;
                  
                  if (ImGui::Button("ç¨³å®šç¬å‡»", ImVec2(230 - 15, 50)))
                  ç¬å‡» = true;
                  
                  if (ImGui::Button("ç¨³å®šèšç‚¹", ImVec2(230 - 15, 50)))
                  èšç‚¹ = true;
                  
                  if (ImGui::Button("å†…å­˜è‡ªç„", ImVec2(230 - 15, 50)))
                  è‡ªç„ = true;
                  
                  if (ImGui::Button("å†…å­˜åŠ é€Ÿå¼€", ImVec2(230 - 15, 50))) {
                  ç¨³å®šåŠ é€Ÿå¼€ = true;
                  ç¨³å®šåŠ é€Ÿå…³ = false;
                  }
                  
                  if (ImGui::Button("å†…å­˜åŠ é€Ÿå…³", ImVec2(230 - 15, 50))) {
                  ç¨³å®šåŠ é€Ÿå…³ = true;
                  ç¨³å®šåŠ é€Ÿå¼€ = false;
                  }
                  
                  } else if (è¯­è¨€ == 1) {
                  ImGui::Text("Stable memory");
                  
                  if (ImGui::Button("Memory without backseat", ImVec2(230 - 15, 50)))
                  æ— å = true;
                  
                  if (ImGui::Button("Memory anti-shake", ImVec2(230 - 15, 50)))
                  é˜²æŠ– = true;
                  
                  if (ImGui::Button("Memory instant hit", ImVec2(230 - 15, 50)))
                  ç¬å‡» = true;
                  
                  if (ImGui::Button("Memory aggregation point", ImVec2(230 - 15, 50)))
                  èšç‚¹ = true;
                  
                  if (ImGui::Button("Memory aimbot", ImVec2(230 - 15, 50)))
                  è‡ªç„ = true;
                  
                  if (ImGui::Button("Memory acceleration", ImVec2(230 - 15, 50))) {
                  ç¨³å®šåŠ é€Ÿå¼€ = true;
                  ç¨³å®šåŠ é€Ÿå…³ = false;
                  }
                  
                  if (ImGui::Button("Memory acceleration off", ImVec2(230 - 15, 50))) {
                  ç¨³å®šåŠ é€Ÿå…³ = true;
                  ç¨³å®šåŠ é€Ÿå¼€ = false;
                  }
                  
                  }
                  
                  
                         ImGui::EndTabItem();
              ImGui::TableNextColumn();
                         }
                         
                         
                         

                         }
                         }
                         }
                         
                         
                         


             
             
//             if (å½©è‰²æ–‡å­—) {
//             ImGuiStyle& style = ImGui::GetStyle();
//style.Colors[ImGuiCol_Text]                   = ImColor(æ–‡å­—1, æ–‡å­—2, æ–‡å­—3, 255);
//             }
				
}

                 
                     
                //love.SBX
              //KL NIKE Mod 4.0 Pro+
              //FULL OF Brutality
                          //KL NIKE AimBot ProMax
                       
                      
				             	
			                
              
		
		

		
        ImGui::End();
        ImGui::Render();

        ImGui_ImplOpenGL3_RenderDrawData(ImGui::GetDrawData());

        return orig_eglSwapBuffers(dpy, surface);
    }


int32_t (*orig_onInputEvent)(struct android_app *app, AInputEvent *inputEvent);
int32_t onInputEvent(struct android_app *app, AInputEvent *inputEvent)
{
	if (initImGui)
	{
		ImGui_ImplAndroid_HandleInputEvent(inputEvent, {(float)screenWidth / (float)glWidth, (float)screenHeight / (float)glHeight});
	}
	return orig_onInputEvent(app, inputEvent);
}




#define SLEEP_TIME 1000LL / 60LL
[[noreturn]] void *maps_thread(void *) {
    while (true) {
   auto t1 = std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::system_clock::now().time_since_epoch()).count();
               std::vector<sRegion> tmp;
            char line[512];
            FILE *f = fopen("/proc/self/maps", "r");;
            if (f) {
                while (fgets(line, sizeof line, f)) {
                    uintptr_t start, end;
                    char tmpProt[16];
                    if (sscanf(line, "%" PRIXPTR "-%" PRIXPTR " %16s %*s %*s %*s %*s", &start, &end, tmpProt) > 0) {
                        if (tmpProt[0] != 'r') {
                            tmp.push_back({start, end});
                        }
                    }
                }
                fclose(f);
            }
            trapRegions = tmp;
        auto objs = UObject::GetGlobalObjects();
        for (int i = 0; i < objs.Num(); i++) {
            auto Object = objs.GetByIndex(i);
   if (isObjectInvalid(Object))
                continue;
if (WideView) {
if (Object->IsA(ULocalPlayer::StaticClass())) {
auto playerChar = (ULocalPlayer *) Object;
playerChar->AspectRatioAxisConstraint = EAspectRatioAxisConstraint::AspectRatio_MaintainYFOV;
}}else{
if (Object->IsA(ULocalPlayer::StaticClass())) {
auto playerChar = (ULocalPlayer *) Object;
playerChar->AspectRatioAxisConstraint = EAspectRatioAxisConstraint::AspectRatio_MaintainXFOV;
}
}


if (é£å¤©) {
if (Object->IsA(UPhysicsSettings::StaticClass())) {
auto playerChar = (UPhysicsSettings *) Object;
playerChar->DefaultGravityZ=900.00f;
}}
        
                 
if (Unlock) {
if (Object->IsA(USTExtraGameInstance::StaticClass())) {
auto playerChar = (USTExtraGameInstance *) Object;      
playerChar->UserDetailSetting.PUBGDeviceFPSDef = 90.0f;
playerChar->UserDetailSetting.PUBGDeviceFPSLow = 90.0f;
playerChar->UserDetailSetting.PUBGDeviceFPSMid = 90.0f;
playerChar->UserDetailSetting.PUBGDeviceFPSHigh = 90.0f;
playerChar->UserDetailSetting.PUBGDeviceFPSHDR = 90.0f;
playerChar->UserDetailSetting.PUBGDeviceFPSUltralHigh = 90.0f;
}}}



auto td = std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::system_clock::now().time_since_epoch()).count() - t1;
std::this_thread::sleep_for(std::chrono::milliseconds(std::max(std::min(0LL, SLEEP_TIME - td),SLEEP_TIME)));
}}












void *main_thread(void *) {	

	    UE4 = Tools::GetBaseAddress("libUE4.so");
        while (!UE4) {
            UE4 = Tools::GetBaseAddress("libUE4.so");
            sleep(1);
        }
        
  
        anort = Tools::GetBaseAddress("libanort.so");
        while (!anort) {
            anort = Tools::GetBaseAddress("libanort.so");
            sleep(1);
        }
      
        
        anogs = Tools::GetBaseAddress("libanogs.so");
        while (!anogs) {
        anogs = Tools::GetBaseAddress("libanogs.so");
        sleep(1);
        }
        

        
        
	while (!g_App)
	{
		g_App = *(android_app **)(UE4 + GNativeAndroidApp_Offset);
		sleep(1);
	}
	
	
	
	while (!g_App->onInputEvent)
		sleep(1);
		
    orig_onInputEvent = decltype(orig_onInputEvent)(g_App->onInputEvent);
	g_App->onInputEvent = onInputEvent;
		
	
		
    FName::GNames = GetGNames();
	while (!FName::GNames)
	{
		FName::GNames = GetGNames();
		sleep(1);
	}
	UObject::GUObjectArray = (FUObjectArray *)(UE4 + GUObject_Offset);
	
	



    
	orig_onInputEvent = decltype(orig_onInputEvent)(g_App->onInputEvent);
    g_App->onInputEvent = onInputEvent;

    plthook_t *plthook;
    if (plthook_open(&plthook, "libUE4.so") == 0) {
        plthook_replace(plthook, "eglSwapBuffers", (void *) _eglSwapBuffers, (void **) &orig_eglSwapBuffers);
        plthook_close(plthook);
    }
 
 Tools::Hook((void *) DobbySymbolResolver(OBFUSCATE("/system/lib/libEGL.so"), OBFUSCATE("eglSwapBuffers")), (void *) _eglSwapBuffers, (void **) &orig_eglSwapBuffers);
	
	
	pthread_t t;
	pthread_create(&t, 0, maps_thread, 0);
	items_datakl = json::parse(JSON_ITEMSSKL);
	itemss_datakl = json::parse(JSON_ITEMSSKL);
	itemsss_datakl = json::parse(JSON_ITEMSS);
	return 0;
}

__attribute__((constructor)) void _init() {
    pthread_t t;
//    pthread_create(&t, 0, Memory_thread, 0);
    pthread_create(&t, 0, main_thread, 0);
}



